{
  "openapi": "3.0.1",
  "info": {
    "title": "API Reference",
    "description": "API reference for the StackRox Security Platform",
    "version": "1"
  },
  "servers": [
    {
      "url": "/"
    }
  ],
  "paths": {
    "/v1/alerts": {
      "get": {
        "tags": [
          "AlertService"
        ],
        "summary": "ListAlerts returns the slim list version of the alerts.",
        "description": "**Pagination Behavior:**\n- Default limit: 1000 alerts per request\n- Maximum limit: 1000 alerts per request\n- Default sorting: By violation time (newest first)\n- Supports custom pagination and sorting\n\n**Response Format:**\n- Returns ListAlert objects (slimmed down version)\n- Includes essential fields for list views\n- Optimized for UI display and bulk operations\n\n**Query Examples:**\n- \"Severity:HIGH_SEVERITY\" - High severity alerts\n- \"Cluster:production\" - Production cluster alerts\n- \"Violation State:ACTIVE\" - Active alerts only",
        "operationId": "AlertService_ListAlerts",
        "parameters": [
          {
            "name": "query",
            "in": "query",
            "description": "Search query string using StackRox search syntax.\nIf empty, returns all alerts (subject to pagination limits).\nSee https://docs.stackrox.com/docs/use-roxctl/#search for query syntax.",
            "schema": {
              "nullable": true,
              "type": "string"
            }
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "pagination.sortOption.field",
            "in": "query",
            "schema": {
              "nullable": true,
              "type": "string"
            }
          },
          {
            "name": "pagination.sortOption.reversed",
            "in": "query",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "pagination.sortOption.aggregateBy.aggrFunc",
            "in": "query",
            "schema": {
              "nullable": true,
              "type": "string",
              "default": "UNSET",
              "enum": [
                "UNSET",
                "COUNT",
                "MIN",
                "MAX"
              ]
            }
          },
          {
            "name": "pagination.sortOption.aggregateBy.distinct",
            "in": "query",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "alerts": {
                      "type": "array",
                      "description": "List of alerts matching the search criteria.\nLimited to maximum 1000 alerts per request.",
                      "items": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "id": {
                            "nullable": true,
                            "type": "string"
                          },
                          "lifecycleStage": {
                            "nullable": true,
                            "type": "string",
                            "default": "DEPLOY",
                            "enum": [
                              "DEPLOY",
                              "BUILD",
                              "RUNTIME"
                            ]
                          },
                          "time": {
                            "nullable": true,
                            "type": "string",
                            "format": "date-time"
                          },
                          "policy": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "id": {
                                "nullable": true,
                                "type": "string"
                              },
                              "name": {
                                "nullable": true,
                                "type": "string"
                              },
                              "severity": {
                                "nullable": true,
                                "type": "string",
                                "default": "UNSET_SEVERITY",
                                "enum": [
                                  "UNSET_SEVERITY",
                                  "LOW_SEVERITY",
                                  "MEDIUM_SEVERITY",
                                  "HIGH_SEVERITY",
                                  "CRITICAL_SEVERITY"
                                ]
                              },
                              "description": {
                                "nullable": true,
                                "type": "string"
                              },
                              "categories": {
                                "type": "array",
                                "items": {
                                  "nullable": true,
                                  "type": "string"
                                }
                              },
                              "developerInternalFields": {
                                "nullable": true,
                                "type": "object",
                                "properties": {
                                  "SORTName": {
                                    "nullable": true,
                                    "type": "string"
                                  }
                                }
                              }
                            }
                          },
                          "state": {
                            "nullable": true,
                            "type": "string",
                            "description": " - ACTIVE: Alert is currently active and requires attention.\nThis is the default state for new alerts.\nActive alerts can be resolved but cannot be deleted.\n - RESOLVED: Alert has been resolved (manually or automatically).\nResolved alerts can be deleted for maintenance purposes.\nOnly RESOLVED alerts can be deleted via DeleteAlerts API.\n - ATTEMPTED: Enforcement action was attempted but failed.\nThese alerts can be resolved to acknowledge the failed enforcement.\nCommon for alerts where enforcement actions are not fully configured.",
                            "default": "ACTIVE",
                            "enum": [
                              "ACTIVE",
                              "RESOLVED",
                              "ATTEMPTED"
                            ]
                          },
                          "enforcementCount": {
                            "type": "integer",
                            "format": "int32"
                          },
                          "enforcementAction": {
                            "nullable": true,
                            "type": "string",
                            "description": " - FAIL_KUBE_REQUEST_ENFORCEMENT: FAIL_KUBE_REQUEST_ENFORCEMENT takes effect only if admission control webhook is enabled to listen on exec and port-forward events.\n - FAIL_DEPLOYMENT_CREATE_ENFORCEMENT: FAIL_DEPLOYMENT_CREATE_ENFORCEMENT takes effect only if admission control webhook is configured to enforce on object creates.\n - FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT: FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT takes effect only if admission control webhook is configured to enforce on object updates.",
                            "default": "UNSET_ENFORCEMENT",
                            "enum": [
                              "UNSET_ENFORCEMENT",
                              "SCALE_TO_ZERO_ENFORCEMENT",
                              "UNSATISFIABLE_NODE_CONSTRAINT_ENFORCEMENT",
                              "KILL_POD_ENFORCEMENT",
                              "FAIL_BUILD_ENFORCEMENT",
                              "FAIL_KUBE_REQUEST_ENFORCEMENT",
                              "FAIL_DEPLOYMENT_CREATE_ENFORCEMENT",
                              "FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT"
                            ]
                          },
                          "commonEntityInfo": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "clusterName": {
                                "nullable": true,
                                "type": "string"
                              },
                              "namespace": {
                                "nullable": true,
                                "type": "string"
                              },
                              "clusterId": {
                                "nullable": true,
                                "type": "string"
                              },
                              "namespaceId": {
                                "nullable": true,
                                "type": "string"
                              },
                              "resourceType": {
                                "title": "A special ListAlert-only enumeration of all resource types. Unlike Alert.Resource.ResourceType this also includes deployment as a type\nThis must be kept in sync with Alert.Resource.ResourceType (excluding the deployment value)",
                                "nullable": true,
                                "type": "string",
                                "default": "DEPLOYMENT",
                                "enum": [
                                  "DEPLOYMENT",
                                  "SECRETS",
                                  "CONFIGMAPS",
                                  "CLUSTER_ROLES",
                                  "CLUSTER_ROLE_BINDINGS",
                                  "NETWORK_POLICIES",
                                  "SECURITY_CONTEXT_CONSTRAINTS",
                                  "EGRESS_FIREWALLS"
                                ]
                              }
                            },
                            "description": "Fields common to all entities that an alert might belong to."
                          },
                          "deployment": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "id": {
                                "nullable": true,
                                "type": "string"
                              },
                              "name": {
                                "nullable": true,
                                "type": "string"
                              },
                              "clusterName": {
                                "nullable": true,
                                "type": "string",
                                "description": "This field is deprecated and can be found in CommonEntityInfo. It will be removed from here in a future release.\n\nThis field has moved to CommonEntityInfo"
                              },
                              "namespace": {
                                "nullable": true,
                                "type": "string",
                                "description": "This field is deprecated and can be found in CommonEntityInfo. It will be removed from here in a future release.\n\nThis field has moved to CommonEntityInfo"
                              },
                              "clusterId": {
                                "nullable": true,
                                "type": "string",
                                "description": "This field is deprecated and can be found in CommonEntityInfo. It will be removed from here in a future release.\n\nThis field has moved to CommonEntityInfo"
                              },
                              "inactive": {
                                "type": "boolean"
                              },
                              "namespaceId": {
                                "nullable": true,
                                "type": "string",
                                "description": "This field is deprecated and can be found in CommonEntityInfo. It will be removed from here in a future release.\n\nThis field has moved to CommonEntityInfo"
                              },
                              "deploymentType": {
                                "nullable": true,
                                "type": "string"
                              }
                            }
                          },
                          "resource": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "name": {
                                "nullable": true,
                                "type": "string"
                              }
                            }
                          }
                        }
                      }
                    }
                  },
                  "description": "ListAlertsResponse contains the list of alerts matching the request criteria."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "application/json": {
                "schema": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "nullable": true,
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "@type": {
                            "nullable": true,
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com. As of May 2023, there are no widely used type server\nimplementations and no plans to implement one.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          }
                        },
                        "additionalProperties": {
                          "nullable": true,
                          "type": "object"
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n    // or ...\n    if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n      foo = any.unpack(Foo.getDefaultInstance());\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "AlertService"
        ],
        "summary": "DeleteAlerts is a maintenance function that deletes alerts from the store.",
        "description": "**Deletion Constraints:**\n- Only RESOLVED alerts can be deleted\n- Query MUST explicitly specify \"Violation State:RESOLVED\"\n- Confirmation required for actual deletion (dry-run mode by default)\n- Deletion is permanent and cannot be undone\n\n**Safety Features:**\n- Dry-run mode shows how many alerts would be deleted\n- Explicit confirmation required for actual deletion\n- Query must specifically target RESOLVED alerts\n\n**Error Cases:**\n- 400: Query does not specify RESOLVED state or specifies invalid state\n- 400: No query provided\n- 403: Insufficient permissions to delete alerts\n\n**Example Query:**\n- \"Violation State:RESOLVED+Cluster:production\" - Delete resolved alerts from production cluster",
        "operationId": "AlertService_DeleteAlerts",
        "parameters": [
          {
            "name": "query.query",
            "in": "query",
            "schema": {
              "nullable": true,
              "type": "string"
            }
          },
          {
            "name": "query.pagination.limit",
            "in": "query",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "query.pagination.offset",
            "in": "query",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "query.pagination.sortOption.field",
            "in": "query",
            "schema": {
              "nullable": true,
              "type": "string"
            }
          },
          {
            "name": "query.pagination.sortOption.reversed",
            "in": "query",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "query.pagination.sortOption.aggregateBy.aggrFunc",
            "in": "query",
            "schema": {
              "nullable": true,
              "type": "string",
              "default": "UNSET",
              "enum": [
                "UNSET",
                "COUNT",
                "MIN",
                "MAX"
              ]
            }
          },
          {
            "name": "query.pagination.sortOption.aggregateBy.distinct",
            "in": "query",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "confirm",
            "in": "query",
            "description": "When false (default), performs a dry-run showing how many alerts would be deleted.\nWhen true, actually deletes the matching RESOLVED alerts.\nDeletion is permanent and cannot be undone.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "numDeleted": {
                      "type": "integer",
                      "description": "Number of alerts that were (or would be) deleted.",
                      "format": "int64"
                    },
                    "dryRun": {
                      "type": "boolean",
                      "description": "True if this was a dry-run (no actual deletion occurred).\nFalse if alerts were actually deleted."
                    }
                  },
                  "description": "DeleteAlertsResponse contains the result of a delete operation."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "application/json": {
                "schema": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "nullable": true,
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "@type": {
                            "nullable": true,
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com. As of May 2023, there are no widely used type server\nimplementations and no plans to implement one.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          }
                        },
                        "additionalProperties": {
                          "nullable": true,
                          "type": "object"
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n    // or ...\n    if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n      foo = any.unpack(Foo.getDefaultInstance());\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/v1/alerts/{id}": {
      "get": {
        "tags": [
          "AlertService"
        ],
        "summary": "GetAlert returns the alert given its id.",
        "description": "Returns the full alert details including violations, enforcement actions,\nand entity information (deployment, image, or resource).\n\n**Error Cases:**\n- 404: Alert with specified ID does not exist\n- 403: Insufficient permissions to view the alert",
        "operationId": "AlertService_GetAlert",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "nullable": true,
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "title": "Next available tag: 24",
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "id": {
                      "nullable": true,
                      "type": "string",
                      "description": "Unique identifier for the alert."
                    },
                    "policy": {
                      "title": "Next tag: 28",
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "id": {
                          "title": "Unique identifier generated by the system. Must be empty for new policies.\nFormat: UUID v4, auto-generated during creation",
                          "nullable": true,
                          "type": "string"
                        },
                        "name": {
                          "title": "Name of the policy. Must be unique across all policies.\nValidation: 5-128 characters, no newlines or dollar signs\nPattern: ^[^\\n\\r\\$]{5,128}$",
                          "nullable": true,
                          "type": "string"
                        },
                        "description": {
                          "title": "Free-form text description of this policy.\nValidation: Max 800 characters, no dollar signs\nPattern: ^[^\\$]{0,800}$",
                          "nullable": true,
                          "type": "string"
                        },
                        "rationale": {
                          "nullable": true,
                          "type": "string",
                          "description": "Business justification for why this policy exists.\nUsed for compliance and audit purposes."
                        },
                        "remediation": {
                          "nullable": true,
                          "type": "string",
                          "description": "Describes how to remediate a violation of this policy.\nShould be actionable and specific to the policy type."
                        },
                        "disabled": {
                          "title": "Toggles whether or not this policy will be executing and actively firing alerts.\nDefault: false",
                          "type": "boolean"
                        },
                        "categories": {
                          "title": "List of categories that this policy falls under. Category names must already exist in Central.\nValidation: At least one category required, no duplicates",
                          "type": "array",
                          "items": {
                            "nullable": true,
                            "type": "string"
                          }
                        },
                        "lifecycleStages": {
                          "title": "Describes which policy lifecycle stages this policy applies to. Choices are DEPLOY, BUILD, and RUNTIME.\nValidation: At least one stage required\n- BUILD: Must contain image-related criteria only\n- DEPLOY: Cannot contain runtime criteria\n- RUNTIME: Must contain at least one runtime criterion",
                          "type": "array",
                          "items": {
                            "nullable": true,
                            "type": "string",
                            "default": "DEPLOY",
                            "enum": [
                              "DEPLOY",
                              "BUILD",
                              "RUNTIME"
                            ]
                          }
                        },
                        "eventSource": {
                          "nullable": true,
                          "type": "string",
                          "default": "NOT_APPLICABLE",
                          "enum": [
                            "NOT_APPLICABLE",
                            "DEPLOYMENT_EVENT",
                            "AUDIT_LOG_EVENT"
                          ]
                        },
                        "exclusions": {
                          "title": "Define deployments or images that should be excluded from this policy.\nValidation:\n- Deployment exclusions: Only valid for DEPLOY and RUNTIME lifecycles\n- Image exclusions: Only valid for BUILD lifecycle\n- Must have at least one criteria (name, scope, or image)",
                          "type": "array",
                          "items": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "name": {
                                "nullable": true,
                                "type": "string",
                                "description": "Name of the exclusion. Used for identification and documentation."
                              },
                              "deployment": {
                                "nullable": true,
                                "type": "object",
                                "properties": {
                                  "name": {
                                    "title": "Name of the deployment to exclude. Optional if scope is provided.\nValidation: Must be provided if scope is not specified",
                                    "nullable": true,
                                    "type": "string"
                                  },
                                  "scope": {
                                    "nullable": true,
                                    "type": "object",
                                    "properties": {
                                      "cluster": {
                                        "nullable": true,
                                        "type": "string"
                                      },
                                      "namespace": {
                                        "nullable": true,
                                        "type": "string"
                                      },
                                      "label": {
                                        "nullable": true,
                                        "type": "object",
                                        "properties": {
                                          "key": {
                                            "nullable": true,
                                            "type": "string"
                                          },
                                          "value": {
                                            "nullable": true,
                                            "type": "string"
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              },
                              "image": {
                                "nullable": true,
                                "type": "object",
                                "properties": {
                                  "name": {
                                    "title": "Name of the image to exclude.\nValidation: Must be non-empty",
                                    "nullable": true,
                                    "type": "string"
                                  }
                                }
                              },
                              "expiration": {
                                "nullable": true,
                                "type": "string",
                                "description": "Expiration timestamp for this exclusion.\nWhen expired, the exclusion is automatically removed.",
                                "format": "date-time"
                              }
                            }
                          }
                        },
                        "scope": {
                          "title": "Defines clusters, namespaces, and deployments that should be included in this policy.\nNo scopes defined includes everything.\nValidation: Must have at least one field populated (cluster, namespace, or label)",
                          "type": "array",
                          "items": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "cluster": {
                                "nullable": true,
                                "type": "string"
                              },
                              "namespace": {
                                "nullable": true,
                                "type": "string"
                              },
                              "label": {
                                "nullable": true,
                                "type": "object",
                                "properties": {
                                  "key": {
                                    "nullable": true,
                                    "type": "string"
                                  },
                                  "value": {
                                    "nullable": true,
                                    "type": "string"
                                  }
                                }
                              }
                            }
                          }
                        },
                        "severity": {
                          "nullable": true,
                          "type": "string",
                          "default": "UNSET_SEVERITY",
                          "enum": [
                            "UNSET_SEVERITY",
                            "LOW_SEVERITY",
                            "MEDIUM_SEVERITY",
                            "HIGH_SEVERITY",
                            "CRITICAL_SEVERITY"
                          ]
                        },
                        "enforcementActions": {
                          "title": "Lists the enforcement actions to take when a violation from this policy is identified.\nValidation: Must be compatible with lifecycle stages\n- FAIL_BUILD_ENFORCEMENT: BUILD lifecycle only\n- SCALE_TO_ZERO_ENFORCEMENT: DEPLOY lifecycle only\n- UNSATISFIABLE_NODE_CONSTRAINT_ENFORCEMENT: DEPLOY lifecycle only\n- KILL_POD_ENFORCEMENT: RUNTIME lifecycle only\n- FAIL_KUBE_REQUEST_ENFORCEMENT: RUNTIME lifecycle only\n- FAIL_DEPLOYMENT_CREATE_ENFORCEMENT: DEPLOY lifecycle only\n- FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT: DEPLOY lifecycle only\n- Audit log policies: No enforcement actions allowed",
                          "type": "array",
                          "items": {
                            "nullable": true,
                            "type": "string",
                            "description": " - FAIL_KUBE_REQUEST_ENFORCEMENT: FAIL_KUBE_REQUEST_ENFORCEMENT takes effect only if admission control webhook is enabled to listen on exec and port-forward events.\n - FAIL_DEPLOYMENT_CREATE_ENFORCEMENT: FAIL_DEPLOYMENT_CREATE_ENFORCEMENT takes effect only if admission control webhook is configured to enforce on object creates.\n - FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT: FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT takes effect only if admission control webhook is configured to enforce on object updates.",
                            "default": "UNSET_ENFORCEMENT",
                            "enum": [
                              "UNSET_ENFORCEMENT",
                              "SCALE_TO_ZERO_ENFORCEMENT",
                              "UNSATISFIABLE_NODE_CONSTRAINT_ENFORCEMENT",
                              "KILL_POD_ENFORCEMENT",
                              "FAIL_BUILD_ENFORCEMENT",
                              "FAIL_KUBE_REQUEST_ENFORCEMENT",
                              "FAIL_DEPLOYMENT_CREATE_ENFORCEMENT",
                              "FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT"
                            ]
                          }
                        },
                        "notifiers": {
                          "title": "List of IDs of the notifiers that should be triggered when a violation from this policy is identified.\nIDs should be in the form of a UUID and are found through the Central API.\nValidation: All notifier IDs must reference existing notifiers",
                          "type": "array",
                          "items": {
                            "nullable": true,
                            "type": "string"
                          }
                        },
                        "lastUpdated": {
                          "nullable": true,
                          "type": "string",
                          "description": "Timestamp when the policy was last updated. Auto-generated during creation/update.",
                          "format": "date-time"
                        },
                        "SORTName": {
                          "nullable": true,
                          "type": "string",
                          "description": "For internal use only."
                        },
                        "SORTLifecycleStage": {
                          "nullable": true,
                          "type": "string",
                          "description": "For internal use only."
                        },
                        "SORTEnforcement": {
                          "type": "boolean",
                          "description": "For internal use only."
                        },
                        "policyVersion": {
                          "title": "Policy version. Must be \"1.1\" (current supported version).\nValidation: Only version 1.1 is supported",
                          "nullable": true,
                          "type": "string"
                        },
                        "policySections": {
                          "title": "PolicySections define the violation criteria for this policy.\nValidation Requirements:\n- Each section must have a unique sectionName\n- Each policy group must have a valid fieldName and at least one value\n- Field names must be valid for the specified lifecycle stages\n- Values must match the expected format for each field type\n- Boolean operators must be compatible with field requirements\n- Negation must be allowed for the field type\n- Runtime policies must contain at least one runtime criterion\n- Runtime criteria must be in separate sections\n- Audit log policies require both KubeResource and KubeAPIVerb criteria",
                          "type": "array",
                          "items": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "sectionName": {
                                "nullable": true,
                                "type": "string",
                                "description": "Name of the policy section. Must be unique within the policy.\nUsed for organizing policy criteria into logical groups."
                              },
                              "policyGroups": {
                                "title": "The set of policy groups that make up this section. Each group can be considered an individual criterion.\nValidation Requirements:\n- Each group must have a valid fieldName and at least one value\n- Field names must be valid for the specified lifecycle stages\n- Values must match the expected format for each field type\n- Boolean operators must be compatible with field requirements\n- Negation must be allowed for the field type\n- Runtime criteria must be in separate sections\n- Audit log policies require both KubeResource and KubeAPIVerb criteria",
                                "type": "array",
                                "items": {
                                  "nullable": true,
                                  "type": "object",
                                  "properties": {
                                    "fieldName": {
                                      "title": "Defines which field on a deployment or image this PolicyGroup evaluates.\nSee https://docs.openshift.com/acs/operating/manage-security-policies.html#policy-criteria_manage-security-policies for a complete list of possible values.\nValidation Requirements:\n- Must be a valid field name for the specified lifecycle stages\n- Field must support the specified boolean operator\n- Field must allow negation if negate=true\n- Field must support multiple values if more than one value is provided\n- Some fields have special restrictions (e.g., ImageSignatureVerifiedBy cannot use AND operator)",
                                      "nullable": true,
                                      "type": "string"
                                    },
                                    "booleanOperator": {
                                      "nullable": true,
                                      "type": "string",
                                      "default": "OR",
                                      "enum": [
                                        "OR",
                                        "AND"
                                      ]
                                    },
                                    "negate": {
                                      "title": "Determines if the evaluation of this PolicyGroup is negated. Default to false.\nValidation: Must be allowed for the field type\n- Some fields cannot be negated (negationForbidden=true)",
                                      "type": "boolean"
                                    },
                                    "values": {
                                      "title": "List of values for the specified field.\nValidation Requirements:\n- Must have at least one value\n- Values must match the expected regex pattern for the field type\n- Some fields only support single values\n- Values must be valid for the field's data type and constraints\n- Environment variable values have special format requirements\n- Dockerfile line values have special restrictions (e.g., no FROM with strict validation)",
                                      "type": "array",
                                      "items": {
                                        "nullable": true,
                                        "type": "object",
                                        "properties": {
                                          "value": {
                                            "title": "The actual value for the policy criterion.\nValidation: Must match the expected format for the field type\nExamples:\n- CVE: \"CVE-2021-1234\"\n- Image Tag: \"latest\"\n- Environment Variable: \"UNSET=key=value\" or \"SECRET_KEY=key=\"\n- Dockerfile Line: \"ADD=.\" or \"RUN=apt-get update\"\n- Process Name: \"nginx\"\n- Network Flow: \"tcp:80\"",
                                            "nullable": true,
                                            "type": "string"
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        },
                        "mitreAttackVectors": {
                          "type": "array",
                          "description": "MITRE ATT&CK framework mappings for this policy.\nUsed for threat intelligence and compliance reporting.",
                          "items": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "tactic": {
                                "nullable": true,
                                "type": "string"
                              },
                              "techniques": {
                                "type": "array",
                                "items": {
                                  "nullable": true,
                                  "type": "string"
                                }
                              }
                            }
                          }
                        },
                        "criteriaLocked": {
                          "type": "boolean",
                          "description": "Read-only field. If true, the policy's criteria fields are rendered read-only."
                        },
                        "mitreVectorsLocked": {
                          "type": "boolean",
                          "description": "Read-only field. If true, the policy's MITRE ATT&CK fields are rendered read-only."
                        },
                        "isDefault": {
                          "type": "boolean",
                          "description": "Read-only field. Indicates the policy is a default policy if true and a custom policy if false."
                        },
                        "source": {
                          "nullable": true,
                          "type": "string",
                          "default": "IMPERATIVE",
                          "enum": [
                            "IMPERATIVE",
                            "DECLARATIVE"
                          ]
                        }
                      }
                    },
                    "lifecycleStage": {
                      "nullable": true,
                      "type": "string",
                      "default": "DEPLOY",
                      "enum": [
                        "DEPLOY",
                        "BUILD",
                        "RUNTIME"
                      ]
                    },
                    "clusterId": {
                      "nullable": true,
                      "type": "string",
                      "description": "Unique identifier for the cluster containing the alert."
                    },
                    "clusterName": {
                      "nullable": true,
                      "type": "string",
                      "description": "Human-readable name of the cluster containing the alert."
                    },
                    "namespace": {
                      "nullable": true,
                      "type": "string",
                      "description": "Kubernetes namespace containing the alert."
                    },
                    "namespaceId": {
                      "nullable": true,
                      "type": "string",
                      "description": "Unique identifier for the namespace containing the alert."
                    },
                    "deployment": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "id": {
                          "nullable": true,
                          "type": "string",
                          "description": "Unique identifier for the deployment."
                        },
                        "name": {
                          "nullable": true,
                          "type": "string",
                          "description": "Human-readable name of the deployment."
                        },
                        "type": {
                          "nullable": true,
                          "type": "string",
                          "description": "Type of deployment (e.g., \"Deployment\", \"DaemonSet\", \"StatefulSet\")."
                        },
                        "namespace": {
                          "nullable": true,
                          "type": "string",
                          "description": "Kubernetes namespace containing the deployment.\nThis field has to be duplicated in Alert for scope management and search.\n\nThis field has to be duplicated in Alert for scope management and search."
                        },
                        "labels": {
                          "nullable": true,
                          "type": "object",
                          "additionalProperties": {
                            "nullable": true,
                            "type": "string"
                          },
                          "description": "Kubernetes labels applied to the deployment."
                        },
                        "clusterId": {
                          "nullable": true,
                          "type": "string",
                          "description": "Unique identifier for the cluster containing the deployment.\nThis field has to be duplicated in Alert for scope management and search.\n\nThis field has to be duplicated in Alert for scope management and search."
                        },
                        "clusterName": {
                          "nullable": true,
                          "type": "string",
                          "description": "Human-readable name of the cluster containing the deployment.\nThis field has to be duplicated in Alert for scope management and search.\n\nThis field has to be duplicated in Alert for scope management and search."
                        },
                        "containers": {
                          "type": "array",
                          "description": "List of containers in the deployment.",
                          "items": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "image": {
                                "title": "Next tag: 13",
                                "nullable": true,
                                "type": "object",
                                "properties": {
                                  "id": {
                                    "nullable": true,
                                    "type": "string"
                                  },
                                  "name": {
                                    "nullable": true,
                                    "type": "object",
                                    "properties": {
                                      "registry": {
                                        "nullable": true,
                                        "type": "string"
                                      },
                                      "remote": {
                                        "nullable": true,
                                        "type": "string"
                                      },
                                      "tag": {
                                        "nullable": true,
                                        "type": "string"
                                      },
                                      "fullName": {
                                        "nullable": true,
                                        "type": "string"
                                      }
                                    }
                                  },
                                  "notPullable": {
                                    "type": "boolean"
                                  },
                                  "isClusterLocal": {
                                    "type": "boolean"
                                  },
                                  "idV2": {
                                    "nullable": true,
                                    "type": "string"
                                  }
                                }
                              },
                              "name": {
                                "nullable": true,
                                "type": "string",
                                "description": "Name of the container within the deployment."
                              }
                            }
                          }
                        },
                        "annotations": {
                          "nullable": true,
                          "type": "object",
                          "additionalProperties": {
                            "nullable": true,
                            "type": "string"
                          },
                          "description": "Kubernetes annotations applied to the deployment."
                        },
                        "inactive": {
                          "type": "boolean",
                          "description": "Whether the deployment is currently inactive."
                        }
                      }
                    },
                    "image": {
                      "title": "Next tag: 13",
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "id": {
                          "nullable": true,
                          "type": "string"
                        },
                        "name": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "registry": {
                              "nullable": true,
                              "type": "string"
                            },
                            "remote": {
                              "nullable": true,
                              "type": "string"
                            },
                            "tag": {
                              "nullable": true,
                              "type": "string"
                            },
                            "fullName": {
                              "nullable": true,
                              "type": "string"
                            }
                          }
                        },
                        "notPullable": {
                          "type": "boolean"
                        },
                        "isClusterLocal": {
                          "type": "boolean"
                        },
                        "idV2": {
                          "nullable": true,
                          "type": "string"
                        }
                      }
                    },
                    "resource": {
                      "title": "Represents an alert on a kubernetes resource other than a deployment (configmaps, secrets, etc.)",
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "resourceType": {
                          "nullable": true,
                          "type": "string",
                          "default": "UNKNOWN",
                          "enum": [
                            "UNKNOWN",
                            "SECRETS",
                            "CONFIGMAPS",
                            "CLUSTER_ROLES",
                            "CLUSTER_ROLE_BINDINGS",
                            "NETWORK_POLICIES",
                            "SECURITY_CONTEXT_CONSTRAINTS",
                            "EGRESS_FIREWALLS"
                          ]
                        },
                        "name": {
                          "nullable": true,
                          "type": "string",
                          "description": "Name of the resource that triggered the alert."
                        },
                        "clusterId": {
                          "nullable": true,
                          "type": "string",
                          "description": "Unique identifier for the cluster containing the resource.\nThis field has to be duplicated in Alert for scope management and search.\n\nThis field has to be duplicated in Alert for scope management and search."
                        },
                        "clusterName": {
                          "nullable": true,
                          "type": "string",
                          "description": "Human-readable name of the cluster containing the resource.\nThis field has to be duplicated in Alert for scope management and search.\n\nThis field has to be duplicated in Alert for scope management and search."
                        },
                        "namespace": {
                          "nullable": true,
                          "type": "string",
                          "description": "Kubernetes namespace containing the resource.\nThis field has to be duplicated in Alert for scope management and search.\n\nThis field has to be duplicated in Alert for scope management and search."
                        },
                        "namespaceId": {
                          "nullable": true,
                          "type": "string",
                          "description": "Unique identifier for the namespace containing the resource.\nThis field has to be duplicated in Alert for scope management and search.\n\nThis field has to be duplicated in Alert for scope management and search."
                        }
                      }
                    },
                    "violations": {
                      "type": "array",
                      "description": "For run-time phase alert, a maximum of 40 violations are retained.",
                      "items": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "message": {
                            "nullable": true,
                            "type": "string",
                            "description": "Human-readable message describing the violation."
                          },
                          "keyValueAttrs": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "attrs": {
                                "type": "array",
                                "items": {
                                  "nullable": true,
                                  "type": "object",
                                  "properties": {
                                    "key": {
                                      "nullable": true,
                                      "type": "string"
                                    },
                                    "value": {
                                      "nullable": true,
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            }
                          },
                          "networkFlowInfo": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "protocol": {
                                "nullable": true,
                                "type": "string",
                                "default": "L4_PROTOCOL_UNKNOWN",
                                "enum": [
                                  "L4_PROTOCOL_UNKNOWN",
                                  "L4_PROTOCOL_TCP",
                                  "L4_PROTOCOL_UDP",
                                  "L4_PROTOCOL_ICMP",
                                  "L4_PROTOCOL_RAW",
                                  "L4_PROTOCOL_SCTP",
                                  "L4_PROTOCOL_ANY"
                                ]
                              },
                              "source": {
                                "nullable": true,
                                "type": "object",
                                "properties": {
                                  "name": {
                                    "nullable": true,
                                    "type": "string"
                                  },
                                  "entityType": {
                                    "title": "- INTERNAL_ENTITIES: INTERNAL_ENTITIES is for grouping all internal entities under a single network graph node",
                                    "nullable": true,
                                    "type": "string",
                                    "default": "UNKNOWN_TYPE",
                                    "enum": [
                                      "UNKNOWN_TYPE",
                                      "DEPLOYMENT",
                                      "INTERNET",
                                      "LISTEN_ENDPOINT",
                                      "EXTERNAL_SOURCE",
                                      "INTERNAL_ENTITIES"
                                    ]
                                  },
                                  "deploymentNamespace": {
                                    "nullable": true,
                                    "type": "string"
                                  },
                                  "deploymentType": {
                                    "nullable": true,
                                    "type": "string"
                                  },
                                  "port": {
                                    "type": "integer",
                                    "format": "int32"
                                  }
                                }
                              },
                              "destination": {
                                "nullable": true,
                                "type": "object",
                                "properties": {
                                  "name": {
                                    "nullable": true,
                                    "type": "string"
                                  },
                                  "entityType": {
                                    "title": "- INTERNAL_ENTITIES: INTERNAL_ENTITIES is for grouping all internal entities under a single network graph node",
                                    "nullable": true,
                                    "type": "string",
                                    "default": "UNKNOWN_TYPE",
                                    "enum": [
                                      "UNKNOWN_TYPE",
                                      "DEPLOYMENT",
                                      "INTERNET",
                                      "LISTEN_ENDPOINT",
                                      "EXTERNAL_SOURCE",
                                      "INTERNAL_ENTITIES"
                                    ]
                                  },
                                  "deploymentNamespace": {
                                    "nullable": true,
                                    "type": "string"
                                  },
                                  "deploymentType": {
                                    "nullable": true,
                                    "type": "string"
                                  },
                                  "port": {
                                    "type": "integer",
                                    "format": "int32"
                                  }
                                }
                              }
                            }
                          },
                          "type": {
                            "title": "- GENERIC: Generic policy violation\n - K8S_EVENT: Kubernetes event violation\n - NETWORK_FLOW: Network flow violation\n - NETWORK_POLICY: Network policy violation",
                            "nullable": true,
                            "type": "string",
                            "default": "GENERIC",
                            "enum": [
                              "GENERIC",
                              "K8S_EVENT",
                              "NETWORK_FLOW",
                              "NETWORK_POLICY"
                            ]
                          },
                          "time": {
                            "nullable": true,
                            "type": "string",
                            "description": "Indicates violation time. This field differs from top-level field 'time' which represents last time the alert\noccurred in case of multiple occurrences of the policy alert. As of 55.0, this field is set only for kubernetes\nevent violations, but may not be limited to it in future.",
                            "format": "date-time"
                          }
                        }
                      }
                    },
                    "processViolation": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "message": {
                          "nullable": true,
                          "type": "string",
                          "description": "Human-readable message describing the process violation."
                        },
                        "processes": {
                          "type": "array",
                          "description": "List of processes that violated the policy.\nLimited to maximum 40 processes per runtime alert.",
                          "items": {
                            "title": "Next available tag: 13",
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "id": {
                                "title": "A unique UUID for the Indicator message",
                                "nullable": true,
                                "type": "string"
                              },
                              "deploymentId": {
                                "nullable": true,
                                "type": "string"
                              },
                              "containerName": {
                                "nullable": true,
                                "type": "string"
                              },
                              "podId": {
                                "title": "Pod name",
                                "nullable": true,
                                "type": "string"
                              },
                              "podUid": {
                                "nullable": true,
                                "type": "string"
                              },
                              "signal": {
                                "nullable": true,
                                "type": "object",
                                "properties": {
                                  "id": {
                                    "nullable": true,
                                    "type": "string",
                                    "description": "A unique UUID for identifying the message\nWe have this here instead of at the top level\nbecause we want to have each message to be\nself contained."
                                  },
                                  "containerId": {
                                    "title": "ID of container associated with this process",
                                    "nullable": true,
                                    "type": "string"
                                  },
                                  "time": {
                                    "title": "Process creation time",
                                    "nullable": true,
                                    "type": "string",
                                    "format": "date-time"
                                  },
                                  "name": {
                                    "title": "Process name",
                                    "nullable": true,
                                    "type": "string"
                                  },
                                  "args": {
                                    "title": "Process arguments",
                                    "nullable": true,
                                    "type": "string"
                                  },
                                  "execFilePath": {
                                    "title": "Process executable file path",
                                    "nullable": true,
                                    "type": "string"
                                  },
                                  "pid": {
                                    "title": "Host process ID",
                                    "type": "integer",
                                    "format": "int64"
                                  },
                                  "uid": {
                                    "title": "Real user ID",
                                    "type": "integer",
                                    "format": "int64"
                                  },
                                  "gid": {
                                    "title": "Real group ID",
                                    "type": "integer",
                                    "format": "int64"
                                  },
                                  "lineage": {
                                    "title": "Process Lineage",
                                    "type": "array",
                                    "items": {
                                      "nullable": true,
                                      "type": "string"
                                    }
                                  },
                                  "scraped": {
                                    "title": "Signal origin",
                                    "type": "boolean"
                                  },
                                  "lineageInfo": {
                                    "title": "Process LineageInfo",
                                    "type": "array",
                                    "items": {
                                      "nullable": true,
                                      "type": "object",
                                      "properties": {
                                        "parentUid": {
                                          "type": "integer",
                                          "format": "int64"
                                        },
                                        "parentExecFilePath": {
                                          "nullable": true,
                                          "type": "string"
                                        }
                                      }
                                    }
                                  }
                                }
                              },
                              "clusterId": {
                                "nullable": true,
                                "type": "string"
                              },
                              "namespace": {
                                "nullable": true,
                                "type": "string"
                              },
                              "containerStartTime": {
                                "nullable": true,
                                "type": "string",
                                "format": "date-time"
                              },
                              "imageId": {
                                "nullable": true,
                                "type": "string"
                              }
                            }
                          }
                        }
                      }
                    },
                    "enforcement": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "action": {
                          "nullable": true,
                          "type": "string",
                          "description": " - FAIL_KUBE_REQUEST_ENFORCEMENT: FAIL_KUBE_REQUEST_ENFORCEMENT takes effect only if admission control webhook is enabled to listen on exec and port-forward events.\n - FAIL_DEPLOYMENT_CREATE_ENFORCEMENT: FAIL_DEPLOYMENT_CREATE_ENFORCEMENT takes effect only if admission control webhook is configured to enforce on object creates.\n - FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT: FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT takes effect only if admission control webhook is configured to enforce on object updates.",
                          "default": "UNSET_ENFORCEMENT",
                          "enum": [
                            "UNSET_ENFORCEMENT",
                            "SCALE_TO_ZERO_ENFORCEMENT",
                            "UNSATISFIABLE_NODE_CONSTRAINT_ENFORCEMENT",
                            "KILL_POD_ENFORCEMENT",
                            "FAIL_BUILD_ENFORCEMENT",
                            "FAIL_KUBE_REQUEST_ENFORCEMENT",
                            "FAIL_DEPLOYMENT_CREATE_ENFORCEMENT",
                            "FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT"
                          ]
                        },
                        "message": {
                          "nullable": true,
                          "type": "string",
                          "description": "Human-readable message describing the enforcement result."
                        }
                      }
                    },
                    "time": {
                      "nullable": true,
                      "type": "string",
                      "description": "Timestamp of the last occurrence of this alert.\nFor alerts with multiple violations, this represents the most recent occurrence.",
                      "format": "date-time"
                    },
                    "firstOccurred": {
                      "nullable": true,
                      "type": "string",
                      "description": "Timestamp of the first occurrence of this alert.",
                      "format": "date-time"
                    },
                    "resolvedAt": {
                      "nullable": true,
                      "type": "string",
                      "description": "The time at which the alert was resolved. Only set if ViolationState is RESOLVED.",
                      "format": "date-time"
                    },
                    "state": {
                      "nullable": true,
                      "type": "string",
                      "description": " - ACTIVE: Alert is currently active and requires attention.\nThis is the default state for new alerts.\nActive alerts can be resolved but cannot be deleted.\n - RESOLVED: Alert has been resolved (manually or automatically).\nResolved alerts can be deleted for maintenance purposes.\nOnly RESOLVED alerts can be deleted via DeleteAlerts API.\n - ATTEMPTED: Enforcement action was attempted but failed.\nThese alerts can be resolved to acknowledge the failed enforcement.\nCommon for alerts where enforcement actions are not fully configured.",
                      "default": "ACTIVE",
                      "enum": [
                        "ACTIVE",
                        "RESOLVED",
                        "ATTEMPTED"
                      ]
                    },
                    "platformComponent": {
                      "type": "boolean",
                      "description": "Whether this alert is related to a platform component."
                    },
                    "entityType": {
                      "title": "- DEPLOYMENT: Alert on a deployment\n - CONTAINER_IMAGE: Alert on a container image\n - RESOURCE: Alert on a Kubernetes resource",
                      "nullable": true,
                      "type": "string",
                      "default": "UNSET",
                      "enum": [
                        "UNSET",
                        "DEPLOYMENT",
                        "CONTAINER_IMAGE",
                        "RESOURCE"
                      ]
                    }
                  }
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "application/json": {
                "schema": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "nullable": true,
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "@type": {
                            "nullable": true,
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com. As of May 2023, there are no widely used type server\nimplementations and no plans to implement one.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          }
                        },
                        "additionalProperties": {
                          "nullable": true,
                          "type": "object"
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n    // or ...\n    if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n      foo = any.unpack(Foo.getDefaultInstance());\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/v1/clusters": {
      "get": {
        "tags": [
          "ClustersService"
        ],
        "operationId": "ClustersService_GetClusters",
        "parameters": [
          {
            "name": "query",
            "in": "query",
            "schema": {
              "nullable": true,
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "clusters": {
                      "type": "array",
                      "items": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "id": {
                            "nullable": true,
                            "type": "string"
                          },
                          "name": {
                            "nullable": true,
                            "type": "string"
                          },
                          "type": {
                            "nullable": true,
                            "type": "string",
                            "default": "GENERIC_CLUSTER",
                            "enum": [
                              "GENERIC_CLUSTER",
                              "KUBERNETES_CLUSTER",
                              "OPENSHIFT_CLUSTER",
                              "OPENSHIFT4_CLUSTER"
                            ]
                          },
                          "labels": {
                            "nullable": true,
                            "type": "object",
                            "additionalProperties": {
                              "nullable": true,
                              "type": "string"
                            }
                          },
                          "mainImage": {
                            "nullable": true,
                            "type": "string"
                          },
                          "collectorImage": {
                            "nullable": true,
                            "type": "string"
                          },
                          "centralApiEndpoint": {
                            "nullable": true,
                            "type": "string"
                          },
                          "runtimeSupport": {
                            "type": "boolean"
                          },
                          "collectionMethod": {
                            "nullable": true,
                            "type": "string",
                            "default": "UNSET_COLLECTION",
                            "enum": [
                              "UNSET_COLLECTION",
                              "NO_COLLECTION",
                              "KERNEL_MODULE",
                              "EBPF",
                              "CORE_BPF"
                            ]
                          },
                          "admissionController": {
                            "type": "boolean"
                          },
                          "admissionControllerUpdates": {
                            "type": "boolean"
                          },
                          "admissionControllerEvents": {
                            "type": "boolean"
                          },
                          "status": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "sensorVersion": {
                                "nullable": true,
                                "type": "string"
                              },
                              "DEPRECATEDLastContact": {
                                "nullable": true,
                                "type": "string",
                                "description": "This field has been deprecated starting release 49.0. Use healthStatus.lastContact instead.",
                                "format": "date-time"
                              },
                              "providerMetadata": {
                                "nullable": true,
                                "type": "object",
                                "properties": {
                                  "region": {
                                    "nullable": true,
                                    "type": "string"
                                  },
                                  "zone": {
                                    "nullable": true,
                                    "type": "string"
                                  },
                                  "google": {
                                    "nullable": true,
                                    "type": "object",
                                    "properties": {
                                      "project": {
                                        "nullable": true,
                                        "type": "string"
                                      },
                                      "clusterName": {
                                        "nullable": true,
                                        "type": "string",
                                        "description": "Deprecated in favor of providerMetadata.cluster.name."
                                      }
                                    }
                                  },
                                  "aws": {
                                    "nullable": true,
                                    "type": "object",
                                    "properties": {
                                      "accountId": {
                                        "nullable": true,
                                        "type": "string"
                                      }
                                    }
                                  },
                                  "azure": {
                                    "nullable": true,
                                    "type": "object",
                                    "properties": {
                                      "subscriptionId": {
                                        "nullable": true,
                                        "type": "string"
                                      }
                                    }
                                  },
                                  "verified": {
                                    "type": "boolean"
                                  },
                                  "cluster": {
                                    "nullable": true,
                                    "type": "object",
                                    "properties": {
                                      "type": {
                                        "nullable": true,
                                        "type": "string",
                                        "default": "UNSPECIFIED",
                                        "enum": [
                                          "UNSPECIFIED",
                                          "AKS",
                                          "ARO",
                                          "EKS",
                                          "GKE",
                                          "OCP",
                                          "OSD",
                                          "ROSA"
                                        ]
                                      },
                                      "name": {
                                        "nullable": true,
                                        "type": "string",
                                        "description": "Name represents the name under which the cluster is registered with the\ncloud provider. In case of self managed OpenShift it is the name chosen\nby the OpenShift installer."
                                      },
                                      "id": {
                                        "nullable": true,
                                        "type": "string",
                                        "description": "Id represents a unique ID under which the cluster is registered with the\ncloud provider. Not all cluster types have an id. For all OpenShift\nclusters, this is the Red Hat `cluster_id` registered with OCM."
                                      }
                                    },
                                    "description": "ClusterMetadata contains metadata information about the cluster infrastructure."
                                  }
                                }
                              },
                              "orchestratorMetadata": {
                                "nullable": true,
                                "type": "object",
                                "properties": {
                                  "version": {
                                    "nullable": true,
                                    "type": "string"
                                  },
                                  "openshiftVersion": {
                                    "nullable": true,
                                    "type": "string"
                                  },
                                  "buildDate": {
                                    "nullable": true,
                                    "type": "string",
                                    "format": "date-time"
                                  },
                                  "apiVersions": {
                                    "type": "array",
                                    "items": {
                                      "nullable": true,
                                      "type": "string"
                                    }
                                  }
                                }
                              },
                              "upgradeStatus": {
                                "nullable": true,
                                "type": "object",
                                "properties": {
                                  "upgradability": {
                                    "nullable": true,
                                    "type": "string",
                                    "description": " - SENSOR_VERSION_HIGHER: SENSOR_VERSION_HIGHER occurs when we detect that the sensor\nis running a newer version than this Central. This is unexpected,\nbut can occur depending on the patches a customer does.\nIn this case, we will NOT automatically \"upgrade\" the sensor,\nsince that would be a downgrade, even if the autoupgrade setting is\non. The user will be allowed to manually trigger the upgrade, but they are\nstrongly discouraged from doing so without upgrading Central first, since this\nis an unsupported configuration.",
                                    "default": "UNSET",
                                    "enum": [
                                      "UNSET",
                                      "UP_TO_DATE",
                                      "MANUAL_UPGRADE_REQUIRED",
                                      "AUTO_UPGRADE_POSSIBLE",
                                      "SENSOR_VERSION_HIGHER"
                                    ]
                                  },
                                  "upgradabilityStatusReason": {
                                    "nullable": true,
                                    "type": "string"
                                  },
                                  "mostRecentProcess": {
                                    "nullable": true,
                                    "type": "object",
                                    "properties": {
                                      "active": {
                                        "type": "boolean"
                                      },
                                      "id": {
                                        "nullable": true,
                                        "type": "string"
                                      },
                                      "targetVersion": {
                                        "title": "only relevant if type == Upgrade",
                                        "nullable": true,
                                        "type": "string"
                                      },
                                      "upgraderImage": {
                                        "nullable": true,
                                        "type": "string"
                                      },
                                      "initiatedAt": {
                                        "nullable": true,
                                        "type": "string",
                                        "format": "date-time"
                                      },
                                      "progress": {
                                        "nullable": true,
                                        "type": "object",
                                        "properties": {
                                          "upgradeState": {
                                            "nullable": true,
                                            "type": "string",
                                            "description": " - UPGRADER_LAUNCHING: In-progress states.\n - UPGRADE_COMPLETE: The success state.\nPLEASE NUMBER ALL IN-PROGRESS STATES ABOVE THIS\nAND ALL ERROR STATES BELOW THIS.\n - UPGRADE_INITIALIZATION_ERROR: Error states.",
                                            "default": "UPGRADE_INITIALIZING",
                                            "enum": [
                                              "UPGRADE_INITIALIZING",
                                              "UPGRADER_LAUNCHING",
                                              "UPGRADER_LAUNCHED",
                                              "PRE_FLIGHT_CHECKS_COMPLETE",
                                              "UPGRADE_OPERATIONS_DONE",
                                              "UPGRADE_COMPLETE",
                                              "UPGRADE_INITIALIZATION_ERROR",
                                              "PRE_FLIGHT_CHECKS_FAILED",
                                              "UPGRADE_ERROR_ROLLING_BACK",
                                              "UPGRADE_ERROR_ROLLED_BACK",
                                              "UPGRADE_ERROR_ROLLBACK_FAILED",
                                              "UPGRADE_ERROR_UNKNOWN",
                                              "UPGRADE_TIMED_OUT"
                                            ]
                                          },
                                          "upgradeStatusDetail": {
                                            "nullable": true,
                                            "type": "string"
                                          },
                                          "since": {
                                            "nullable": true,
                                            "type": "string",
                                            "format": "date-time"
                                          }
                                        }
                                      },
                                      "type": {
                                        "nullable": true,
                                        "type": "string",
                                        "description": " - UPGRADE: UPGRADE represents a sensor version upgrade.\n - CERT_ROTATION: CERT_ROTATION represents an upgrade process that only rotates the TLS certs\nused by the cluster, without changing anything else.",
                                        "default": "UPGRADE",
                                        "enum": [
                                          "UPGRADE",
                                          "CERT_ROTATION"
                                        ]
                                      }
                                    }
                                  }
                                }
                              },
                              "certExpiryStatus": {
                                "nullable": true,
                                "type": "object",
                                "properties": {
                                  "sensorCertExpiry": {
                                    "nullable": true,
                                    "type": "string",
                                    "format": "date-time"
                                  },
                                  "sensorCertNotBefore": {
                                    "nullable": true,
                                    "type": "string",
                                    "format": "date-time"
                                  }
                                }
                              }
                            }
                          },
                          "dynamicConfig": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "admissionControllerConfig": {
                                "nullable": true,
                                "type": "object",
                                "properties": {
                                  "enabled": {
                                    "type": "boolean"
                                  },
                                  "timeoutSeconds": {
                                    "type": "integer",
                                    "format": "int32"
                                  },
                                  "scanInline": {
                                    "type": "boolean"
                                  },
                                  "disableBypass": {
                                    "type": "boolean"
                                  },
                                  "enforceOnUpdates": {
                                    "type": "boolean"
                                  }
                                }
                              },
                              "registryOverride": {
                                "nullable": true,
                                "type": "string"
                              },
                              "disableAuditLogs": {
                                "type": "boolean"
                              }
                            },
                            "description": "The difference between Static and Dynamic cluster config is that Dynamic values are sent over the Central to Sensor gRPC connection. This has the benefit of allowing for \"hot reloading\" of values without restarting Secured cluster components."
                          },
                          "tolerationsConfig": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "disabled": {
                                "type": "boolean"
                              }
                            }
                          },
                          "priority": {
                            "nullable": true,
                            "type": "string",
                            "format": "int64"
                          },
                          "healthStatus": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "id": {
                                "nullable": true,
                                "type": "string"
                              },
                              "collectorHealthInfo": {
                                "nullable": true,
                                "type": "object",
                                "properties": {
                                  "version": {
                                    "title": "This is the version of the collector deamonset as returned by k8s API",
                                    "nullable": true,
                                    "type": "string"
                                  },
                                  "totalDesiredPods": {
                                    "type": "integer",
                                    "format": "int32"
                                  },
                                  "totalReadyPods": {
                                    "type": "integer",
                                    "format": "int32"
                                  },
                                  "totalRegisteredNodes": {
                                    "type": "integer",
                                    "format": "int32"
                                  },
                                  "statusErrors": {
                                    "type": "array",
                                    "description": "Collection of errors that occurred while trying to obtain collector health info.",
                                    "items": {
                                      "nullable": true,
                                      "type": "string"
                                    }
                                  }
                                },
                                "description": "CollectorHealthInfo carries data about collector deployment but does not include collector health status derived from this data.\nAggregated collector health status is not included because it is derived in central and not in the component that\nfirst reports CollectorHealthInfo (sensor)."
                              },
                              "admissionControlHealthInfo": {
                                "nullable": true,
                                "type": "object",
                                "properties": {
                                  "totalDesiredPods": {
                                    "type": "integer",
                                    "format": "int32"
                                  },
                                  "totalReadyPods": {
                                    "type": "integer",
                                    "format": "int32"
                                  },
                                  "statusErrors": {
                                    "type": "array",
                                    "description": "Collection of errors that occurred while trying to obtain admission control health info.",
                                    "items": {
                                      "nullable": true,
                                      "type": "string"
                                    }
                                  }
                                },
                                "description": "AdmissionControlHealthInfo carries data about admission control deployment but does not include admission control health status\nderived from this data.\nAggregated admission control health status is not included because it is derived in central and not in the component that\nfirst reports AdmissionControlHealthInfo (sensor).\n\nThe following fields are made optional/nullable because there can be errors when trying to obtain them and\n the default value of 0 might be confusing with the actual value 0. In case an error happens when trying to obtain\n a certain field, it will be absent (instead of having the default value)."
                              },
                              "scannerHealthInfo": {
                                "nullable": true,
                                "type": "object",
                                "properties": {
                                  "totalDesiredAnalyzerPods": {
                                    "type": "integer",
                                    "format": "int32"
                                  },
                                  "totalReadyAnalyzerPods": {
                                    "type": "integer",
                                    "format": "int32"
                                  },
                                  "totalDesiredDbPods": {
                                    "type": "integer",
                                    "format": "int32"
                                  },
                                  "totalReadyDbPods": {
                                    "type": "integer",
                                    "format": "int32"
                                  },
                                  "statusErrors": {
                                    "type": "array",
                                    "description": "Collection of errors that occurred while trying to obtain scanner health info.",
                                    "items": {
                                      "nullable": true,
                                      "type": "string"
                                    }
                                  }
                                },
                                "description": "ScannerHealthInfo represents health info of a scanner instance that is deployed on a secured cluster (so called \"local scanner\").\nWhen the scanner is deployed on a central cluster, the following message is NOT used.\nScannerHealthInfo carries data about scanner deployment but does not include scanner health status\nderived from this data.\nAggregated scanner health status is not included because it is derived in central and not in the component that\nfirst reports ScannerHealthInfo (sensor).\n\nThe following fields are made optional/nullable because there can be errors when trying to obtain them and\n the default value of 0 might be confusing with the actual value 0. In case an error happens when trying to obtain\n a certain field, it will be absent (instead of having the default value)."
                              },
                              "sensorHealthStatus": {
                                "title": "- UNAVAILABLE: Only collector can have unavailable status",
                                "nullable": true,
                                "type": "string",
                                "default": "UNINITIALIZED",
                                "enum": [
                                  "UNINITIALIZED",
                                  "UNAVAILABLE",
                                  "UNHEALTHY",
                                  "DEGRADED",
                                  "HEALTHY"
                                ]
                              },
                              "collectorHealthStatus": {
                                "title": "- UNAVAILABLE: Only collector can have unavailable status",
                                "nullable": true,
                                "type": "string",
                                "default": "UNINITIALIZED",
                                "enum": [
                                  "UNINITIALIZED",
                                  "UNAVAILABLE",
                                  "UNHEALTHY",
                                  "DEGRADED",
                                  "HEALTHY"
                                ]
                              },
                              "overallHealthStatus": {
                                "title": "- UNAVAILABLE: Only collector can have unavailable status",
                                "nullable": true,
                                "type": "string",
                                "default": "UNINITIALIZED",
                                "enum": [
                                  "UNINITIALIZED",
                                  "UNAVAILABLE",
                                  "UNHEALTHY",
                                  "DEGRADED",
                                  "HEALTHY"
                                ]
                              },
                              "admissionControlHealthStatus": {
                                "title": "- UNAVAILABLE: Only collector can have unavailable status",
                                "nullable": true,
                                "type": "string",
                                "default": "UNINITIALIZED",
                                "enum": [
                                  "UNINITIALIZED",
                                  "UNAVAILABLE",
                                  "UNHEALTHY",
                                  "DEGRADED",
                                  "HEALTHY"
                                ]
                              },
                              "scannerHealthStatus": {
                                "title": "- UNAVAILABLE: Only collector can have unavailable status",
                                "nullable": true,
                                "type": "string",
                                "default": "UNINITIALIZED",
                                "enum": [
                                  "UNINITIALIZED",
                                  "UNAVAILABLE",
                                  "UNHEALTHY",
                                  "DEGRADED",
                                  "HEALTHY"
                                ]
                              },
                              "lastContact": {
                                "nullable": true,
                                "type": "string",
                                "description": "For sensors not having health capability, this will be filled with gRPC connection poll. Otherwise,\nthis timestamp will be updated by central pipeline when message is processed.\n\nNote: we use this setting to guard against a specific attack vector during CRS-based cluster registration.\nAssuming that a CRS was used to register a cluster A and the CRS is leaked, an attacker shall not be able\nto re-run the CRS-flow which would then equip the attacker with a certificate & key issued to the cluster A.\nAs countermeasure we only allow re-running the CRS-flow only as long as the last_contact field is empty,\nindicating that the legit cluster A's sensor has not yet connected with the CRS-issued service certificates.",
                                "format": "date-time"
                              },
                              "healthInfoComplete": {
                                "title": "To track cases such as when sensor is healthy, but collector status data is unavailable because the sensor is on an old version",
                                "type": "boolean"
                              }
                            }
                          },
                          "slimCollector": {
                            "type": "boolean"
                          },
                          "helmConfig": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "dynamicConfig": {
                                "nullable": true,
                                "type": "object",
                                "properties": {
                                  "admissionControllerConfig": {
                                    "nullable": true,
                                    "type": "object",
                                    "properties": {
                                      "enabled": {
                                        "type": "boolean"
                                      },
                                      "timeoutSeconds": {
                                        "type": "integer",
                                        "format": "int32"
                                      },
                                      "scanInline": {
                                        "type": "boolean"
                                      },
                                      "disableBypass": {
                                        "type": "boolean"
                                      },
                                      "enforceOnUpdates": {
                                        "type": "boolean"
                                      }
                                    }
                                  },
                                  "registryOverride": {
                                    "nullable": true,
                                    "type": "string"
                                  },
                                  "disableAuditLogs": {
                                    "type": "boolean"
                                  }
                                },
                                "description": "The difference between Static and Dynamic cluster config is that Dynamic values are sent over the Central to Sensor gRPC connection. This has the benefit of allowing for \"hot reloading\" of values without restarting Secured cluster components."
                              },
                              "staticConfig": {
                                "nullable": true,
                                "type": "object",
                                "properties": {
                                  "type": {
                                    "nullable": true,
                                    "type": "string",
                                    "default": "GENERIC_CLUSTER",
                                    "enum": [
                                      "GENERIC_CLUSTER",
                                      "KUBERNETES_CLUSTER",
                                      "OPENSHIFT_CLUSTER",
                                      "OPENSHIFT4_CLUSTER"
                                    ]
                                  },
                                  "mainImage": {
                                    "nullable": true,
                                    "type": "string"
                                  },
                                  "centralApiEndpoint": {
                                    "nullable": true,
                                    "type": "string"
                                  },
                                  "collectionMethod": {
                                    "nullable": true,
                                    "type": "string",
                                    "default": "UNSET_COLLECTION",
                                    "enum": [
                                      "UNSET_COLLECTION",
                                      "NO_COLLECTION",
                                      "KERNEL_MODULE",
                                      "EBPF",
                                      "CORE_BPF"
                                    ]
                                  },
                                  "collectorImage": {
                                    "nullable": true,
                                    "type": "string"
                                  },
                                  "admissionController": {
                                    "type": "boolean"
                                  },
                                  "admissionControllerUpdates": {
                                    "type": "boolean"
                                  },
                                  "tolerationsConfig": {
                                    "nullable": true,
                                    "type": "object",
                                    "properties": {
                                      "disabled": {
                                        "type": "boolean"
                                      }
                                    }
                                  },
                                  "slimCollector": {
                                    "type": "boolean"
                                  },
                                  "admissionControllerEvents": {
                                    "type": "boolean"
                                  }
                                },
                                "description": "The difference between Static and Dynamic cluster config is that Static values are not sent over the Central to Sensor gRPC connection. They are used, for example, to generate manifests that can be used to set up the Secured Cluster's k8s components. They are *not* dynamically reloaded."
                              },
                              "configFingerprint": {
                                "nullable": true,
                                "type": "string"
                              },
                              "clusterLabels": {
                                "nullable": true,
                                "type": "object",
                                "additionalProperties": {
                                  "nullable": true,
                                  "type": "string"
                                }
                              }
                            },
                            "description": "Encodes a complete cluster configuration minus ID/Name identifiers\nincluding static and dynamic settings."
                          },
                          "mostRecentSensorId": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "systemNamespaceId": {
                                "nullable": true,
                                "type": "string"
                              },
                              "defaultNamespaceId": {
                                "nullable": true,
                                "type": "string"
                              },
                              "appNamespace": {
                                "nullable": true,
                                "type": "string"
                              },
                              "appNamespaceId": {
                                "nullable": true,
                                "type": "string"
                              },
                              "appServiceaccountId": {
                                "nullable": true,
                                "type": "string"
                              },
                              "k8sNodeName": {
                                "nullable": true,
                                "type": "string"
                              }
                            },
                            "description": "StackRoxDeploymentIdentification aims at uniquely identifying a StackRox Sensor deployment. It is used to determine\nwhether a sensor connection comes from a sensor pod that has restarted or was recreated (possibly after a network\npartition), or from a deployment in a different namespace or cluster."
                          },
                          "auditLogState": {
                            "nullable": true,
                            "type": "object",
                            "additionalProperties": {
                              "title": "AuditLogFileState tracks the last audit log event timestamp and ID that was collected by Compliance\nFor internal use only",
                              "nullable": true,
                              "type": "object",
                              "properties": {
                                "collectLogsSince": {
                                  "nullable": true,
                                  "type": "string",
                                  "format": "date-time"
                                },
                                "lastAuditId": {
                                  "title": "Previously received audit id. May be empty",
                                  "nullable": true,
                                  "type": "string"
                                }
                              }
                            },
                            "description": "For internal use only."
                          },
                          "initBundleId": {
                            "nullable": true,
                            "type": "string"
                          },
                          "managedBy": {
                            "nullable": true,
                            "type": "string",
                            "default": "MANAGER_TYPE_UNKNOWN",
                            "enum": [
                              "MANAGER_TYPE_UNKNOWN",
                              "MANAGER_TYPE_MANUAL",
                              "MANAGER_TYPE_HELM_CHART",
                              "MANAGER_TYPE_KUBERNETES_OPERATOR"
                            ]
                          },
                          "sensorCapabilities": {
                            "type": "array",
                            "items": {
                              "nullable": true,
                              "type": "string"
                            }
                          }
                        }
                      }
                    },
                    "clusterIdToRetentionInfo": {
                      "title": "Maps 'UNHEALTHY' clusters' IDs to their retention info",
                      "nullable": true,
                      "type": "object",
                      "additionalProperties": {
                        "title": "next available tag: 3",
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "isExcluded": {
                            "title": "indicates whether a cluster is protected from deletion",
                            "type": "boolean"
                          },
                          "daysUntilDeletion": {
                            "title": "days after which cluster will be deleted if sensor health remains UNHEALTHY",
                            "type": "integer",
                            "format": "int32"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "application/json": {
                "schema": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "nullable": true,
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "@type": {
                            "nullable": true,
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com. As of May 2023, there are no widely used type server\nimplementations and no plans to implement one.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          }
                        },
                        "additionalProperties": {
                          "nullable": true,
                          "type": "object"
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n    // or ...\n    if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n      foo = any.unpack(Foo.getDefaultInstance());\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "ClustersService"
        ],
        "operationId": "ClustersService_PostCluster",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "id": {
                    "nullable": true,
                    "type": "string"
                  },
                  "name": {
                    "nullable": true,
                    "type": "string"
                  },
                  "type": {
                    "nullable": true,
                    "type": "string",
                    "default": "GENERIC_CLUSTER",
                    "enum": [
                      "GENERIC_CLUSTER",
                      "KUBERNETES_CLUSTER",
                      "OPENSHIFT_CLUSTER",
                      "OPENSHIFT4_CLUSTER"
                    ]
                  },
                  "labels": {
                    "nullable": true,
                    "type": "object",
                    "additionalProperties": {
                      "nullable": true,
                      "type": "string"
                    }
                  },
                  "mainImage": {
                    "nullable": true,
                    "type": "string"
                  },
                  "collectorImage": {
                    "nullable": true,
                    "type": "string"
                  },
                  "centralApiEndpoint": {
                    "nullable": true,
                    "type": "string"
                  },
                  "runtimeSupport": {
                    "type": "boolean"
                  },
                  "collectionMethod": {
                    "nullable": true,
                    "type": "string",
                    "default": "UNSET_COLLECTION",
                    "enum": [
                      "UNSET_COLLECTION",
                      "NO_COLLECTION",
                      "KERNEL_MODULE",
                      "EBPF",
                      "CORE_BPF"
                    ]
                  },
                  "admissionController": {
                    "type": "boolean"
                  },
                  "admissionControllerUpdates": {
                    "type": "boolean"
                  },
                  "admissionControllerEvents": {
                    "type": "boolean"
                  },
                  "status": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "sensorVersion": {
                        "nullable": true,
                        "type": "string"
                      },
                      "DEPRECATEDLastContact": {
                        "nullable": true,
                        "type": "string",
                        "description": "This field has been deprecated starting release 49.0. Use healthStatus.lastContact instead.",
                        "format": "date-time"
                      },
                      "providerMetadata": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "region": {
                            "nullable": true,
                            "type": "string"
                          },
                          "zone": {
                            "nullable": true,
                            "type": "string"
                          },
                          "google": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "project": {
                                "nullable": true,
                                "type": "string"
                              },
                              "clusterName": {
                                "nullable": true,
                                "type": "string",
                                "description": "Deprecated in favor of providerMetadata.cluster.name."
                              }
                            }
                          },
                          "aws": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "accountId": {
                                "nullable": true,
                                "type": "string"
                              }
                            }
                          },
                          "azure": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "subscriptionId": {
                                "nullable": true,
                                "type": "string"
                              }
                            }
                          },
                          "verified": {
                            "type": "boolean"
                          },
                          "cluster": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "type": {
                                "nullable": true,
                                "type": "string",
                                "default": "UNSPECIFIED",
                                "enum": [
                                  "UNSPECIFIED",
                                  "AKS",
                                  "ARO",
                                  "EKS",
                                  "GKE",
                                  "OCP",
                                  "OSD",
                                  "ROSA"
                                ]
                              },
                              "name": {
                                "nullable": true,
                                "type": "string",
                                "description": "Name represents the name under which the cluster is registered with the\ncloud provider. In case of self managed OpenShift it is the name chosen\nby the OpenShift installer."
                              },
                              "id": {
                                "nullable": true,
                                "type": "string",
                                "description": "Id represents a unique ID under which the cluster is registered with the\ncloud provider. Not all cluster types have an id. For all OpenShift\nclusters, this is the Red Hat `cluster_id` registered with OCM."
                              }
                            },
                            "description": "ClusterMetadata contains metadata information about the cluster infrastructure."
                          }
                        }
                      },
                      "orchestratorMetadata": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "version": {
                            "nullable": true,
                            "type": "string"
                          },
                          "openshiftVersion": {
                            "nullable": true,
                            "type": "string"
                          },
                          "buildDate": {
                            "nullable": true,
                            "type": "string",
                            "format": "date-time"
                          },
                          "apiVersions": {
                            "type": "array",
                            "items": {
                              "nullable": true,
                              "type": "string"
                            }
                          }
                        }
                      },
                      "upgradeStatus": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "upgradability": {
                            "nullable": true,
                            "type": "string",
                            "description": " - SENSOR_VERSION_HIGHER: SENSOR_VERSION_HIGHER occurs when we detect that the sensor\nis running a newer version than this Central. This is unexpected,\nbut can occur depending on the patches a customer does.\nIn this case, we will NOT automatically \"upgrade\" the sensor,\nsince that would be a downgrade, even if the autoupgrade setting is\non. The user will be allowed to manually trigger the upgrade, but they are\nstrongly discouraged from doing so without upgrading Central first, since this\nis an unsupported configuration.",
                            "default": "UNSET",
                            "enum": [
                              "UNSET",
                              "UP_TO_DATE",
                              "MANUAL_UPGRADE_REQUIRED",
                              "AUTO_UPGRADE_POSSIBLE",
                              "SENSOR_VERSION_HIGHER"
                            ]
                          },
                          "upgradabilityStatusReason": {
                            "nullable": true,
                            "type": "string"
                          },
                          "mostRecentProcess": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "active": {
                                "type": "boolean"
                              },
                              "id": {
                                "nullable": true,
                                "type": "string"
                              },
                              "targetVersion": {
                                "title": "only relevant if type == Upgrade",
                                "nullable": true,
                                "type": "string"
                              },
                              "upgraderImage": {
                                "nullable": true,
                                "type": "string"
                              },
                              "initiatedAt": {
                                "nullable": true,
                                "type": "string",
                                "format": "date-time"
                              },
                              "progress": {
                                "nullable": true,
                                "type": "object",
                                "properties": {
                                  "upgradeState": {
                                    "nullable": true,
                                    "type": "string",
                                    "description": " - UPGRADER_LAUNCHING: In-progress states.\n - UPGRADE_COMPLETE: The success state.\nPLEASE NUMBER ALL IN-PROGRESS STATES ABOVE THIS\nAND ALL ERROR STATES BELOW THIS.\n - UPGRADE_INITIALIZATION_ERROR: Error states.",
                                    "default": "UPGRADE_INITIALIZING",
                                    "enum": [
                                      "UPGRADE_INITIALIZING",
                                      "UPGRADER_LAUNCHING",
                                      "UPGRADER_LAUNCHED",
                                      "PRE_FLIGHT_CHECKS_COMPLETE",
                                      "UPGRADE_OPERATIONS_DONE",
                                      "UPGRADE_COMPLETE",
                                      "UPGRADE_INITIALIZATION_ERROR",
                                      "PRE_FLIGHT_CHECKS_FAILED",
                                      "UPGRADE_ERROR_ROLLING_BACK",
                                      "UPGRADE_ERROR_ROLLED_BACK",
                                      "UPGRADE_ERROR_ROLLBACK_FAILED",
                                      "UPGRADE_ERROR_UNKNOWN",
                                      "UPGRADE_TIMED_OUT"
                                    ]
                                  },
                                  "upgradeStatusDetail": {
                                    "nullable": true,
                                    "type": "string"
                                  },
                                  "since": {
                                    "nullable": true,
                                    "type": "string",
                                    "format": "date-time"
                                  }
                                }
                              },
                              "type": {
                                "nullable": true,
                                "type": "string",
                                "description": " - UPGRADE: UPGRADE represents a sensor version upgrade.\n - CERT_ROTATION: CERT_ROTATION represents an upgrade process that only rotates the TLS certs\nused by the cluster, without changing anything else.",
                                "default": "UPGRADE",
                                "enum": [
                                  "UPGRADE",
                                  "CERT_ROTATION"
                                ]
                              }
                            }
                          }
                        }
                      },
                      "certExpiryStatus": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "sensorCertExpiry": {
                            "nullable": true,
                            "type": "string",
                            "format": "date-time"
                          },
                          "sensorCertNotBefore": {
                            "nullable": true,
                            "type": "string",
                            "format": "date-time"
                          }
                        }
                      }
                    }
                  },
                  "dynamicConfig": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "admissionControllerConfig": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "enabled": {
                            "type": "boolean"
                          },
                          "timeoutSeconds": {
                            "type": "integer",
                            "format": "int32"
                          },
                          "scanInline": {
                            "type": "boolean"
                          },
                          "disableBypass": {
                            "type": "boolean"
                          },
                          "enforceOnUpdates": {
                            "type": "boolean"
                          }
                        }
                      },
                      "registryOverride": {
                        "nullable": true,
                        "type": "string"
                      },
                      "disableAuditLogs": {
                        "type": "boolean"
                      }
                    },
                    "description": "The difference between Static and Dynamic cluster config is that Dynamic values are sent over the Central to Sensor gRPC connection. This has the benefit of allowing for \"hot reloading\" of values without restarting Secured cluster components."
                  },
                  "tolerationsConfig": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "disabled": {
                        "type": "boolean"
                      }
                    }
                  },
                  "priority": {
                    "nullable": true,
                    "type": "string",
                    "format": "int64"
                  },
                  "healthStatus": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "id": {
                        "nullable": true,
                        "type": "string"
                      },
                      "collectorHealthInfo": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "version": {
                            "title": "This is the version of the collector deamonset as returned by k8s API",
                            "nullable": true,
                            "type": "string"
                          },
                          "totalDesiredPods": {
                            "type": "integer",
                            "format": "int32"
                          },
                          "totalReadyPods": {
                            "type": "integer",
                            "format": "int32"
                          },
                          "totalRegisteredNodes": {
                            "type": "integer",
                            "format": "int32"
                          },
                          "statusErrors": {
                            "type": "array",
                            "description": "Collection of errors that occurred while trying to obtain collector health info.",
                            "items": {
                              "nullable": true,
                              "type": "string"
                            }
                          }
                        },
                        "description": "CollectorHealthInfo carries data about collector deployment but does not include collector health status derived from this data.\nAggregated collector health status is not included because it is derived in central and not in the component that\nfirst reports CollectorHealthInfo (sensor)."
                      },
                      "admissionControlHealthInfo": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "totalDesiredPods": {
                            "type": "integer",
                            "format": "int32"
                          },
                          "totalReadyPods": {
                            "type": "integer",
                            "format": "int32"
                          },
                          "statusErrors": {
                            "type": "array",
                            "description": "Collection of errors that occurred while trying to obtain admission control health info.",
                            "items": {
                              "nullable": true,
                              "type": "string"
                            }
                          }
                        },
                        "description": "AdmissionControlHealthInfo carries data about admission control deployment but does not include admission control health status\nderived from this data.\nAggregated admission control health status is not included because it is derived in central and not in the component that\nfirst reports AdmissionControlHealthInfo (sensor).\n\nThe following fields are made optional/nullable because there can be errors when trying to obtain them and\n the default value of 0 might be confusing with the actual value 0. In case an error happens when trying to obtain\n a certain field, it will be absent (instead of having the default value)."
                      },
                      "scannerHealthInfo": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "totalDesiredAnalyzerPods": {
                            "type": "integer",
                            "format": "int32"
                          },
                          "totalReadyAnalyzerPods": {
                            "type": "integer",
                            "format": "int32"
                          },
                          "totalDesiredDbPods": {
                            "type": "integer",
                            "format": "int32"
                          },
                          "totalReadyDbPods": {
                            "type": "integer",
                            "format": "int32"
                          },
                          "statusErrors": {
                            "type": "array",
                            "description": "Collection of errors that occurred while trying to obtain scanner health info.",
                            "items": {
                              "nullable": true,
                              "type": "string"
                            }
                          }
                        },
                        "description": "ScannerHealthInfo represents health info of a scanner instance that is deployed on a secured cluster (so called \"local scanner\").\nWhen the scanner is deployed on a central cluster, the following message is NOT used.\nScannerHealthInfo carries data about scanner deployment but does not include scanner health status\nderived from this data.\nAggregated scanner health status is not included because it is derived in central and not in the component that\nfirst reports ScannerHealthInfo (sensor).\n\nThe following fields are made optional/nullable because there can be errors when trying to obtain them and\n the default value of 0 might be confusing with the actual value 0. In case an error happens when trying to obtain\n a certain field, it will be absent (instead of having the default value)."
                      },
                      "sensorHealthStatus": {
                        "title": "- UNAVAILABLE: Only collector can have unavailable status",
                        "nullable": true,
                        "type": "string",
                        "default": "UNINITIALIZED",
                        "enum": [
                          "UNINITIALIZED",
                          "UNAVAILABLE",
                          "UNHEALTHY",
                          "DEGRADED",
                          "HEALTHY"
                        ]
                      },
                      "collectorHealthStatus": {
                        "title": "- UNAVAILABLE: Only collector can have unavailable status",
                        "nullable": true,
                        "type": "string",
                        "default": "UNINITIALIZED",
                        "enum": [
                          "UNINITIALIZED",
                          "UNAVAILABLE",
                          "UNHEALTHY",
                          "DEGRADED",
                          "HEALTHY"
                        ]
                      },
                      "overallHealthStatus": {
                        "title": "- UNAVAILABLE: Only collector can have unavailable status",
                        "nullable": true,
                        "type": "string",
                        "default": "UNINITIALIZED",
                        "enum": [
                          "UNINITIALIZED",
                          "UNAVAILABLE",
                          "UNHEALTHY",
                          "DEGRADED",
                          "HEALTHY"
                        ]
                      },
                      "admissionControlHealthStatus": {
                        "title": "- UNAVAILABLE: Only collector can have unavailable status",
                        "nullable": true,
                        "type": "string",
                        "default": "UNINITIALIZED",
                        "enum": [
                          "UNINITIALIZED",
                          "UNAVAILABLE",
                          "UNHEALTHY",
                          "DEGRADED",
                          "HEALTHY"
                        ]
                      },
                      "scannerHealthStatus": {
                        "title": "- UNAVAILABLE: Only collector can have unavailable status",
                        "nullable": true,
                        "type": "string",
                        "default": "UNINITIALIZED",
                        "enum": [
                          "UNINITIALIZED",
                          "UNAVAILABLE",
                          "UNHEALTHY",
                          "DEGRADED",
                          "HEALTHY"
                        ]
                      },
                      "lastContact": {
                        "nullable": true,
                        "type": "string",
                        "description": "For sensors not having health capability, this will be filled with gRPC connection poll. Otherwise,\nthis timestamp will be updated by central pipeline when message is processed.\n\nNote: we use this setting to guard against a specific attack vector during CRS-based cluster registration.\nAssuming that a CRS was used to register a cluster A and the CRS is leaked, an attacker shall not be able\nto re-run the CRS-flow which would then equip the attacker with a certificate & key issued to the cluster A.\nAs countermeasure we only allow re-running the CRS-flow only as long as the last_contact field is empty,\nindicating that the legit cluster A's sensor has not yet connected with the CRS-issued service certificates.",
                        "format": "date-time"
                      },
                      "healthInfoComplete": {
                        "title": "To track cases such as when sensor is healthy, but collector status data is unavailable because the sensor is on an old version",
                        "type": "boolean"
                      }
                    }
                  },
                  "slimCollector": {
                    "type": "boolean"
                  },
                  "helmConfig": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "dynamicConfig": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "admissionControllerConfig": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "enabled": {
                                "type": "boolean"
                              },
                              "timeoutSeconds": {
                                "type": "integer",
                                "format": "int32"
                              },
                              "scanInline": {
                                "type": "boolean"
                              },
                              "disableBypass": {
                                "type": "boolean"
                              },
                              "enforceOnUpdates": {
                                "type": "boolean"
                              }
                            }
                          },
                          "registryOverride": {
                            "nullable": true,
                            "type": "string"
                          },
                          "disableAuditLogs": {
                            "type": "boolean"
                          }
                        },
                        "description": "The difference between Static and Dynamic cluster config is that Dynamic values are sent over the Central to Sensor gRPC connection. This has the benefit of allowing for \"hot reloading\" of values without restarting Secured cluster components."
                      },
                      "staticConfig": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "type": {
                            "nullable": true,
                            "type": "string",
                            "default": "GENERIC_CLUSTER",
                            "enum": [
                              "GENERIC_CLUSTER",
                              "KUBERNETES_CLUSTER",
                              "OPENSHIFT_CLUSTER",
                              "OPENSHIFT4_CLUSTER"
                            ]
                          },
                          "mainImage": {
                            "nullable": true,
                            "type": "string"
                          },
                          "centralApiEndpoint": {
                            "nullable": true,
                            "type": "string"
                          },
                          "collectionMethod": {
                            "nullable": true,
                            "type": "string",
                            "default": "UNSET_COLLECTION",
                            "enum": [
                              "UNSET_COLLECTION",
                              "NO_COLLECTION",
                              "KERNEL_MODULE",
                              "EBPF",
                              "CORE_BPF"
                            ]
                          },
                          "collectorImage": {
                            "nullable": true,
                            "type": "string"
                          },
                          "admissionController": {
                            "type": "boolean"
                          },
                          "admissionControllerUpdates": {
                            "type": "boolean"
                          },
                          "tolerationsConfig": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "disabled": {
                                "type": "boolean"
                              }
                            }
                          },
                          "slimCollector": {
                            "type": "boolean"
                          },
                          "admissionControllerEvents": {
                            "type": "boolean"
                          }
                        },
                        "description": "The difference between Static and Dynamic cluster config is that Static values are not sent over the Central to Sensor gRPC connection. They are used, for example, to generate manifests that can be used to set up the Secured Cluster's k8s components. They are *not* dynamically reloaded."
                      },
                      "configFingerprint": {
                        "nullable": true,
                        "type": "string"
                      },
                      "clusterLabels": {
                        "nullable": true,
                        "type": "object",
                        "additionalProperties": {
                          "nullable": true,
                          "type": "string"
                        }
                      }
                    },
                    "description": "Encodes a complete cluster configuration minus ID/Name identifiers\nincluding static and dynamic settings."
                  },
                  "mostRecentSensorId": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "systemNamespaceId": {
                        "nullable": true,
                        "type": "string"
                      },
                      "defaultNamespaceId": {
                        "nullable": true,
                        "type": "string"
                      },
                      "appNamespace": {
                        "nullable": true,
                        "type": "string"
                      },
                      "appNamespaceId": {
                        "nullable": true,
                        "type": "string"
                      },
                      "appServiceaccountId": {
                        "nullable": true,
                        "type": "string"
                      },
                      "k8sNodeName": {
                        "nullable": true,
                        "type": "string"
                      }
                    },
                    "description": "StackRoxDeploymentIdentification aims at uniquely identifying a StackRox Sensor deployment. It is used to determine\nwhether a sensor connection comes from a sensor pod that has restarted or was recreated (possibly after a network\npartition), or from a deployment in a different namespace or cluster."
                  },
                  "auditLogState": {
                    "nullable": true,
                    "type": "object",
                    "additionalProperties": {
                      "title": "AuditLogFileState tracks the last audit log event timestamp and ID that was collected by Compliance\nFor internal use only",
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "collectLogsSince": {
                          "nullable": true,
                          "type": "string",
                          "format": "date-time"
                        },
                        "lastAuditId": {
                          "title": "Previously received audit id. May be empty",
                          "nullable": true,
                          "type": "string"
                        }
                      }
                    },
                    "description": "For internal use only."
                  },
                  "initBundleId": {
                    "nullable": true,
                    "type": "string"
                  },
                  "managedBy": {
                    "nullable": true,
                    "type": "string",
                    "default": "MANAGER_TYPE_UNKNOWN",
                    "enum": [
                      "MANAGER_TYPE_UNKNOWN",
                      "MANAGER_TYPE_MANUAL",
                      "MANAGER_TYPE_HELM_CHART",
                      "MANAGER_TYPE_KUBERNETES_OPERATOR"
                    ]
                  },
                  "sensorCapabilities": {
                    "type": "array",
                    "items": {
                      "nullable": true,
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "cluster": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "id": {
                          "nullable": true,
                          "type": "string"
                        },
                        "name": {
                          "nullable": true,
                          "type": "string"
                        },
                        "type": {
                          "nullable": true,
                          "type": "string",
                          "default": "GENERIC_CLUSTER",
                          "enum": [
                            "GENERIC_CLUSTER",
                            "KUBERNETES_CLUSTER",
                            "OPENSHIFT_CLUSTER",
                            "OPENSHIFT4_CLUSTER"
                          ]
                        },
                        "labels": {
                          "nullable": true,
                          "type": "object",
                          "additionalProperties": {
                            "nullable": true,
                            "type": "string"
                          }
                        },
                        "mainImage": {
                          "nullable": true,
                          "type": "string"
                        },
                        "collectorImage": {
                          "nullable": true,
                          "type": "string"
                        },
                        "centralApiEndpoint": {
                          "nullable": true,
                          "type": "string"
                        },
                        "runtimeSupport": {
                          "type": "boolean"
                        },
                        "collectionMethod": {
                          "nullable": true,
                          "type": "string",
                          "default": "UNSET_COLLECTION",
                          "enum": [
                            "UNSET_COLLECTION",
                            "NO_COLLECTION",
                            "KERNEL_MODULE",
                            "EBPF",
                            "CORE_BPF"
                          ]
                        },
                        "admissionController": {
                          "type": "boolean"
                        },
                        "admissionControllerUpdates": {
                          "type": "boolean"
                        },
                        "admissionControllerEvents": {
                          "type": "boolean"
                        },
                        "status": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "sensorVersion": {
                              "nullable": true,
                              "type": "string"
                            },
                            "DEPRECATEDLastContact": {
                              "nullable": true,
                              "type": "string",
                              "description": "This field has been deprecated starting release 49.0. Use healthStatus.lastContact instead.",
                              "format": "date-time"
                            },
                            "providerMetadata": {
                              "nullable": true,
                              "type": "object",
                              "properties": {
                                "region": {
                                  "nullable": true,
                                  "type": "string"
                                },
                                "zone": {
                                  "nullable": true,
                                  "type": "string"
                                },
                                "google": {
                                  "nullable": true,
                                  "type": "object",
                                  "properties": {
                                    "project": {
                                      "nullable": true,
                                      "type": "string"
                                    },
                                    "clusterName": {
                                      "nullable": true,
                                      "type": "string",
                                      "description": "Deprecated in favor of providerMetadata.cluster.name."
                                    }
                                  }
                                },
                                "aws": {
                                  "nullable": true,
                                  "type": "object",
                                  "properties": {
                                    "accountId": {
                                      "nullable": true,
                                      "type": "string"
                                    }
                                  }
                                },
                                "azure": {
                                  "nullable": true,
                                  "type": "object",
                                  "properties": {
                                    "subscriptionId": {
                                      "nullable": true,
                                      "type": "string"
                                    }
                                  }
                                },
                                "verified": {
                                  "type": "boolean"
                                },
                                "cluster": {
                                  "nullable": true,
                                  "type": "object",
                                  "properties": {
                                    "type": {
                                      "nullable": true,
                                      "type": "string",
                                      "default": "UNSPECIFIED",
                                      "enum": [
                                        "UNSPECIFIED",
                                        "AKS",
                                        "ARO",
                                        "EKS",
                                        "GKE",
                                        "OCP",
                                        "OSD",
                                        "ROSA"
                                      ]
                                    },
                                    "name": {
                                      "nullable": true,
                                      "type": "string",
                                      "description": "Name represents the name under which the cluster is registered with the\ncloud provider. In case of self managed OpenShift it is the name chosen\nby the OpenShift installer."
                                    },
                                    "id": {
                                      "nullable": true,
                                      "type": "string",
                                      "description": "Id represents a unique ID under which the cluster is registered with the\ncloud provider. Not all cluster types have an id. For all OpenShift\nclusters, this is the Red Hat `cluster_id` registered with OCM."
                                    }
                                  },
                                  "description": "ClusterMetadata contains metadata information about the cluster infrastructure."
                                }
                              }
                            },
                            "orchestratorMetadata": {
                              "nullable": true,
                              "type": "object",
                              "properties": {
                                "version": {
                                  "nullable": true,
                                  "type": "string"
                                },
                                "openshiftVersion": {
                                  "nullable": true,
                                  "type": "string"
                                },
                                "buildDate": {
                                  "nullable": true,
                                  "type": "string",
                                  "format": "date-time"
                                },
                                "apiVersions": {
                                  "type": "array",
                                  "items": {
                                    "nullable": true,
                                    "type": "string"
                                  }
                                }
                              }
                            },
                            "upgradeStatus": {
                              "nullable": true,
                              "type": "object",
                              "properties": {
                                "upgradability": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": " - SENSOR_VERSION_HIGHER: SENSOR_VERSION_HIGHER occurs when we detect that the sensor\nis running a newer version than this Central. This is unexpected,\nbut can occur depending on the patches a customer does.\nIn this case, we will NOT automatically \"upgrade\" the sensor,\nsince that would be a downgrade, even if the autoupgrade setting is\non. The user will be allowed to manually trigger the upgrade, but they are\nstrongly discouraged from doing so without upgrading Central first, since this\nis an unsupported configuration.",
                                  "default": "UNSET",
                                  "enum": [
                                    "UNSET",
                                    "UP_TO_DATE",
                                    "MANUAL_UPGRADE_REQUIRED",
                                    "AUTO_UPGRADE_POSSIBLE",
                                    "SENSOR_VERSION_HIGHER"
                                  ]
                                },
                                "upgradabilityStatusReason": {
                                  "nullable": true,
                                  "type": "string"
                                },
                                "mostRecentProcess": {
                                  "nullable": true,
                                  "type": "object",
                                  "properties": {
                                    "active": {
                                      "type": "boolean"
                                    },
                                    "id": {
                                      "nullable": true,
                                      "type": "string"
                                    },
                                    "targetVersion": {
                                      "title": "only relevant if type == Upgrade",
                                      "nullable": true,
                                      "type": "string"
                                    },
                                    "upgraderImage": {
                                      "nullable": true,
                                      "type": "string"
                                    },
                                    "initiatedAt": {
                                      "nullable": true,
                                      "type": "string",
                                      "format": "date-time"
                                    },
                                    "progress": {
                                      "nullable": true,
                                      "type": "object",
                                      "properties": {
                                        "upgradeState": {
                                          "nullable": true,
                                          "type": "string",
                                          "description": " - UPGRADER_LAUNCHING: In-progress states.\n - UPGRADE_COMPLETE: The success state.\nPLEASE NUMBER ALL IN-PROGRESS STATES ABOVE THIS\nAND ALL ERROR STATES BELOW THIS.\n - UPGRADE_INITIALIZATION_ERROR: Error states.",
                                          "default": "UPGRADE_INITIALIZING",
                                          "enum": [
                                            "UPGRADE_INITIALIZING",
                                            "UPGRADER_LAUNCHING",
                                            "UPGRADER_LAUNCHED",
                                            "PRE_FLIGHT_CHECKS_COMPLETE",
                                            "UPGRADE_OPERATIONS_DONE",
                                            "UPGRADE_COMPLETE",
                                            "UPGRADE_INITIALIZATION_ERROR",
                                            "PRE_FLIGHT_CHECKS_FAILED",
                                            "UPGRADE_ERROR_ROLLING_BACK",
                                            "UPGRADE_ERROR_ROLLED_BACK",
                                            "UPGRADE_ERROR_ROLLBACK_FAILED",
                                            "UPGRADE_ERROR_UNKNOWN",
                                            "UPGRADE_TIMED_OUT"
                                          ]
                                        },
                                        "upgradeStatusDetail": {
                                          "nullable": true,
                                          "type": "string"
                                        },
                                        "since": {
                                          "nullable": true,
                                          "type": "string",
                                          "format": "date-time"
                                        }
                                      }
                                    },
                                    "type": {
                                      "nullable": true,
                                      "type": "string",
                                      "description": " - UPGRADE: UPGRADE represents a sensor version upgrade.\n - CERT_ROTATION: CERT_ROTATION represents an upgrade process that only rotates the TLS certs\nused by the cluster, without changing anything else.",
                                      "default": "UPGRADE",
                                      "enum": [
                                        "UPGRADE",
                                        "CERT_ROTATION"
                                      ]
                                    }
                                  }
                                }
                              }
                            },
                            "certExpiryStatus": {
                              "nullable": true,
                              "type": "object",
                              "properties": {
                                "sensorCertExpiry": {
                                  "nullable": true,
                                  "type": "string",
                                  "format": "date-time"
                                },
                                "sensorCertNotBefore": {
                                  "nullable": true,
                                  "type": "string",
                                  "format": "date-time"
                                }
                              }
                            }
                          }
                        },
                        "dynamicConfig": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "admissionControllerConfig": {
                              "nullable": true,
                              "type": "object",
                              "properties": {
                                "enabled": {
                                  "type": "boolean"
                                },
                                "timeoutSeconds": {
                                  "type": "integer",
                                  "format": "int32"
                                },
                                "scanInline": {
                                  "type": "boolean"
                                },
                                "disableBypass": {
                                  "type": "boolean"
                                },
                                "enforceOnUpdates": {
                                  "type": "boolean"
                                }
                              }
                            },
                            "registryOverride": {
                              "nullable": true,
                              "type": "string"
                            },
                            "disableAuditLogs": {
                              "type": "boolean"
                            }
                          },
                          "description": "The difference between Static and Dynamic cluster config is that Dynamic values are sent over the Central to Sensor gRPC connection. This has the benefit of allowing for \"hot reloading\" of values without restarting Secured cluster components."
                        },
                        "tolerationsConfig": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "disabled": {
                              "type": "boolean"
                            }
                          }
                        },
                        "priority": {
                          "nullable": true,
                          "type": "string",
                          "format": "int64"
                        },
                        "healthStatus": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "id": {
                              "nullable": true,
                              "type": "string"
                            },
                            "collectorHealthInfo": {
                              "nullable": true,
                              "type": "object",
                              "properties": {
                                "version": {
                                  "title": "This is the version of the collector deamonset as returned by k8s API",
                                  "nullable": true,
                                  "type": "string"
                                },
                                "totalDesiredPods": {
                                  "type": "integer",
                                  "format": "int32"
                                },
                                "totalReadyPods": {
                                  "type": "integer",
                                  "format": "int32"
                                },
                                "totalRegisteredNodes": {
                                  "type": "integer",
                                  "format": "int32"
                                },
                                "statusErrors": {
                                  "type": "array",
                                  "description": "Collection of errors that occurred while trying to obtain collector health info.",
                                  "items": {
                                    "nullable": true,
                                    "type": "string"
                                  }
                                }
                              },
                              "description": "CollectorHealthInfo carries data about collector deployment but does not include collector health status derived from this data.\nAggregated collector health status is not included because it is derived in central and not in the component that\nfirst reports CollectorHealthInfo (sensor)."
                            },
                            "admissionControlHealthInfo": {
                              "nullable": true,
                              "type": "object",
                              "properties": {
                                "totalDesiredPods": {
                                  "type": "integer",
                                  "format": "int32"
                                },
                                "totalReadyPods": {
                                  "type": "integer",
                                  "format": "int32"
                                },
                                "statusErrors": {
                                  "type": "array",
                                  "description": "Collection of errors that occurred while trying to obtain admission control health info.",
                                  "items": {
                                    "nullable": true,
                                    "type": "string"
                                  }
                                }
                              },
                              "description": "AdmissionControlHealthInfo carries data about admission control deployment but does not include admission control health status\nderived from this data.\nAggregated admission control health status is not included because it is derived in central and not in the component that\nfirst reports AdmissionControlHealthInfo (sensor).\n\nThe following fields are made optional/nullable because there can be errors when trying to obtain them and\n the default value of 0 might be confusing with the actual value 0. In case an error happens when trying to obtain\n a certain field, it will be absent (instead of having the default value)."
                            },
                            "scannerHealthInfo": {
                              "nullable": true,
                              "type": "object",
                              "properties": {
                                "totalDesiredAnalyzerPods": {
                                  "type": "integer",
                                  "format": "int32"
                                },
                                "totalReadyAnalyzerPods": {
                                  "type": "integer",
                                  "format": "int32"
                                },
                                "totalDesiredDbPods": {
                                  "type": "integer",
                                  "format": "int32"
                                },
                                "totalReadyDbPods": {
                                  "type": "integer",
                                  "format": "int32"
                                },
                                "statusErrors": {
                                  "type": "array",
                                  "description": "Collection of errors that occurred while trying to obtain scanner health info.",
                                  "items": {
                                    "nullable": true,
                                    "type": "string"
                                  }
                                }
                              },
                              "description": "ScannerHealthInfo represents health info of a scanner instance that is deployed on a secured cluster (so called \"local scanner\").\nWhen the scanner is deployed on a central cluster, the following message is NOT used.\nScannerHealthInfo carries data about scanner deployment but does not include scanner health status\nderived from this data.\nAggregated scanner health status is not included because it is derived in central and not in the component that\nfirst reports ScannerHealthInfo (sensor).\n\nThe following fields are made optional/nullable because there can be errors when trying to obtain them and\n the default value of 0 might be confusing with the actual value 0. In case an error happens when trying to obtain\n a certain field, it will be absent (instead of having the default value)."
                            },
                            "sensorHealthStatus": {
                              "title": "- UNAVAILABLE: Only collector can have unavailable status",
                              "nullable": true,
                              "type": "string",
                              "default": "UNINITIALIZED",
                              "enum": [
                                "UNINITIALIZED",
                                "UNAVAILABLE",
                                "UNHEALTHY",
                                "DEGRADED",
                                "HEALTHY"
                              ]
                            },
                            "collectorHealthStatus": {
                              "title": "- UNAVAILABLE: Only collector can have unavailable status",
                              "nullable": true,
                              "type": "string",
                              "default": "UNINITIALIZED",
                              "enum": [
                                "UNINITIALIZED",
                                "UNAVAILABLE",
                                "UNHEALTHY",
                                "DEGRADED",
                                "HEALTHY"
                              ]
                            },
                            "overallHealthStatus": {
                              "title": "- UNAVAILABLE: Only collector can have unavailable status",
                              "nullable": true,
                              "type": "string",
                              "default": "UNINITIALIZED",
                              "enum": [
                                "UNINITIALIZED",
                                "UNAVAILABLE",
                                "UNHEALTHY",
                                "DEGRADED",
                                "HEALTHY"
                              ]
                            },
                            "admissionControlHealthStatus": {
                              "title": "- UNAVAILABLE: Only collector can have unavailable status",
                              "nullable": true,
                              "type": "string",
                              "default": "UNINITIALIZED",
                              "enum": [
                                "UNINITIALIZED",
                                "UNAVAILABLE",
                                "UNHEALTHY",
                                "DEGRADED",
                                "HEALTHY"
                              ]
                            },
                            "scannerHealthStatus": {
                              "title": "- UNAVAILABLE: Only collector can have unavailable status",
                              "nullable": true,
                              "type": "string",
                              "default": "UNINITIALIZED",
                              "enum": [
                                "UNINITIALIZED",
                                "UNAVAILABLE",
                                "UNHEALTHY",
                                "DEGRADED",
                                "HEALTHY"
                              ]
                            },
                            "lastContact": {
                              "nullable": true,
                              "type": "string",
                              "description": "For sensors not having health capability, this will be filled with gRPC connection poll. Otherwise,\nthis timestamp will be updated by central pipeline when message is processed.\n\nNote: we use this setting to guard against a specific attack vector during CRS-based cluster registration.\nAssuming that a CRS was used to register a cluster A and the CRS is leaked, an attacker shall not be able\nto re-run the CRS-flow which would then equip the attacker with a certificate & key issued to the cluster A.\nAs countermeasure we only allow re-running the CRS-flow only as long as the last_contact field is empty,\nindicating that the legit cluster A's sensor has not yet connected with the CRS-issued service certificates.",
                              "format": "date-time"
                            },
                            "healthInfoComplete": {
                              "title": "To track cases such as when sensor is healthy, but collector status data is unavailable because the sensor is on an old version",
                              "type": "boolean"
                            }
                          }
                        },
                        "slimCollector": {
                          "type": "boolean"
                        },
                        "helmConfig": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "dynamicConfig": {
                              "nullable": true,
                              "type": "object",
                              "properties": {
                                "admissionControllerConfig": {
                                  "nullable": true,
                                  "type": "object",
                                  "properties": {
                                    "enabled": {
                                      "type": "boolean"
                                    },
                                    "timeoutSeconds": {
                                      "type": "integer",
                                      "format": "int32"
                                    },
                                    "scanInline": {
                                      "type": "boolean"
                                    },
                                    "disableBypass": {
                                      "type": "boolean"
                                    },
                                    "enforceOnUpdates": {
                                      "type": "boolean"
                                    }
                                  }
                                },
                                "registryOverride": {
                                  "nullable": true,
                                  "type": "string"
                                },
                                "disableAuditLogs": {
                                  "type": "boolean"
                                }
                              },
                              "description": "The difference between Static and Dynamic cluster config is that Dynamic values are sent over the Central to Sensor gRPC connection. This has the benefit of allowing for \"hot reloading\" of values without restarting Secured cluster components."
                            },
                            "staticConfig": {
                              "nullable": true,
                              "type": "object",
                              "properties": {
                                "type": {
                                  "nullable": true,
                                  "type": "string",
                                  "default": "GENERIC_CLUSTER",
                                  "enum": [
                                    "GENERIC_CLUSTER",
                                    "KUBERNETES_CLUSTER",
                                    "OPENSHIFT_CLUSTER",
                                    "OPENSHIFT4_CLUSTER"
                                  ]
                                },
                                "mainImage": {
                                  "nullable": true,
                                  "type": "string"
                                },
                                "centralApiEndpoint": {
                                  "nullable": true,
                                  "type": "string"
                                },
                                "collectionMethod": {
                                  "nullable": true,
                                  "type": "string",
                                  "default": "UNSET_COLLECTION",
                                  "enum": [
                                    "UNSET_COLLECTION",
                                    "NO_COLLECTION",
                                    "KERNEL_MODULE",
                                    "EBPF",
                                    "CORE_BPF"
                                  ]
                                },
                                "collectorImage": {
                                  "nullable": true,
                                  "type": "string"
                                },
                                "admissionController": {
                                  "type": "boolean"
                                },
                                "admissionControllerUpdates": {
                                  "type": "boolean"
                                },
                                "tolerationsConfig": {
                                  "nullable": true,
                                  "type": "object",
                                  "properties": {
                                    "disabled": {
                                      "type": "boolean"
                                    }
                                  }
                                },
                                "slimCollector": {
                                  "type": "boolean"
                                },
                                "admissionControllerEvents": {
                                  "type": "boolean"
                                }
                              },
                              "description": "The difference between Static and Dynamic cluster config is that Static values are not sent over the Central to Sensor gRPC connection. They are used, for example, to generate manifests that can be used to set up the Secured Cluster's k8s components. They are *not* dynamically reloaded."
                            },
                            "configFingerprint": {
                              "nullable": true,
                              "type": "string"
                            },
                            "clusterLabels": {
                              "nullable": true,
                              "type": "object",
                              "additionalProperties": {
                                "nullable": true,
                                "type": "string"
                              }
                            }
                          },
                          "description": "Encodes a complete cluster configuration minus ID/Name identifiers\nincluding static and dynamic settings."
                        },
                        "mostRecentSensorId": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "systemNamespaceId": {
                              "nullable": true,
                              "type": "string"
                            },
                            "defaultNamespaceId": {
                              "nullable": true,
                              "type": "string"
                            },
                            "appNamespace": {
                              "nullable": true,
                              "type": "string"
                            },
                            "appNamespaceId": {
                              "nullable": true,
                              "type": "string"
                            },
                            "appServiceaccountId": {
                              "nullable": true,
                              "type": "string"
                            },
                            "k8sNodeName": {
                              "nullable": true,
                              "type": "string"
                            }
                          },
                          "description": "StackRoxDeploymentIdentification aims at uniquely identifying a StackRox Sensor deployment. It is used to determine\nwhether a sensor connection comes from a sensor pod that has restarted or was recreated (possibly after a network\npartition), or from a deployment in a different namespace or cluster."
                        },
                        "auditLogState": {
                          "nullable": true,
                          "type": "object",
                          "additionalProperties": {
                            "title": "AuditLogFileState tracks the last audit log event timestamp and ID that was collected by Compliance\nFor internal use only",
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "collectLogsSince": {
                                "nullable": true,
                                "type": "string",
                                "format": "date-time"
                              },
                              "lastAuditId": {
                                "title": "Previously received audit id. May be empty",
                                "nullable": true,
                                "type": "string"
                              }
                            }
                          },
                          "description": "For internal use only."
                        },
                        "initBundleId": {
                          "nullable": true,
                          "type": "string"
                        },
                        "managedBy": {
                          "nullable": true,
                          "type": "string",
                          "default": "MANAGER_TYPE_UNKNOWN",
                          "enum": [
                            "MANAGER_TYPE_UNKNOWN",
                            "MANAGER_TYPE_MANUAL",
                            "MANAGER_TYPE_HELM_CHART",
                            "MANAGER_TYPE_KUBERNETES_OPERATOR"
                          ]
                        },
                        "sensorCapabilities": {
                          "type": "array",
                          "items": {
                            "nullable": true,
                            "type": "string"
                          }
                        }
                      }
                    },
                    "clusterRetentionInfo": {
                      "title": "next available tag: 3",
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "isExcluded": {
                          "title": "indicates whether a cluster is protected from deletion",
                          "type": "boolean"
                        },
                        "daysUntilDeletion": {
                          "title": "days after which cluster will be deleted if sensor health remains UNHEALTHY",
                          "type": "integer",
                          "format": "int32"
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "application/json": {
                "schema": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "nullable": true,
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "@type": {
                            "nullable": true,
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com. As of May 2023, there are no widely used type server\nimplementations and no plans to implement one.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          }
                        },
                        "additionalProperties": {
                          "nullable": true,
                          "type": "object"
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n    // or ...\n    if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n      foo = any.unpack(Foo.getDefaultInstance());\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "x-codegen-request-body-name": "body"
      }
    },
    "/v1/cve/requests": {
      "get": {
        "tags": [
          "VulnerabilityRequestService"
        ],
        "summary": "ListVulnerabilityRequests returns the list of vulnerability requests.",
        "description": "**Query Behavior:**\n- Supports StackRox search syntax for filtering\n- Default pagination limit: 1000 requests\n- Maximum limit: 1000 requests per request\n\n**Search Examples:**\n- \"CVE:CVE-2021-1234\" - Requests for specific CVE\n- \"Request Status:PENDING\" - Pending requests only\n- \"Requested Vulnerability State:DEFERRED\" - Deferral requests only\n\n**Error Cases:**\n- 400: Invalid search query\n- 403: Insufficient permissions to view requests\n- 410: Service deprecated (when UnifiedCVEDeferral feature is enabled)",
        "operationId": "VulnerabilityRequestService_ListVulnerabilityRequests",
        "parameters": [
          {
            "name": "query",
            "in": "query",
            "schema": {
              "nullable": true,
              "type": "string"
            }
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "pagination.sortOption.field",
            "in": "query",
            "schema": {
              "nullable": true,
              "type": "string"
            }
          },
          {
            "name": "pagination.sortOption.reversed",
            "in": "query",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "pagination.sortOption.aggregateBy.aggrFunc",
            "in": "query",
            "schema": {
              "nullable": true,
              "type": "string",
              "default": "UNSET",
              "enum": [
                "UNSET",
                "COUNT",
                "MIN",
                "MAX"
              ]
            }
          },
          {
            "name": "pagination.sortOption.aggregateBy.distinct",
            "in": "query",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "requestInfos": {
                      "type": "array",
                      "description": "List of vulnerability requests matching the search criteria.\nLimited to maximum 1000 requests per response.",
                      "items": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "id": {
                            "nullable": true,
                            "type": "string",
                            "description": "Unique identifier for the vulnerability request (auto-generated).\nNew requests must not specify this field."
                          },
                          "name": {
                            "nullable": true,
                            "type": "string",
                            "description": "Human-readable name for the request (auto-generated).\nMust be unique across all requests."
                          },
                          "targetState": {
                            "nullable": true,
                            "type": "string",
                            "description": "VulnerabilityState indicates if vulnerability is being observed or deferred(/suppressed). By default, it vulnerabilities are observed.\n\n - OBSERVED: [Default state]",
                            "default": "OBSERVED",
                            "enum": [
                              "OBSERVED",
                              "DEFERRED",
                              "FALSE_POSITIVE"
                            ]
                          },
                          "status": {
                            "nullable": true,
                            "type": "string",
                            "description": "RequestStatus indicates the status of a vulnerability request.\n\n**Status Lifecycle:**\n- PENDING: Default state for new requests awaiting approval/denial\n- APPROVED: Request approved and enforced\n- DENIED: Request denied and permanently closed\n- APPROVED_PENDING_UPDATE: Approved request with pending update\n\n**Status Rules:**\n- New requests must start in PENDING state\n- Only PENDING requests can be approved or denied\n- APPROVED requests can be updated (creates APPROVED_PENDING_UPDATE)\n- DENIED requests are permanently closed\n- Cancelled requests are not persisted (except in audit logs)\n\n - PENDING: Default request state. It indicates that the request has not been fulfilled and that an action (approve/deny) is required.\nOnly requests in this state can be approved, denied, or updated.\n - APPROVED: Indicates that the request has been approved by the approver.\nApproved requests are immediately enforced and suppress vulnerability detection.\nOnly PENDING requests can transition to this state.\n - DENIED: Indicates that the request has been denied by the approver.\nDenied requests are permanently closed and have no impact on vulnerability detection.\nOnly PENDING requests can transition to this state.\n - APPROVED_PENDING_UPDATE: Indicates that the original request was approved, but an update is still pending an approval or denial.\nThis state occurs when an approved request is updated.\nThe original approval remains in effect until the update is processed.",
                            "default": "PENDING",
                            "enum": [
                              "PENDING",
                              "APPROVED",
                              "DENIED",
                              "APPROVED_PENDING_UPDATE"
                            ]
                          },
                          "expired": {
                            "type": "boolean",
                            "description": "Indicates if this request is a historical request that is no longer in effect\ndue to deferral expiry, cancellation, or restarting cve observation.\nExpired requests are retained for audit purposes."
                          },
                          "requestor": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "id": {
                                "nullable": true,
                                "type": "string"
                              },
                              "name": {
                                "nullable": true,
                                "type": "string"
                              }
                            }
                          },
                          "approvers": {
                            "type": "array",
                            "description": "DEPRECATED: Use approvers_v2 instead.\nUsers who can approve or deny the request.",
                            "items": {
                              "nullable": true,
                              "type": "object",
                              "properties": {
                                "id": {
                                  "nullable": true,
                                  "type": "string"
                                },
                                "name": {
                                  "nullable": true,
                                  "type": "string"
                                }
                              }
                            }
                          },
                          "createdAt": {
                            "nullable": true,
                            "type": "string",
                            "description": "Timestamp when the request was created.",
                            "format": "date-time"
                          },
                          "lastUpdated": {
                            "nullable": true,
                            "type": "string",
                            "description": "Timestamp when the request was last updated.",
                            "format": "date-time"
                          },
                          "comments": {
                            "type": "array",
                            "description": "Comments on the request providing audit trail.\nMust have at least one comment for new requests.",
                            "items": {
                              "nullable": true,
                              "type": "object",
                              "properties": {
                                "id": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "Unique identifier for the comment."
                                },
                                "message": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "The comment message content.\nRequired for all request actions."
                                },
                                "user": {
                                  "nullable": true,
                                  "type": "object",
                                  "properties": {
                                    "id": {
                                      "nullable": true,
                                      "type": "string"
                                    },
                                    "name": {
                                      "nullable": true,
                                      "type": "string"
                                    }
                                  }
                                },
                                "createdAt": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "Timestamp when the comment was created.",
                                  "format": "date-time"
                                }
                              },
                              "description": "RequestComment represents a comment on a vulnerability request.\n\n**Comment Rules:**\n- Comments are required for all request actions (create, approve, deny, update)\n- Each comment is associated with a user and timestamp\n- Comments provide audit trail for request lifecycle"
                            }
                          },
                          "scope": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "imageScope": {
                                "nullable": true,
                                "type": "object",
                                "properties": {
                                  "registry": {
                                    "nullable": true,
                                    "type": "string",
                                    "description": "Container registry (e.g., \"docker.io\", \"gcr.io\").\nRequired for image scope."
                                  },
                                  "remote": {
                                    "nullable": true,
                                    "type": "string",
                                    "description": "Image repository name (e.g., \"stackrox/main\").\nRequired for image scope."
                                  },
                                  "tag": {
                                    "nullable": true,
                                    "type": "string",
                                    "description": "Image tag (e.g., \"latest\", \"v1.0.0\").\nRequired for image scope."
                                  }
                                },
                                "description": "Image scope applies the request to specific container images."
                              },
                              "globalScope": {
                                "nullable": true,
                                "type": "object",
                                "description": "Global scope applies the request system-wide (deprecated)."
                              }
                            },
                            "description": "Scope defines the scope where the vulnerability request applies."
                          },
                          "requesterV2": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "id": {
                                "nullable": true,
                                "type": "string",
                                "description": "Unique identifier for the requester."
                              },
                              "name": {
                                "nullable": true,
                                "type": "string",
                                "description": "Display name of the requester."
                              }
                            },
                            "description": "Requester represents the user who created the vulnerability request.\n\n**Requester Rules:**\n- Must be specified for all new requests\n- Cannot be changed after request creation\n- Used for audit trail and permission checks"
                          },
                          "approversV2": {
                            "type": "array",
                            "description": "Users who can approve or deny the request (v2).\nMultiple approvers can be assigned.",
                            "items": {
                              "nullable": true,
                              "type": "object",
                              "properties": {
                                "id": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "Unique identifier for the approver."
                                },
                                "name": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "Display name of the approver."
                                }
                              },
                              "description": "Approver represents a user who can approve or deny vulnerability requests.\n\n**Approver Rules:**\n- Multiple approvers can be assigned to a request\n- Any approver can approve or deny the request\n- Used for audit trail and permission checks"
                            }
                          },
                          "deferralReq": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "expiry": {
                                "nullable": true,
                                "type": "object",
                                "properties": {
                                  "expiresWhenFixed": {
                                    "type": "boolean",
                                    "description": "Indicates that this request expires when the associated vulnerability is fixed.\nCannot be used with expires_on.\nOnly applicable to deferral requests."
                                  },
                                  "expiresOn": {
                                    "nullable": true,
                                    "type": "string",
                                    "description": "Indicates the timestamp when this request expires.\nCannot be used with expires_when_fixed.\nMust be a future timestamp.",
                                    "format": "date-time"
                                  },
                                  "expiryType": {
                                    "nullable": true,
                                    "type": "string",
                                    "description": "ExpiryType indicates the type of expiry for the request.\nThis field is under development, DO NOT USE FOR NON-DEVELOPMENT PURPOSES.\n\n - TIME: Request has a fixed expiry time. If used, expires_on must be set.\n - ALL_CVE_FIXABLE: Request expires if all CVEs in the request are fixable.\n - ANY_CVE_FIXABLE: Request expires if any CVE in the request is fixable.",
                                    "default": "TIME",
                                    "enum": [
                                      "TIME",
                                      "ALL_CVE_FIXABLE",
                                      "ANY_CVE_FIXABLE"
                                    ]
                                  }
                                },
                                "description": "RequestExpiry defines the expiration configuration for deferral requests.\n\n**Expiry Rules:**\n- Deferral requests must specify expiry (either expires_when_fixed or expires_on)\n- False-positive requests do not have expiry (permanent)\n- Cannot specify both expiry options\n- Expiry type is under development (do not use for non-development purposes)"
                              }
                            },
                            "description": "DeferralRequest represents a request to temporarily defer vulnerability detection.\n\n**Deferral Rules:**\n- Must specify expiry configuration\n- Expiry can be time-based or fix-based\n- Deferrals are temporary and expire automatically"
                          },
                          "fpRequest": {
                            "nullable": true,
                            "type": "object",
                            "description": "FalsePositiveRequest represents a request to permanently mark vulnerabilities as false-positive.\n\n**False-Positive Rules:**\n- No expiry configuration (permanent)\n- False-positives are permanently suppressed\n- Cannot be undone except through request management"
                          },
                          "cves": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "cves": {
                                "type": "array",
                                "description": "These are (NVD) vulnerability identifiers, `cve` field of `storage.CVE`, and *not* the `id` field.\nFor example, CVE-2021-44832.\nMust be in valid CVE format and not already covered by approved requests.",
                                "items": {
                                  "nullable": true,
                                  "type": "string"
                                }
                              }
                            },
                            "description": "CVEs represents the list of CVE identifiers in the request."
                          },
                          "updatedDeferralReq": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "expiry": {
                                "nullable": true,
                                "type": "object",
                                "properties": {
                                  "expiresWhenFixed": {
                                    "type": "boolean",
                                    "description": "Indicates that this request expires when the associated vulnerability is fixed.\nCannot be used with expires_on.\nOnly applicable to deferral requests."
                                  },
                                  "expiresOn": {
                                    "nullable": true,
                                    "type": "string",
                                    "description": "Indicates the timestamp when this request expires.\nCannot be used with expires_when_fixed.\nMust be a future timestamp.",
                                    "format": "date-time"
                                  },
                                  "expiryType": {
                                    "nullable": true,
                                    "type": "string",
                                    "description": "ExpiryType indicates the type of expiry for the request.\nThis field is under development, DO NOT USE FOR NON-DEVELOPMENT PURPOSES.\n\n - TIME: Request has a fixed expiry time. If used, expires_on must be set.\n - ALL_CVE_FIXABLE: Request expires if all CVEs in the request are fixable.\n - ANY_CVE_FIXABLE: Request expires if any CVE in the request is fixable.",
                                    "default": "TIME",
                                    "enum": [
                                      "TIME",
                                      "ALL_CVE_FIXABLE",
                                      "ANY_CVE_FIXABLE"
                                    ]
                                  }
                                },
                                "description": "RequestExpiry defines the expiration configuration for deferral requests.\n\n**Expiry Rules:**\n- Deferral requests must specify expiry (either expires_when_fixed or expires_on)\n- False-positive requests do not have expiry (permanent)\n- Cannot specify both expiry options\n- Expiry type is under development (do not use for non-development purposes)"
                              }
                            },
                            "description": "DeferralRequest represents a request to temporarily defer vulnerability detection.\n\n**Deferral Rules:**\n- Must specify expiry configuration\n- Expiry can be time-based or fix-based\n- Deferrals are temporary and expire automatically"
                          },
                          "deferralUpdate": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "CVEs": {
                                "type": "array",
                                "description": "CVEs to be updated in the deferral request.\nCannot be empty (at least one CVE must remain).",
                                "items": {
                                  "nullable": true,
                                  "type": "string"
                                }
                              },
                              "expiry": {
                                "nullable": true,
                                "type": "object",
                                "properties": {
                                  "expiresWhenFixed": {
                                    "type": "boolean",
                                    "description": "Indicates that this request expires when the associated vulnerability is fixed.\nCannot be used with expires_on.\nOnly applicable to deferral requests."
                                  },
                                  "expiresOn": {
                                    "nullable": true,
                                    "type": "string",
                                    "description": "Indicates the timestamp when this request expires.\nCannot be used with expires_when_fixed.\nMust be a future timestamp.",
                                    "format": "date-time"
                                  },
                                  "expiryType": {
                                    "nullable": true,
                                    "type": "string",
                                    "description": "ExpiryType indicates the type of expiry for the request.\nThis field is under development, DO NOT USE FOR NON-DEVELOPMENT PURPOSES.\n\n - TIME: Request has a fixed expiry time. If used, expires_on must be set.\n - ALL_CVE_FIXABLE: Request expires if all CVEs in the request are fixable.\n - ANY_CVE_FIXABLE: Request expires if any CVE in the request is fixable.",
                                    "default": "TIME",
                                    "enum": [
                                      "TIME",
                                      "ALL_CVE_FIXABLE",
                                      "ANY_CVE_FIXABLE"
                                    ]
                                  }
                                },
                                "description": "RequestExpiry defines the expiration configuration for deferral requests.\n\n**Expiry Rules:**\n- Deferral requests must specify expiry (either expires_when_fixed or expires_on)\n- False-positive requests do not have expiry (permanent)\n- Cannot specify both expiry options\n- Expiry type is under development (do not use for non-development purposes)"
                              }
                            },
                            "description": "DeferralUpdate represents an update to an existing deferral request.\n\n**Update Rules:**\n- Can add or remove CVEs from the request\n- Cannot remove all CVEs (at least one CVE must remain)\n- Can update expiry configuration\n- Creates a new pending update request"
                          },
                          "falsePositiveUpdate": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "CVEs": {
                                "type": "array",
                                "description": "CVEs to be updated in the false-positive request.\nCannot be empty (at least one CVE must remain).",
                                "items": {
                                  "nullable": true,
                                  "type": "string"
                                }
                              }
                            },
                            "description": "FalsePositiveUpdate represents an update to an existing false-positive request.\n\n**Update Rules:**\n- Can add or remove CVEs from the request\n- Cannot remove all CVEs (at least one CVE must remain)\n- False-positive requests remain permanent (no expiry)"
                          }
                        },
                        "description": "VulnerabilityRequest encapsulates a request such as deferral request and false-positive request.\n\n**Request Lifecycle:**\n- Creation: New request in PENDING state\n- Approval: Request approved and enforced\n- Denial: Request denied and closed\n- Update: Approved request with pending update\n- Expiry: Request expires automatically or manually\n- Undo: Approved request undone and vulnerabilities re-enabled\n\n**Validation Rules:**\n- New requests must not have ID (auto-generated)\n- Must have at least one comment\n- Must have valid CVE format (e.g., \"CVE-2021-1234\")\n- Must have valid scope (image scope or global scope)\n- Cannot create duplicate requests for same CVE-scope combination\n- Deferral requests must specify expiry\n- False-positive requests are permanent (no expiry)\n- New requests cannot start in APPROVED or DENIED state\n\n**Performance Considerations:**\n- Maximum 1000 requests returned per list operation\n- Requests are processed sequentially to prevent race conditions\n- Duplicate prevention checks are performed during creation"
                      }
                    }
                  },
                  "description": "ListVulnerabilityRequestsResponse contains the list of vulnerability requests."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "application/json": {
                "schema": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "nullable": true,
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "@type": {
                            "nullable": true,
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com. As of May 2023, there are no widely used type server\nimplementations and no plans to implement one.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          }
                        },
                        "additionalProperties": {
                          "nullable": true,
                          "type": "object"
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n    // or ...\n    if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n      foo = any.unpack(Foo.getDefaultInstance());\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/v1/cve/requests/defer": {
      "post": {
        "tags": [
          "VulnerabilityRequestService"
        ],
        "summary": "DeferVulnerability starts the deferral process for the specified vulnerability.",
        "description": "**Deferral Request Rules:**\n- CVE must be in valid format (e.g., \"CVE-2021-1234\")\n- Scope must be valid (image scope or global scope)\n- Expiry must be specified (either expires_when_fixed or expires_on)\n- Comment is required for request creation\n- Cannot create request for CVEs already covered by approved requests\n- Only one request can exist per CVE-scope combination\n\n**Expiry Options:**\n- expires_when_fixed: Request expires when CVE is fixed\n- expires_on: Request expires at specific timestamp\n- Cannot specify both expiry options\n\n**Error Cases:**\n- 400: Invalid CVE format, missing comment, invalid scope, or duplicate request\n- 403: Insufficient permissions to create requests\n- 409: CVE already covered by existing approved request\n- 410: Service deprecated (when UnifiedCVEDeferral feature is enabled)",
        "operationId": "VulnerabilityRequestService_DeferVulnerability",
        "requestBody": {
          "description": "DeferVulnRequest contains parameters for creating a vulnerability deferral request.\n\n**Deferral Request Rules:**\n- CVE must be in valid format (e.g., \"CVE-2021-1234\")\n- Scope must be valid (image scope or global scope)\n- Expiry must be specified (either expires_when_fixed or expires_on)\n- Comment is required for request creation\n- Cannot create request for CVEs already covered by approved requests\n- Only one request can exist per CVE-scope combination\n\n**Expiry Options:**\n- expires_when_fixed: Request expires when CVE is fixed\n- expires_on: Request expires at specific timestamp\n- Cannot specify both expiry options\n\n**Scope Validation:**\n- Image scope: Must specify valid registry, remote, and tag\n- Global scope: Applies to all images (deprecated)",
          "content": {
            "application/json": {
              "schema": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "cve": {
                    "nullable": true,
                    "type": "string",
                    "description": "CVE identifier to be deferred (e.g., \"CVE-2021-1234\").\nMust be in valid CVE format and not already covered by approved requests."
                  },
                  "comment": {
                    "nullable": true,
                    "type": "string",
                    "description": "Comment explaining the reason for the deferral request.\nRequired for request creation."
                  },
                  "scope": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "imageScope": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "registry": {
                            "nullable": true,
                            "type": "string",
                            "description": "Container registry (e.g., \"docker.io\", \"gcr.io\").\nRequired for image scope."
                          },
                          "remote": {
                            "nullable": true,
                            "type": "string",
                            "description": "Image repository name (e.g., \"stackrox/main\").\nRequired for image scope."
                          },
                          "tag": {
                            "nullable": true,
                            "type": "string",
                            "description": "Image tag (e.g., \"latest\", \"v1.0.0\").\nRequired for image scope."
                          }
                        },
                        "description": "Image scope applies the request to specific container images."
                      },
                      "globalScope": {
                        "nullable": true,
                        "type": "object",
                        "description": "Global scope applies the request system-wide (deprecated)."
                      }
                    },
                    "description": "Scope defines the scope where the vulnerability request applies."
                  },
                  "expiresWhenFixed": {
                    "type": "boolean",
                    "description": "When true, the deferral expires when the CVE is fixed.\nCannot be used with expires_on."
                  },
                  "expiresOn": {
                    "nullable": true,
                    "type": "string",
                    "description": "Timestamp when the deferral expires.\nCannot be used with expires_when_fixed.",
                    "format": "date-time"
                  }
                },
                "description": "DeferVulnRequest contains parameters for creating a vulnerability deferral request.\n\n**Deferral Request Rules:**\n- CVE must be in valid format (e.g., \"CVE-2021-1234\")\n- Scope must be valid (image scope or global scope)\n- Expiry must be specified (either expires_when_fixed or expires_on)\n- Comment is required for request creation\n- Cannot create request for CVEs already covered by approved requests\n- Only one request can exist per CVE-scope combination\n\n**Expiry Options:**\n- expires_when_fixed: Request expires when CVE is fixed\n- expires_on: Request expires at specific timestamp\n- Cannot specify both expiry options\n\n**Scope Validation:**\n- Image scope: Must specify valid registry, remote, and tag\n- Global scope: Applies to all images (deprecated)"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "requestInfo": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "id": {
                          "nullable": true,
                          "type": "string",
                          "description": "Unique identifier for the vulnerability request (auto-generated).\nNew requests must not specify this field."
                        },
                        "name": {
                          "nullable": true,
                          "type": "string",
                          "description": "Human-readable name for the request (auto-generated).\nMust be unique across all requests."
                        },
                        "targetState": {
                          "nullable": true,
                          "type": "string",
                          "description": "VulnerabilityState indicates if vulnerability is being observed or deferred(/suppressed). By default, it vulnerabilities are observed.\n\n - OBSERVED: [Default state]",
                          "default": "OBSERVED",
                          "enum": [
                            "OBSERVED",
                            "DEFERRED",
                            "FALSE_POSITIVE"
                          ]
                        },
                        "status": {
                          "nullable": true,
                          "type": "string",
                          "description": "RequestStatus indicates the status of a vulnerability request.\n\n**Status Lifecycle:**\n- PENDING: Default state for new requests awaiting approval/denial\n- APPROVED: Request approved and enforced\n- DENIED: Request denied and permanently closed\n- APPROVED_PENDING_UPDATE: Approved request with pending update\n\n**Status Rules:**\n- New requests must start in PENDING state\n- Only PENDING requests can be approved or denied\n- APPROVED requests can be updated (creates APPROVED_PENDING_UPDATE)\n- DENIED requests are permanently closed\n- Cancelled requests are not persisted (except in audit logs)\n\n - PENDING: Default request state. It indicates that the request has not been fulfilled and that an action (approve/deny) is required.\nOnly requests in this state can be approved, denied, or updated.\n - APPROVED: Indicates that the request has been approved by the approver.\nApproved requests are immediately enforced and suppress vulnerability detection.\nOnly PENDING requests can transition to this state.\n - DENIED: Indicates that the request has been denied by the approver.\nDenied requests are permanently closed and have no impact on vulnerability detection.\nOnly PENDING requests can transition to this state.\n - APPROVED_PENDING_UPDATE: Indicates that the original request was approved, but an update is still pending an approval or denial.\nThis state occurs when an approved request is updated.\nThe original approval remains in effect until the update is processed.",
                          "default": "PENDING",
                          "enum": [
                            "PENDING",
                            "APPROVED",
                            "DENIED",
                            "APPROVED_PENDING_UPDATE"
                          ]
                        },
                        "expired": {
                          "type": "boolean",
                          "description": "Indicates if this request is a historical request that is no longer in effect\ndue to deferral expiry, cancellation, or restarting cve observation.\nExpired requests are retained for audit purposes."
                        },
                        "requestor": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "id": {
                              "nullable": true,
                              "type": "string"
                            },
                            "name": {
                              "nullable": true,
                              "type": "string"
                            }
                          }
                        },
                        "approvers": {
                          "type": "array",
                          "description": "DEPRECATED: Use approvers_v2 instead.\nUsers who can approve or deny the request.",
                          "items": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "id": {
                                "nullable": true,
                                "type": "string"
                              },
                              "name": {
                                "nullable": true,
                                "type": "string"
                              }
                            }
                          }
                        },
                        "createdAt": {
                          "nullable": true,
                          "type": "string",
                          "description": "Timestamp when the request was created.",
                          "format": "date-time"
                        },
                        "lastUpdated": {
                          "nullable": true,
                          "type": "string",
                          "description": "Timestamp when the request was last updated.",
                          "format": "date-time"
                        },
                        "comments": {
                          "type": "array",
                          "description": "Comments on the request providing audit trail.\nMust have at least one comment for new requests.",
                          "items": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "id": {
                                "nullable": true,
                                "type": "string",
                                "description": "Unique identifier for the comment."
                              },
                              "message": {
                                "nullable": true,
                                "type": "string",
                                "description": "The comment message content.\nRequired for all request actions."
                              },
                              "user": {
                                "nullable": true,
                                "type": "object",
                                "properties": {
                                  "id": {
                                    "nullable": true,
                                    "type": "string"
                                  },
                                  "name": {
                                    "nullable": true,
                                    "type": "string"
                                  }
                                }
                              },
                              "createdAt": {
                                "nullable": true,
                                "type": "string",
                                "description": "Timestamp when the comment was created.",
                                "format": "date-time"
                              }
                            },
                            "description": "RequestComment represents a comment on a vulnerability request.\n\n**Comment Rules:**\n- Comments are required for all request actions (create, approve, deny, update)\n- Each comment is associated with a user and timestamp\n- Comments provide audit trail for request lifecycle"
                          }
                        },
                        "scope": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "imageScope": {
                              "nullable": true,
                              "type": "object",
                              "properties": {
                                "registry": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "Container registry (e.g., \"docker.io\", \"gcr.io\").\nRequired for image scope."
                                },
                                "remote": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "Image repository name (e.g., \"stackrox/main\").\nRequired for image scope."
                                },
                                "tag": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "Image tag (e.g., \"latest\", \"v1.0.0\").\nRequired for image scope."
                                }
                              },
                              "description": "Image scope applies the request to specific container images."
                            },
                            "globalScope": {
                              "nullable": true,
                              "type": "object",
                              "description": "Global scope applies the request system-wide (deprecated)."
                            }
                          },
                          "description": "Scope defines the scope where the vulnerability request applies."
                        },
                        "requesterV2": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "id": {
                              "nullable": true,
                              "type": "string",
                              "description": "Unique identifier for the requester."
                            },
                            "name": {
                              "nullable": true,
                              "type": "string",
                              "description": "Display name of the requester."
                            }
                          },
                          "description": "Requester represents the user who created the vulnerability request.\n\n**Requester Rules:**\n- Must be specified for all new requests\n- Cannot be changed after request creation\n- Used for audit trail and permission checks"
                        },
                        "approversV2": {
                          "type": "array",
                          "description": "Users who can approve or deny the request (v2).\nMultiple approvers can be assigned.",
                          "items": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "id": {
                                "nullable": true,
                                "type": "string",
                                "description": "Unique identifier for the approver."
                              },
                              "name": {
                                "nullable": true,
                                "type": "string",
                                "description": "Display name of the approver."
                              }
                            },
                            "description": "Approver represents a user who can approve or deny vulnerability requests.\n\n**Approver Rules:**\n- Multiple approvers can be assigned to a request\n- Any approver can approve or deny the request\n- Used for audit trail and permission checks"
                          }
                        },
                        "deferralReq": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "expiry": {
                              "nullable": true,
                              "type": "object",
                              "properties": {
                                "expiresWhenFixed": {
                                  "type": "boolean",
                                  "description": "Indicates that this request expires when the associated vulnerability is fixed.\nCannot be used with expires_on.\nOnly applicable to deferral requests."
                                },
                                "expiresOn": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "Indicates the timestamp when this request expires.\nCannot be used with expires_when_fixed.\nMust be a future timestamp.",
                                  "format": "date-time"
                                },
                                "expiryType": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "ExpiryType indicates the type of expiry for the request.\nThis field is under development, DO NOT USE FOR NON-DEVELOPMENT PURPOSES.\n\n - TIME: Request has a fixed expiry time. If used, expires_on must be set.\n - ALL_CVE_FIXABLE: Request expires if all CVEs in the request are fixable.\n - ANY_CVE_FIXABLE: Request expires if any CVE in the request is fixable.",
                                  "default": "TIME",
                                  "enum": [
                                    "TIME",
                                    "ALL_CVE_FIXABLE",
                                    "ANY_CVE_FIXABLE"
                                  ]
                                }
                              },
                              "description": "RequestExpiry defines the expiration configuration for deferral requests.\n\n**Expiry Rules:**\n- Deferral requests must specify expiry (either expires_when_fixed or expires_on)\n- False-positive requests do not have expiry (permanent)\n- Cannot specify both expiry options\n- Expiry type is under development (do not use for non-development purposes)"
                            }
                          },
                          "description": "DeferralRequest represents a request to temporarily defer vulnerability detection.\n\n**Deferral Rules:**\n- Must specify expiry configuration\n- Expiry can be time-based or fix-based\n- Deferrals are temporary and expire automatically"
                        },
                        "fpRequest": {
                          "nullable": true,
                          "type": "object",
                          "description": "FalsePositiveRequest represents a request to permanently mark vulnerabilities as false-positive.\n\n**False-Positive Rules:**\n- No expiry configuration (permanent)\n- False-positives are permanently suppressed\n- Cannot be undone except through request management"
                        },
                        "cves": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "cves": {
                              "type": "array",
                              "description": "These are (NVD) vulnerability identifiers, `cve` field of `storage.CVE`, and *not* the `id` field.\nFor example, CVE-2021-44832.\nMust be in valid CVE format and not already covered by approved requests.",
                              "items": {
                                "nullable": true,
                                "type": "string"
                              }
                            }
                          },
                          "description": "CVEs represents the list of CVE identifiers in the request."
                        },
                        "updatedDeferralReq": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "expiry": {
                              "nullable": true,
                              "type": "object",
                              "properties": {
                                "expiresWhenFixed": {
                                  "type": "boolean",
                                  "description": "Indicates that this request expires when the associated vulnerability is fixed.\nCannot be used with expires_on.\nOnly applicable to deferral requests."
                                },
                                "expiresOn": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "Indicates the timestamp when this request expires.\nCannot be used with expires_when_fixed.\nMust be a future timestamp.",
                                  "format": "date-time"
                                },
                                "expiryType": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "ExpiryType indicates the type of expiry for the request.\nThis field is under development, DO NOT USE FOR NON-DEVELOPMENT PURPOSES.\n\n - TIME: Request has a fixed expiry time. If used, expires_on must be set.\n - ALL_CVE_FIXABLE: Request expires if all CVEs in the request are fixable.\n - ANY_CVE_FIXABLE: Request expires if any CVE in the request is fixable.",
                                  "default": "TIME",
                                  "enum": [
                                    "TIME",
                                    "ALL_CVE_FIXABLE",
                                    "ANY_CVE_FIXABLE"
                                  ]
                                }
                              },
                              "description": "RequestExpiry defines the expiration configuration for deferral requests.\n\n**Expiry Rules:**\n- Deferral requests must specify expiry (either expires_when_fixed or expires_on)\n- False-positive requests do not have expiry (permanent)\n- Cannot specify both expiry options\n- Expiry type is under development (do not use for non-development purposes)"
                            }
                          },
                          "description": "DeferralRequest represents a request to temporarily defer vulnerability detection.\n\n**Deferral Rules:**\n- Must specify expiry configuration\n- Expiry can be time-based or fix-based\n- Deferrals are temporary and expire automatically"
                        },
                        "deferralUpdate": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "CVEs": {
                              "type": "array",
                              "description": "CVEs to be updated in the deferral request.\nCannot be empty (at least one CVE must remain).",
                              "items": {
                                "nullable": true,
                                "type": "string"
                              }
                            },
                            "expiry": {
                              "nullable": true,
                              "type": "object",
                              "properties": {
                                "expiresWhenFixed": {
                                  "type": "boolean",
                                  "description": "Indicates that this request expires when the associated vulnerability is fixed.\nCannot be used with expires_on.\nOnly applicable to deferral requests."
                                },
                                "expiresOn": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "Indicates the timestamp when this request expires.\nCannot be used with expires_when_fixed.\nMust be a future timestamp.",
                                  "format": "date-time"
                                },
                                "expiryType": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "ExpiryType indicates the type of expiry for the request.\nThis field is under development, DO NOT USE FOR NON-DEVELOPMENT PURPOSES.\n\n - TIME: Request has a fixed expiry time. If used, expires_on must be set.\n - ALL_CVE_FIXABLE: Request expires if all CVEs in the request are fixable.\n - ANY_CVE_FIXABLE: Request expires if any CVE in the request is fixable.",
                                  "default": "TIME",
                                  "enum": [
                                    "TIME",
                                    "ALL_CVE_FIXABLE",
                                    "ANY_CVE_FIXABLE"
                                  ]
                                }
                              },
                              "description": "RequestExpiry defines the expiration configuration for deferral requests.\n\n**Expiry Rules:**\n- Deferral requests must specify expiry (either expires_when_fixed or expires_on)\n- False-positive requests do not have expiry (permanent)\n- Cannot specify both expiry options\n- Expiry type is under development (do not use for non-development purposes)"
                            }
                          },
                          "description": "DeferralUpdate represents an update to an existing deferral request.\n\n**Update Rules:**\n- Can add or remove CVEs from the request\n- Cannot remove all CVEs (at least one CVE must remain)\n- Can update expiry configuration\n- Creates a new pending update request"
                        },
                        "falsePositiveUpdate": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "CVEs": {
                              "type": "array",
                              "description": "CVEs to be updated in the false-positive request.\nCannot be empty (at least one CVE must remain).",
                              "items": {
                                "nullable": true,
                                "type": "string"
                              }
                            }
                          },
                          "description": "FalsePositiveUpdate represents an update to an existing false-positive request.\n\n**Update Rules:**\n- Can add or remove CVEs from the request\n- Cannot remove all CVEs (at least one CVE must remain)\n- False-positive requests remain permanent (no expiry)"
                        }
                      },
                      "description": "VulnerabilityRequest encapsulates a request such as deferral request and false-positive request.\n\n**Request Lifecycle:**\n- Creation: New request in PENDING state\n- Approval: Request approved and enforced\n- Denial: Request denied and closed\n- Update: Approved request with pending update\n- Expiry: Request expires automatically or manually\n- Undo: Approved request undone and vulnerabilities re-enabled\n\n**Validation Rules:**\n- New requests must not have ID (auto-generated)\n- Must have at least one comment\n- Must have valid CVE format (e.g., \"CVE-2021-1234\")\n- Must have valid scope (image scope or global scope)\n- Cannot create duplicate requests for same CVE-scope combination\n- Deferral requests must specify expiry\n- False-positive requests are permanent (no expiry)\n- New requests cannot start in APPROVED or DENIED state\n\n**Performance Considerations:**\n- Maximum 1000 requests returned per list operation\n- Requests are processed sequentially to prevent race conditions\n- Duplicate prevention checks are performed during creation"
                    }
                  },
                  "description": "DeferVulnResponse contains the created deferral request information."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "application/json": {
                "schema": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "nullable": true,
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "@type": {
                            "nullable": true,
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com. As of May 2023, there are no widely used type server\nimplementations and no plans to implement one.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          }
                        },
                        "additionalProperties": {
                          "nullable": true,
                          "type": "object"
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n    // or ...\n    if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n      foo = any.unpack(Foo.getDefaultInstance());\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "x-codegen-request-body-name": "body"
      }
    },
    "/v1/cve/requests/false-positive": {
      "post": {
        "tags": [
          "VulnerabilityRequestService"
        ],
        "summary": "FalsePositiveVulnerability starts the process to mark the specified vulnerability as false-positive.",
        "description": "**False-Positive Request Rules:**\n- CVE must be in valid format (e.g., \"CVE-2021-1234\")\n- Scope must be valid (image scope or global scope)\n- Comment is required for request creation\n- Cannot create request for CVEs already covered by approved requests\n- Only one request can exist per CVE-scope combination\n- False-positive requests do not have expiry (permanent)\n\n**Error Cases:**\n- 400: Invalid CVE format, missing comment, or invalid scope\n- 403: Insufficient permissions to create requests\n- 409: CVE already covered by existing approved request\n- 410: Service deprecated (when UnifiedCVEDeferral feature is enabled)",
        "operationId": "VulnerabilityRequestService_FalsePositiveVulnerability",
        "requestBody": {
          "description": "FalsePositiveVulnRequest contains parameters for creating a false-positive request.\n\n**False-Positive Request Rules:**\n- CVE must be in valid format (e.g., \"CVE-2021-1234\")\n- Scope must be valid (image scope or global scope)\n- Comment is required for request creation\n- Cannot create request for CVEs already covered by approved requests\n- Only one request can exist per CVE-scope combination\n- False-positive requests do not have expiry (permanent)",
          "content": {
            "application/json": {
              "schema": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "cve": {
                    "nullable": true,
                    "type": "string",
                    "description": "CVE identifier to be marked as false-positive (e.g., \"CVE-2021-1234\").\nMust be in valid CVE format and not already covered by approved requests."
                  },
                  "scope": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "imageScope": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "registry": {
                            "nullable": true,
                            "type": "string",
                            "description": "Container registry (e.g., \"docker.io\", \"gcr.io\").\nRequired for image scope."
                          },
                          "remote": {
                            "nullable": true,
                            "type": "string",
                            "description": "Image repository name (e.g., \"stackrox/main\").\nRequired for image scope."
                          },
                          "tag": {
                            "nullable": true,
                            "type": "string",
                            "description": "Image tag (e.g., \"latest\", \"v1.0.0\").\nRequired for image scope."
                          }
                        },
                        "description": "Image scope applies the request to specific container images."
                      },
                      "globalScope": {
                        "nullable": true,
                        "type": "object",
                        "description": "Global scope applies the request system-wide (deprecated)."
                      }
                    },
                    "description": "Scope defines the scope where the vulnerability request applies."
                  },
                  "comment": {
                    "nullable": true,
                    "type": "string",
                    "description": "Comment explaining why the CVE is considered false-positive.\nRequired for request creation."
                  }
                },
                "description": "FalsePositiveVulnRequest contains parameters for creating a false-positive request.\n\n**False-Positive Request Rules:**\n- CVE must be in valid format (e.g., \"CVE-2021-1234\")\n- Scope must be valid (image scope or global scope)\n- Comment is required for request creation\n- Cannot create request for CVEs already covered by approved requests\n- Only one request can exist per CVE-scope combination\n- False-positive requests do not have expiry (permanent)"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "requestInfo": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "id": {
                          "nullable": true,
                          "type": "string",
                          "description": "Unique identifier for the vulnerability request (auto-generated).\nNew requests must not specify this field."
                        },
                        "name": {
                          "nullable": true,
                          "type": "string",
                          "description": "Human-readable name for the request (auto-generated).\nMust be unique across all requests."
                        },
                        "targetState": {
                          "nullable": true,
                          "type": "string",
                          "description": "VulnerabilityState indicates if vulnerability is being observed or deferred(/suppressed). By default, it vulnerabilities are observed.\n\n - OBSERVED: [Default state]",
                          "default": "OBSERVED",
                          "enum": [
                            "OBSERVED",
                            "DEFERRED",
                            "FALSE_POSITIVE"
                          ]
                        },
                        "status": {
                          "nullable": true,
                          "type": "string",
                          "description": "RequestStatus indicates the status of a vulnerability request.\n\n**Status Lifecycle:**\n- PENDING: Default state for new requests awaiting approval/denial\n- APPROVED: Request approved and enforced\n- DENIED: Request denied and permanently closed\n- APPROVED_PENDING_UPDATE: Approved request with pending update\n\n**Status Rules:**\n- New requests must start in PENDING state\n- Only PENDING requests can be approved or denied\n- APPROVED requests can be updated (creates APPROVED_PENDING_UPDATE)\n- DENIED requests are permanently closed\n- Cancelled requests are not persisted (except in audit logs)\n\n - PENDING: Default request state. It indicates that the request has not been fulfilled and that an action (approve/deny) is required.\nOnly requests in this state can be approved, denied, or updated.\n - APPROVED: Indicates that the request has been approved by the approver.\nApproved requests are immediately enforced and suppress vulnerability detection.\nOnly PENDING requests can transition to this state.\n - DENIED: Indicates that the request has been denied by the approver.\nDenied requests are permanently closed and have no impact on vulnerability detection.\nOnly PENDING requests can transition to this state.\n - APPROVED_PENDING_UPDATE: Indicates that the original request was approved, but an update is still pending an approval or denial.\nThis state occurs when an approved request is updated.\nThe original approval remains in effect until the update is processed.",
                          "default": "PENDING",
                          "enum": [
                            "PENDING",
                            "APPROVED",
                            "DENIED",
                            "APPROVED_PENDING_UPDATE"
                          ]
                        },
                        "expired": {
                          "type": "boolean",
                          "description": "Indicates if this request is a historical request that is no longer in effect\ndue to deferral expiry, cancellation, or restarting cve observation.\nExpired requests are retained for audit purposes."
                        },
                        "requestor": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "id": {
                              "nullable": true,
                              "type": "string"
                            },
                            "name": {
                              "nullable": true,
                              "type": "string"
                            }
                          }
                        },
                        "approvers": {
                          "type": "array",
                          "description": "DEPRECATED: Use approvers_v2 instead.\nUsers who can approve or deny the request.",
                          "items": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "id": {
                                "nullable": true,
                                "type": "string"
                              },
                              "name": {
                                "nullable": true,
                                "type": "string"
                              }
                            }
                          }
                        },
                        "createdAt": {
                          "nullable": true,
                          "type": "string",
                          "description": "Timestamp when the request was created.",
                          "format": "date-time"
                        },
                        "lastUpdated": {
                          "nullable": true,
                          "type": "string",
                          "description": "Timestamp when the request was last updated.",
                          "format": "date-time"
                        },
                        "comments": {
                          "type": "array",
                          "description": "Comments on the request providing audit trail.\nMust have at least one comment for new requests.",
                          "items": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "id": {
                                "nullable": true,
                                "type": "string",
                                "description": "Unique identifier for the comment."
                              },
                              "message": {
                                "nullable": true,
                                "type": "string",
                                "description": "The comment message content.\nRequired for all request actions."
                              },
                              "user": {
                                "nullable": true,
                                "type": "object",
                                "properties": {
                                  "id": {
                                    "nullable": true,
                                    "type": "string"
                                  },
                                  "name": {
                                    "nullable": true,
                                    "type": "string"
                                  }
                                }
                              },
                              "createdAt": {
                                "nullable": true,
                                "type": "string",
                                "description": "Timestamp when the comment was created.",
                                "format": "date-time"
                              }
                            },
                            "description": "RequestComment represents a comment on a vulnerability request.\n\n**Comment Rules:**\n- Comments are required for all request actions (create, approve, deny, update)\n- Each comment is associated with a user and timestamp\n- Comments provide audit trail for request lifecycle"
                          }
                        },
                        "scope": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "imageScope": {
                              "nullable": true,
                              "type": "object",
                              "properties": {
                                "registry": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "Container registry (e.g., \"docker.io\", \"gcr.io\").\nRequired for image scope."
                                },
                                "remote": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "Image repository name (e.g., \"stackrox/main\").\nRequired for image scope."
                                },
                                "tag": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "Image tag (e.g., \"latest\", \"v1.0.0\").\nRequired for image scope."
                                }
                              },
                              "description": "Image scope applies the request to specific container images."
                            },
                            "globalScope": {
                              "nullable": true,
                              "type": "object",
                              "description": "Global scope applies the request system-wide (deprecated)."
                            }
                          },
                          "description": "Scope defines the scope where the vulnerability request applies."
                        },
                        "requesterV2": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "id": {
                              "nullable": true,
                              "type": "string",
                              "description": "Unique identifier for the requester."
                            },
                            "name": {
                              "nullable": true,
                              "type": "string",
                              "description": "Display name of the requester."
                            }
                          },
                          "description": "Requester represents the user who created the vulnerability request.\n\n**Requester Rules:**\n- Must be specified for all new requests\n- Cannot be changed after request creation\n- Used for audit trail and permission checks"
                        },
                        "approversV2": {
                          "type": "array",
                          "description": "Users who can approve or deny the request (v2).\nMultiple approvers can be assigned.",
                          "items": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "id": {
                                "nullable": true,
                                "type": "string",
                                "description": "Unique identifier for the approver."
                              },
                              "name": {
                                "nullable": true,
                                "type": "string",
                                "description": "Display name of the approver."
                              }
                            },
                            "description": "Approver represents a user who can approve or deny vulnerability requests.\n\n**Approver Rules:**\n- Multiple approvers can be assigned to a request\n- Any approver can approve or deny the request\n- Used for audit trail and permission checks"
                          }
                        },
                        "deferralReq": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "expiry": {
                              "nullable": true,
                              "type": "object",
                              "properties": {
                                "expiresWhenFixed": {
                                  "type": "boolean",
                                  "description": "Indicates that this request expires when the associated vulnerability is fixed.\nCannot be used with expires_on.\nOnly applicable to deferral requests."
                                },
                                "expiresOn": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "Indicates the timestamp when this request expires.\nCannot be used with expires_when_fixed.\nMust be a future timestamp.",
                                  "format": "date-time"
                                },
                                "expiryType": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "ExpiryType indicates the type of expiry for the request.\nThis field is under development, DO NOT USE FOR NON-DEVELOPMENT PURPOSES.\n\n - TIME: Request has a fixed expiry time. If used, expires_on must be set.\n - ALL_CVE_FIXABLE: Request expires if all CVEs in the request are fixable.\n - ANY_CVE_FIXABLE: Request expires if any CVE in the request is fixable.",
                                  "default": "TIME",
                                  "enum": [
                                    "TIME",
                                    "ALL_CVE_FIXABLE",
                                    "ANY_CVE_FIXABLE"
                                  ]
                                }
                              },
                              "description": "RequestExpiry defines the expiration configuration for deferral requests.\n\n**Expiry Rules:**\n- Deferral requests must specify expiry (either expires_when_fixed or expires_on)\n- False-positive requests do not have expiry (permanent)\n- Cannot specify both expiry options\n- Expiry type is under development (do not use for non-development purposes)"
                            }
                          },
                          "description": "DeferralRequest represents a request to temporarily defer vulnerability detection.\n\n**Deferral Rules:**\n- Must specify expiry configuration\n- Expiry can be time-based or fix-based\n- Deferrals are temporary and expire automatically"
                        },
                        "fpRequest": {
                          "nullable": true,
                          "type": "object",
                          "description": "FalsePositiveRequest represents a request to permanently mark vulnerabilities as false-positive.\n\n**False-Positive Rules:**\n- No expiry configuration (permanent)\n- False-positives are permanently suppressed\n- Cannot be undone except through request management"
                        },
                        "cves": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "cves": {
                              "type": "array",
                              "description": "These are (NVD) vulnerability identifiers, `cve` field of `storage.CVE`, and *not* the `id` field.\nFor example, CVE-2021-44832.\nMust be in valid CVE format and not already covered by approved requests.",
                              "items": {
                                "nullable": true,
                                "type": "string"
                              }
                            }
                          },
                          "description": "CVEs represents the list of CVE identifiers in the request."
                        },
                        "updatedDeferralReq": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "expiry": {
                              "nullable": true,
                              "type": "object",
                              "properties": {
                                "expiresWhenFixed": {
                                  "type": "boolean",
                                  "description": "Indicates that this request expires when the associated vulnerability is fixed.\nCannot be used with expires_on.\nOnly applicable to deferral requests."
                                },
                                "expiresOn": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "Indicates the timestamp when this request expires.\nCannot be used with expires_when_fixed.\nMust be a future timestamp.",
                                  "format": "date-time"
                                },
                                "expiryType": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "ExpiryType indicates the type of expiry for the request.\nThis field is under development, DO NOT USE FOR NON-DEVELOPMENT PURPOSES.\n\n - TIME: Request has a fixed expiry time. If used, expires_on must be set.\n - ALL_CVE_FIXABLE: Request expires if all CVEs in the request are fixable.\n - ANY_CVE_FIXABLE: Request expires if any CVE in the request is fixable.",
                                  "default": "TIME",
                                  "enum": [
                                    "TIME",
                                    "ALL_CVE_FIXABLE",
                                    "ANY_CVE_FIXABLE"
                                  ]
                                }
                              },
                              "description": "RequestExpiry defines the expiration configuration for deferral requests.\n\n**Expiry Rules:**\n- Deferral requests must specify expiry (either expires_when_fixed or expires_on)\n- False-positive requests do not have expiry (permanent)\n- Cannot specify both expiry options\n- Expiry type is under development (do not use for non-development purposes)"
                            }
                          },
                          "description": "DeferralRequest represents a request to temporarily defer vulnerability detection.\n\n**Deferral Rules:**\n- Must specify expiry configuration\n- Expiry can be time-based or fix-based\n- Deferrals are temporary and expire automatically"
                        },
                        "deferralUpdate": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "CVEs": {
                              "type": "array",
                              "description": "CVEs to be updated in the deferral request.\nCannot be empty (at least one CVE must remain).",
                              "items": {
                                "nullable": true,
                                "type": "string"
                              }
                            },
                            "expiry": {
                              "nullable": true,
                              "type": "object",
                              "properties": {
                                "expiresWhenFixed": {
                                  "type": "boolean",
                                  "description": "Indicates that this request expires when the associated vulnerability is fixed.\nCannot be used with expires_on.\nOnly applicable to deferral requests."
                                },
                                "expiresOn": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "Indicates the timestamp when this request expires.\nCannot be used with expires_when_fixed.\nMust be a future timestamp.",
                                  "format": "date-time"
                                },
                                "expiryType": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "ExpiryType indicates the type of expiry for the request.\nThis field is under development, DO NOT USE FOR NON-DEVELOPMENT PURPOSES.\n\n - TIME: Request has a fixed expiry time. If used, expires_on must be set.\n - ALL_CVE_FIXABLE: Request expires if all CVEs in the request are fixable.\n - ANY_CVE_FIXABLE: Request expires if any CVE in the request is fixable.",
                                  "default": "TIME",
                                  "enum": [
                                    "TIME",
                                    "ALL_CVE_FIXABLE",
                                    "ANY_CVE_FIXABLE"
                                  ]
                                }
                              },
                              "description": "RequestExpiry defines the expiration configuration for deferral requests.\n\n**Expiry Rules:**\n- Deferral requests must specify expiry (either expires_when_fixed or expires_on)\n- False-positive requests do not have expiry (permanent)\n- Cannot specify both expiry options\n- Expiry type is under development (do not use for non-development purposes)"
                            }
                          },
                          "description": "DeferralUpdate represents an update to an existing deferral request.\n\n**Update Rules:**\n- Can add or remove CVEs from the request\n- Cannot remove all CVEs (at least one CVE must remain)\n- Can update expiry configuration\n- Creates a new pending update request"
                        },
                        "falsePositiveUpdate": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "CVEs": {
                              "type": "array",
                              "description": "CVEs to be updated in the false-positive request.\nCannot be empty (at least one CVE must remain).",
                              "items": {
                                "nullable": true,
                                "type": "string"
                              }
                            }
                          },
                          "description": "FalsePositiveUpdate represents an update to an existing false-positive request.\n\n**Update Rules:**\n- Can add or remove CVEs from the request\n- Cannot remove all CVEs (at least one CVE must remain)\n- False-positive requests remain permanent (no expiry)"
                        }
                      },
                      "description": "VulnerabilityRequest encapsulates a request such as deferral request and false-positive request.\n\n**Request Lifecycle:**\n- Creation: New request in PENDING state\n- Approval: Request approved and enforced\n- Denial: Request denied and closed\n- Update: Approved request with pending update\n- Expiry: Request expires automatically or manually\n- Undo: Approved request undone and vulnerabilities re-enabled\n\n**Validation Rules:**\n- New requests must not have ID (auto-generated)\n- Must have at least one comment\n- Must have valid CVE format (e.g., \"CVE-2021-1234\")\n- Must have valid scope (image scope or global scope)\n- Cannot create duplicate requests for same CVE-scope combination\n- Deferral requests must specify expiry\n- False-positive requests are permanent (no expiry)\n- New requests cannot start in APPROVED or DENIED state\n\n**Performance Considerations:**\n- Maximum 1000 requests returned per list operation\n- Requests are processed sequentially to prevent race conditions\n- Duplicate prevention checks are performed during creation"
                    }
                  },
                  "description": "FalsePositiveVulnResponse contains the created false-positive request information."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "application/json": {
                "schema": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "nullable": true,
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "@type": {
                            "nullable": true,
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com. As of May 2023, there are no widely used type server\nimplementations and no plans to implement one.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          }
                        },
                        "additionalProperties": {
                          "nullable": true,
                          "type": "object"
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n    // or ...\n    if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n      foo = any.unpack(Foo.getDefaultInstance());\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "x-codegen-request-body-name": "body"
      }
    },
    "/v1/cve/requests/{id}": {
      "get": {
        "tags": [
          "VulnerabilityRequestService"
        ],
        "summary": "GetVulnerabilityRequest returns the requested vulnerability request by ID.",
        "description": "**Error Cases:**\n- 404: Request with specified ID does not exist\n- 403: Insufficient permissions to view the request\n- 410: Service deprecated (when UnifiedCVEDeferral feature is enabled)",
        "operationId": "VulnerabilityRequestService_GetVulnerabilityRequest",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "nullable": true,
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "requestInfo": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "id": {
                          "nullable": true,
                          "type": "string",
                          "description": "Unique identifier for the vulnerability request (auto-generated).\nNew requests must not specify this field."
                        },
                        "name": {
                          "nullable": true,
                          "type": "string",
                          "description": "Human-readable name for the request (auto-generated).\nMust be unique across all requests."
                        },
                        "targetState": {
                          "nullable": true,
                          "type": "string",
                          "description": "VulnerabilityState indicates if vulnerability is being observed or deferred(/suppressed). By default, it vulnerabilities are observed.\n\n - OBSERVED: [Default state]",
                          "default": "OBSERVED",
                          "enum": [
                            "OBSERVED",
                            "DEFERRED",
                            "FALSE_POSITIVE"
                          ]
                        },
                        "status": {
                          "nullable": true,
                          "type": "string",
                          "description": "RequestStatus indicates the status of a vulnerability request.\n\n**Status Lifecycle:**\n- PENDING: Default state for new requests awaiting approval/denial\n- APPROVED: Request approved and enforced\n- DENIED: Request denied and permanently closed\n- APPROVED_PENDING_UPDATE: Approved request with pending update\n\n**Status Rules:**\n- New requests must start in PENDING state\n- Only PENDING requests can be approved or denied\n- APPROVED requests can be updated (creates APPROVED_PENDING_UPDATE)\n- DENIED requests are permanently closed\n- Cancelled requests are not persisted (except in audit logs)\n\n - PENDING: Default request state. It indicates that the request has not been fulfilled and that an action (approve/deny) is required.\nOnly requests in this state can be approved, denied, or updated.\n - APPROVED: Indicates that the request has been approved by the approver.\nApproved requests are immediately enforced and suppress vulnerability detection.\nOnly PENDING requests can transition to this state.\n - DENIED: Indicates that the request has been denied by the approver.\nDenied requests are permanently closed and have no impact on vulnerability detection.\nOnly PENDING requests can transition to this state.\n - APPROVED_PENDING_UPDATE: Indicates that the original request was approved, but an update is still pending an approval or denial.\nThis state occurs when an approved request is updated.\nThe original approval remains in effect until the update is processed.",
                          "default": "PENDING",
                          "enum": [
                            "PENDING",
                            "APPROVED",
                            "DENIED",
                            "APPROVED_PENDING_UPDATE"
                          ]
                        },
                        "expired": {
                          "type": "boolean",
                          "description": "Indicates if this request is a historical request that is no longer in effect\ndue to deferral expiry, cancellation, or restarting cve observation.\nExpired requests are retained for audit purposes."
                        },
                        "requestor": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "id": {
                              "nullable": true,
                              "type": "string"
                            },
                            "name": {
                              "nullable": true,
                              "type": "string"
                            }
                          }
                        },
                        "approvers": {
                          "type": "array",
                          "description": "DEPRECATED: Use approvers_v2 instead.\nUsers who can approve or deny the request.",
                          "items": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "id": {
                                "nullable": true,
                                "type": "string"
                              },
                              "name": {
                                "nullable": true,
                                "type": "string"
                              }
                            }
                          }
                        },
                        "createdAt": {
                          "nullable": true,
                          "type": "string",
                          "description": "Timestamp when the request was created.",
                          "format": "date-time"
                        },
                        "lastUpdated": {
                          "nullable": true,
                          "type": "string",
                          "description": "Timestamp when the request was last updated.",
                          "format": "date-time"
                        },
                        "comments": {
                          "type": "array",
                          "description": "Comments on the request providing audit trail.\nMust have at least one comment for new requests.",
                          "items": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "id": {
                                "nullable": true,
                                "type": "string",
                                "description": "Unique identifier for the comment."
                              },
                              "message": {
                                "nullable": true,
                                "type": "string",
                                "description": "The comment message content.\nRequired for all request actions."
                              },
                              "user": {
                                "nullable": true,
                                "type": "object",
                                "properties": {
                                  "id": {
                                    "nullable": true,
                                    "type": "string"
                                  },
                                  "name": {
                                    "nullable": true,
                                    "type": "string"
                                  }
                                }
                              },
                              "createdAt": {
                                "nullable": true,
                                "type": "string",
                                "description": "Timestamp when the comment was created.",
                                "format": "date-time"
                              }
                            },
                            "description": "RequestComment represents a comment on a vulnerability request.\n\n**Comment Rules:**\n- Comments are required for all request actions (create, approve, deny, update)\n- Each comment is associated with a user and timestamp\n- Comments provide audit trail for request lifecycle"
                          }
                        },
                        "scope": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "imageScope": {
                              "nullable": true,
                              "type": "object",
                              "properties": {
                                "registry": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "Container registry (e.g., \"docker.io\", \"gcr.io\").\nRequired for image scope."
                                },
                                "remote": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "Image repository name (e.g., \"stackrox/main\").\nRequired for image scope."
                                },
                                "tag": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "Image tag (e.g., \"latest\", \"v1.0.0\").\nRequired for image scope."
                                }
                              },
                              "description": "Image scope applies the request to specific container images."
                            },
                            "globalScope": {
                              "nullable": true,
                              "type": "object",
                              "description": "Global scope applies the request system-wide (deprecated)."
                            }
                          },
                          "description": "Scope defines the scope where the vulnerability request applies."
                        },
                        "requesterV2": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "id": {
                              "nullable": true,
                              "type": "string",
                              "description": "Unique identifier for the requester."
                            },
                            "name": {
                              "nullable": true,
                              "type": "string",
                              "description": "Display name of the requester."
                            }
                          },
                          "description": "Requester represents the user who created the vulnerability request.\n\n**Requester Rules:**\n- Must be specified for all new requests\n- Cannot be changed after request creation\n- Used for audit trail and permission checks"
                        },
                        "approversV2": {
                          "type": "array",
                          "description": "Users who can approve or deny the request (v2).\nMultiple approvers can be assigned.",
                          "items": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "id": {
                                "nullable": true,
                                "type": "string",
                                "description": "Unique identifier for the approver."
                              },
                              "name": {
                                "nullable": true,
                                "type": "string",
                                "description": "Display name of the approver."
                              }
                            },
                            "description": "Approver represents a user who can approve or deny vulnerability requests.\n\n**Approver Rules:**\n- Multiple approvers can be assigned to a request\n- Any approver can approve or deny the request\n- Used for audit trail and permission checks"
                          }
                        },
                        "deferralReq": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "expiry": {
                              "nullable": true,
                              "type": "object",
                              "properties": {
                                "expiresWhenFixed": {
                                  "type": "boolean",
                                  "description": "Indicates that this request expires when the associated vulnerability is fixed.\nCannot be used with expires_on.\nOnly applicable to deferral requests."
                                },
                                "expiresOn": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "Indicates the timestamp when this request expires.\nCannot be used with expires_when_fixed.\nMust be a future timestamp.",
                                  "format": "date-time"
                                },
                                "expiryType": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "ExpiryType indicates the type of expiry for the request.\nThis field is under development, DO NOT USE FOR NON-DEVELOPMENT PURPOSES.\n\n - TIME: Request has a fixed expiry time. If used, expires_on must be set.\n - ALL_CVE_FIXABLE: Request expires if all CVEs in the request are fixable.\n - ANY_CVE_FIXABLE: Request expires if any CVE in the request is fixable.",
                                  "default": "TIME",
                                  "enum": [
                                    "TIME",
                                    "ALL_CVE_FIXABLE",
                                    "ANY_CVE_FIXABLE"
                                  ]
                                }
                              },
                              "description": "RequestExpiry defines the expiration configuration for deferral requests.\n\n**Expiry Rules:**\n- Deferral requests must specify expiry (either expires_when_fixed or expires_on)\n- False-positive requests do not have expiry (permanent)\n- Cannot specify both expiry options\n- Expiry type is under development (do not use for non-development purposes)"
                            }
                          },
                          "description": "DeferralRequest represents a request to temporarily defer vulnerability detection.\n\n**Deferral Rules:**\n- Must specify expiry configuration\n- Expiry can be time-based or fix-based\n- Deferrals are temporary and expire automatically"
                        },
                        "fpRequest": {
                          "nullable": true,
                          "type": "object",
                          "description": "FalsePositiveRequest represents a request to permanently mark vulnerabilities as false-positive.\n\n**False-Positive Rules:**\n- No expiry configuration (permanent)\n- False-positives are permanently suppressed\n- Cannot be undone except through request management"
                        },
                        "cves": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "cves": {
                              "type": "array",
                              "description": "These are (NVD) vulnerability identifiers, `cve` field of `storage.CVE`, and *not* the `id` field.\nFor example, CVE-2021-44832.\nMust be in valid CVE format and not already covered by approved requests.",
                              "items": {
                                "nullable": true,
                                "type": "string"
                              }
                            }
                          },
                          "description": "CVEs represents the list of CVE identifiers in the request."
                        },
                        "updatedDeferralReq": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "expiry": {
                              "nullable": true,
                              "type": "object",
                              "properties": {
                                "expiresWhenFixed": {
                                  "type": "boolean",
                                  "description": "Indicates that this request expires when the associated vulnerability is fixed.\nCannot be used with expires_on.\nOnly applicable to deferral requests."
                                },
                                "expiresOn": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "Indicates the timestamp when this request expires.\nCannot be used with expires_when_fixed.\nMust be a future timestamp.",
                                  "format": "date-time"
                                },
                                "expiryType": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "ExpiryType indicates the type of expiry for the request.\nThis field is under development, DO NOT USE FOR NON-DEVELOPMENT PURPOSES.\n\n - TIME: Request has a fixed expiry time. If used, expires_on must be set.\n - ALL_CVE_FIXABLE: Request expires if all CVEs in the request are fixable.\n - ANY_CVE_FIXABLE: Request expires if any CVE in the request is fixable.",
                                  "default": "TIME",
                                  "enum": [
                                    "TIME",
                                    "ALL_CVE_FIXABLE",
                                    "ANY_CVE_FIXABLE"
                                  ]
                                }
                              },
                              "description": "RequestExpiry defines the expiration configuration for deferral requests.\n\n**Expiry Rules:**\n- Deferral requests must specify expiry (either expires_when_fixed or expires_on)\n- False-positive requests do not have expiry (permanent)\n- Cannot specify both expiry options\n- Expiry type is under development (do not use for non-development purposes)"
                            }
                          },
                          "description": "DeferralRequest represents a request to temporarily defer vulnerability detection.\n\n**Deferral Rules:**\n- Must specify expiry configuration\n- Expiry can be time-based or fix-based\n- Deferrals are temporary and expire automatically"
                        },
                        "deferralUpdate": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "CVEs": {
                              "type": "array",
                              "description": "CVEs to be updated in the deferral request.\nCannot be empty (at least one CVE must remain).",
                              "items": {
                                "nullable": true,
                                "type": "string"
                              }
                            },
                            "expiry": {
                              "nullable": true,
                              "type": "object",
                              "properties": {
                                "expiresWhenFixed": {
                                  "type": "boolean",
                                  "description": "Indicates that this request expires when the associated vulnerability is fixed.\nCannot be used with expires_on.\nOnly applicable to deferral requests."
                                },
                                "expiresOn": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "Indicates the timestamp when this request expires.\nCannot be used with expires_when_fixed.\nMust be a future timestamp.",
                                  "format": "date-time"
                                },
                                "expiryType": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "ExpiryType indicates the type of expiry for the request.\nThis field is under development, DO NOT USE FOR NON-DEVELOPMENT PURPOSES.\n\n - TIME: Request has a fixed expiry time. If used, expires_on must be set.\n - ALL_CVE_FIXABLE: Request expires if all CVEs in the request are fixable.\n - ANY_CVE_FIXABLE: Request expires if any CVE in the request is fixable.",
                                  "default": "TIME",
                                  "enum": [
                                    "TIME",
                                    "ALL_CVE_FIXABLE",
                                    "ANY_CVE_FIXABLE"
                                  ]
                                }
                              },
                              "description": "RequestExpiry defines the expiration configuration for deferral requests.\n\n**Expiry Rules:**\n- Deferral requests must specify expiry (either expires_when_fixed or expires_on)\n- False-positive requests do not have expiry (permanent)\n- Cannot specify both expiry options\n- Expiry type is under development (do not use for non-development purposes)"
                            }
                          },
                          "description": "DeferralUpdate represents an update to an existing deferral request.\n\n**Update Rules:**\n- Can add or remove CVEs from the request\n- Cannot remove all CVEs (at least one CVE must remain)\n- Can update expiry configuration\n- Creates a new pending update request"
                        },
                        "falsePositiveUpdate": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "CVEs": {
                              "type": "array",
                              "description": "CVEs to be updated in the false-positive request.\nCannot be empty (at least one CVE must remain).",
                              "items": {
                                "nullable": true,
                                "type": "string"
                              }
                            }
                          },
                          "description": "FalsePositiveUpdate represents an update to an existing false-positive request.\n\n**Update Rules:**\n- Can add or remove CVEs from the request\n- Cannot remove all CVEs (at least one CVE must remain)\n- False-positive requests remain permanent (no expiry)"
                        }
                      },
                      "description": "VulnerabilityRequest encapsulates a request such as deferral request and false-positive request.\n\n**Request Lifecycle:**\n- Creation: New request in PENDING state\n- Approval: Request approved and enforced\n- Denial: Request denied and closed\n- Update: Approved request with pending update\n- Expiry: Request expires automatically or manually\n- Undo: Approved request undone and vulnerabilities re-enabled\n\n**Validation Rules:**\n- New requests must not have ID (auto-generated)\n- Must have at least one comment\n- Must have valid CVE format (e.g., \"CVE-2021-1234\")\n- Must have valid scope (image scope or global scope)\n- Cannot create duplicate requests for same CVE-scope combination\n- Deferral requests must specify expiry\n- False-positive requests are permanent (no expiry)\n- New requests cannot start in APPROVED or DENIED state\n\n**Performance Considerations:**\n- Maximum 1000 requests returned per list operation\n- Requests are processed sequentially to prevent race conditions\n- Duplicate prevention checks are performed during creation"
                    }
                  },
                  "description": "GetVulnerabilityRequestResponse contains the vulnerability request details."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "application/json": {
                "schema": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "nullable": true,
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "@type": {
                            "nullable": true,
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com. As of May 2023, there are no widely used type server\nimplementations and no plans to implement one.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          }
                        },
                        "additionalProperties": {
                          "nullable": true,
                          "type": "object"
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n    // or ...\n    if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n      foo = any.unpack(Foo.getDefaultInstance());\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "VulnerabilityRequestService"
        ],
        "summary": "DeleteVulnerabilityRequest deletes a vulnerability request.",
        "description": "**Delete Rules:**\n- Only pending requests can be deleted\n- Approved or denied requests cannot be deleted\n- Deletion is permanent and cannot be undone\n\n**Error Cases:**\n- 400: Request not in pending state\n- 403: Insufficient permissions to delete requests\n- 404: Request with specified ID does not exist\n- 410: Service deprecated (when UnifiedCVEDeferral feature is enabled)",
        "operationId": "VulnerabilityRequestService_DeleteVulnerabilityRequest",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "nullable": true,
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "nullable": true,
                  "type": "object"
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "application/json": {
                "schema": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "nullable": true,
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "@type": {
                            "nullable": true,
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com. As of May 2023, there are no widely used type server\nimplementations and no plans to implement one.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          }
                        },
                        "additionalProperties": {
                          "nullable": true,
                          "type": "object"
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n    // or ...\n    if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n      foo = any.unpack(Foo.getDefaultInstance());\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/v1/cve/requests/{id}/approve": {
      "post": {
        "tags": [
          "VulnerabilityRequestService"
        ],
        "summary": "ApproveVulnRequest approves a vulnerability request.",
        "description": "**Approval Behavior:**\n- Request is approved and immediately enforced\n- Vulnerabilities are suppressed in policy detection and risk evaluation\n- Conflicting pending requests are automatically denied\n- Comment is required for approval\n\n**Approval Rules:**\n- Only pending requests can be approved\n- Comment is required for approval\n- Approval automatically denies conflicting pending requests\n- Approved requests are enforced immediately\n\n**Error Cases:**\n- 400: Missing comment or request not in pending state\n- 403: Insufficient permissions to approve requests\n- 404: Request with specified ID does not exist\n- 410: Service deprecated (when UnifiedCVEDeferral feature is enabled)",
        "operationId": "VulnerabilityRequestService_ApproveVulnerabilityRequest",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of the vulnerability request to approve.",
            "required": true,
            "schema": {
              "nullable": true,
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "comment": {
                    "nullable": true,
                    "type": "string",
                    "description": "Comment explaining the approval decision.\nRequired for approval action."
                  }
                },
                "description": "ApproveVulnRequest contains parameters for approving a vulnerability request.\n\n**Approval Rules:**\n- Comment is required for approval\n- Only pending requests can be approved\n- Approval automatically denies conflicting pending requests\n- Approved requests are enforced immediately"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "requestInfo": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "id": {
                          "nullable": true,
                          "type": "string",
                          "description": "Unique identifier for the vulnerability request (auto-generated).\nNew requests must not specify this field."
                        },
                        "name": {
                          "nullable": true,
                          "type": "string",
                          "description": "Human-readable name for the request (auto-generated).\nMust be unique across all requests."
                        },
                        "targetState": {
                          "nullable": true,
                          "type": "string",
                          "description": "VulnerabilityState indicates if vulnerability is being observed or deferred(/suppressed). By default, it vulnerabilities are observed.\n\n - OBSERVED: [Default state]",
                          "default": "OBSERVED",
                          "enum": [
                            "OBSERVED",
                            "DEFERRED",
                            "FALSE_POSITIVE"
                          ]
                        },
                        "status": {
                          "nullable": true,
                          "type": "string",
                          "description": "RequestStatus indicates the status of a vulnerability request.\n\n**Status Lifecycle:**\n- PENDING: Default state for new requests awaiting approval/denial\n- APPROVED: Request approved and enforced\n- DENIED: Request denied and permanently closed\n- APPROVED_PENDING_UPDATE: Approved request with pending update\n\n**Status Rules:**\n- New requests must start in PENDING state\n- Only PENDING requests can be approved or denied\n- APPROVED requests can be updated (creates APPROVED_PENDING_UPDATE)\n- DENIED requests are permanently closed\n- Cancelled requests are not persisted (except in audit logs)\n\n - PENDING: Default request state. It indicates that the request has not been fulfilled and that an action (approve/deny) is required.\nOnly requests in this state can be approved, denied, or updated.\n - APPROVED: Indicates that the request has been approved by the approver.\nApproved requests are immediately enforced and suppress vulnerability detection.\nOnly PENDING requests can transition to this state.\n - DENIED: Indicates that the request has been denied by the approver.\nDenied requests are permanently closed and have no impact on vulnerability detection.\nOnly PENDING requests can transition to this state.\n - APPROVED_PENDING_UPDATE: Indicates that the original request was approved, but an update is still pending an approval or denial.\nThis state occurs when an approved request is updated.\nThe original approval remains in effect until the update is processed.",
                          "default": "PENDING",
                          "enum": [
                            "PENDING",
                            "APPROVED",
                            "DENIED",
                            "APPROVED_PENDING_UPDATE"
                          ]
                        },
                        "expired": {
                          "type": "boolean",
                          "description": "Indicates if this request is a historical request that is no longer in effect\ndue to deferral expiry, cancellation, or restarting cve observation.\nExpired requests are retained for audit purposes."
                        },
                        "requestor": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "id": {
                              "nullable": true,
                              "type": "string"
                            },
                            "name": {
                              "nullable": true,
                              "type": "string"
                            }
                          }
                        },
                        "approvers": {
                          "type": "array",
                          "description": "DEPRECATED: Use approvers_v2 instead.\nUsers who can approve or deny the request.",
                          "items": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "id": {
                                "nullable": true,
                                "type": "string"
                              },
                              "name": {
                                "nullable": true,
                                "type": "string"
                              }
                            }
                          }
                        },
                        "createdAt": {
                          "nullable": true,
                          "type": "string",
                          "description": "Timestamp when the request was created.",
                          "format": "date-time"
                        },
                        "lastUpdated": {
                          "nullable": true,
                          "type": "string",
                          "description": "Timestamp when the request was last updated.",
                          "format": "date-time"
                        },
                        "comments": {
                          "type": "array",
                          "description": "Comments on the request providing audit trail.\nMust have at least one comment for new requests.",
                          "items": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "id": {
                                "nullable": true,
                                "type": "string",
                                "description": "Unique identifier for the comment."
                              },
                              "message": {
                                "nullable": true,
                                "type": "string",
                                "description": "The comment message content.\nRequired for all request actions."
                              },
                              "user": {
                                "nullable": true,
                                "type": "object",
                                "properties": {
                                  "id": {
                                    "nullable": true,
                                    "type": "string"
                                  },
                                  "name": {
                                    "nullable": true,
                                    "type": "string"
                                  }
                                }
                              },
                              "createdAt": {
                                "nullable": true,
                                "type": "string",
                                "description": "Timestamp when the comment was created.",
                                "format": "date-time"
                              }
                            },
                            "description": "RequestComment represents a comment on a vulnerability request.\n\n**Comment Rules:**\n- Comments are required for all request actions (create, approve, deny, update)\n- Each comment is associated with a user and timestamp\n- Comments provide audit trail for request lifecycle"
                          }
                        },
                        "scope": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "imageScope": {
                              "nullable": true,
                              "type": "object",
                              "properties": {
                                "registry": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "Container registry (e.g., \"docker.io\", \"gcr.io\").\nRequired for image scope."
                                },
                                "remote": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "Image repository name (e.g., \"stackrox/main\").\nRequired for image scope."
                                },
                                "tag": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "Image tag (e.g., \"latest\", \"v1.0.0\").\nRequired for image scope."
                                }
                              },
                              "description": "Image scope applies the request to specific container images."
                            },
                            "globalScope": {
                              "nullable": true,
                              "type": "object",
                              "description": "Global scope applies the request system-wide (deprecated)."
                            }
                          },
                          "description": "Scope defines the scope where the vulnerability request applies."
                        },
                        "requesterV2": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "id": {
                              "nullable": true,
                              "type": "string",
                              "description": "Unique identifier for the requester."
                            },
                            "name": {
                              "nullable": true,
                              "type": "string",
                              "description": "Display name of the requester."
                            }
                          },
                          "description": "Requester represents the user who created the vulnerability request.\n\n**Requester Rules:**\n- Must be specified for all new requests\n- Cannot be changed after request creation\n- Used for audit trail and permission checks"
                        },
                        "approversV2": {
                          "type": "array",
                          "description": "Users who can approve or deny the request (v2).\nMultiple approvers can be assigned.",
                          "items": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "id": {
                                "nullable": true,
                                "type": "string",
                                "description": "Unique identifier for the approver."
                              },
                              "name": {
                                "nullable": true,
                                "type": "string",
                                "description": "Display name of the approver."
                              }
                            },
                            "description": "Approver represents a user who can approve or deny vulnerability requests.\n\n**Approver Rules:**\n- Multiple approvers can be assigned to a request\n- Any approver can approve or deny the request\n- Used for audit trail and permission checks"
                          }
                        },
                        "deferralReq": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "expiry": {
                              "nullable": true,
                              "type": "object",
                              "properties": {
                                "expiresWhenFixed": {
                                  "type": "boolean",
                                  "description": "Indicates that this request expires when the associated vulnerability is fixed.\nCannot be used with expires_on.\nOnly applicable to deferral requests."
                                },
                                "expiresOn": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "Indicates the timestamp when this request expires.\nCannot be used with expires_when_fixed.\nMust be a future timestamp.",
                                  "format": "date-time"
                                },
                                "expiryType": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "ExpiryType indicates the type of expiry for the request.\nThis field is under development, DO NOT USE FOR NON-DEVELOPMENT PURPOSES.\n\n - TIME: Request has a fixed expiry time. If used, expires_on must be set.\n - ALL_CVE_FIXABLE: Request expires if all CVEs in the request are fixable.\n - ANY_CVE_FIXABLE: Request expires if any CVE in the request is fixable.",
                                  "default": "TIME",
                                  "enum": [
                                    "TIME",
                                    "ALL_CVE_FIXABLE",
                                    "ANY_CVE_FIXABLE"
                                  ]
                                }
                              },
                              "description": "RequestExpiry defines the expiration configuration for deferral requests.\n\n**Expiry Rules:**\n- Deferral requests must specify expiry (either expires_when_fixed or expires_on)\n- False-positive requests do not have expiry (permanent)\n- Cannot specify both expiry options\n- Expiry type is under development (do not use for non-development purposes)"
                            }
                          },
                          "description": "DeferralRequest represents a request to temporarily defer vulnerability detection.\n\n**Deferral Rules:**\n- Must specify expiry configuration\n- Expiry can be time-based or fix-based\n- Deferrals are temporary and expire automatically"
                        },
                        "fpRequest": {
                          "nullable": true,
                          "type": "object",
                          "description": "FalsePositiveRequest represents a request to permanently mark vulnerabilities as false-positive.\n\n**False-Positive Rules:**\n- No expiry configuration (permanent)\n- False-positives are permanently suppressed\n- Cannot be undone except through request management"
                        },
                        "cves": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "cves": {
                              "type": "array",
                              "description": "These are (NVD) vulnerability identifiers, `cve` field of `storage.CVE`, and *not* the `id` field.\nFor example, CVE-2021-44832.\nMust be in valid CVE format and not already covered by approved requests.",
                              "items": {
                                "nullable": true,
                                "type": "string"
                              }
                            }
                          },
                          "description": "CVEs represents the list of CVE identifiers in the request."
                        },
                        "updatedDeferralReq": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "expiry": {
                              "nullable": true,
                              "type": "object",
                              "properties": {
                                "expiresWhenFixed": {
                                  "type": "boolean",
                                  "description": "Indicates that this request expires when the associated vulnerability is fixed.\nCannot be used with expires_on.\nOnly applicable to deferral requests."
                                },
                                "expiresOn": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "Indicates the timestamp when this request expires.\nCannot be used with expires_when_fixed.\nMust be a future timestamp.",
                                  "format": "date-time"
                                },
                                "expiryType": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "ExpiryType indicates the type of expiry for the request.\nThis field is under development, DO NOT USE FOR NON-DEVELOPMENT PURPOSES.\n\n - TIME: Request has a fixed expiry time. If used, expires_on must be set.\n - ALL_CVE_FIXABLE: Request expires if all CVEs in the request are fixable.\n - ANY_CVE_FIXABLE: Request expires if any CVE in the request is fixable.",
                                  "default": "TIME",
                                  "enum": [
                                    "TIME",
                                    "ALL_CVE_FIXABLE",
                                    "ANY_CVE_FIXABLE"
                                  ]
                                }
                              },
                              "description": "RequestExpiry defines the expiration configuration for deferral requests.\n\n**Expiry Rules:**\n- Deferral requests must specify expiry (either expires_when_fixed or expires_on)\n- False-positive requests do not have expiry (permanent)\n- Cannot specify both expiry options\n- Expiry type is under development (do not use for non-development purposes)"
                            }
                          },
                          "description": "DeferralRequest represents a request to temporarily defer vulnerability detection.\n\n**Deferral Rules:**\n- Must specify expiry configuration\n- Expiry can be time-based or fix-based\n- Deferrals are temporary and expire automatically"
                        },
                        "deferralUpdate": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "CVEs": {
                              "type": "array",
                              "description": "CVEs to be updated in the deferral request.\nCannot be empty (at least one CVE must remain).",
                              "items": {
                                "nullable": true,
                                "type": "string"
                              }
                            },
                            "expiry": {
                              "nullable": true,
                              "type": "object",
                              "properties": {
                                "expiresWhenFixed": {
                                  "type": "boolean",
                                  "description": "Indicates that this request expires when the associated vulnerability is fixed.\nCannot be used with expires_on.\nOnly applicable to deferral requests."
                                },
                                "expiresOn": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "Indicates the timestamp when this request expires.\nCannot be used with expires_when_fixed.\nMust be a future timestamp.",
                                  "format": "date-time"
                                },
                                "expiryType": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "ExpiryType indicates the type of expiry for the request.\nThis field is under development, DO NOT USE FOR NON-DEVELOPMENT PURPOSES.\n\n - TIME: Request has a fixed expiry time. If used, expires_on must be set.\n - ALL_CVE_FIXABLE: Request expires if all CVEs in the request are fixable.\n - ANY_CVE_FIXABLE: Request expires if any CVE in the request is fixable.",
                                  "default": "TIME",
                                  "enum": [
                                    "TIME",
                                    "ALL_CVE_FIXABLE",
                                    "ANY_CVE_FIXABLE"
                                  ]
                                }
                              },
                              "description": "RequestExpiry defines the expiration configuration for deferral requests.\n\n**Expiry Rules:**\n- Deferral requests must specify expiry (either expires_when_fixed or expires_on)\n- False-positive requests do not have expiry (permanent)\n- Cannot specify both expiry options\n- Expiry type is under development (do not use for non-development purposes)"
                            }
                          },
                          "description": "DeferralUpdate represents an update to an existing deferral request.\n\n**Update Rules:**\n- Can add or remove CVEs from the request\n- Cannot remove all CVEs (at least one CVE must remain)\n- Can update expiry configuration\n- Creates a new pending update request"
                        },
                        "falsePositiveUpdate": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "CVEs": {
                              "type": "array",
                              "description": "CVEs to be updated in the false-positive request.\nCannot be empty (at least one CVE must remain).",
                              "items": {
                                "nullable": true,
                                "type": "string"
                              }
                            }
                          },
                          "description": "FalsePositiveUpdate represents an update to an existing false-positive request.\n\n**Update Rules:**\n- Can add or remove CVEs from the request\n- Cannot remove all CVEs (at least one CVE must remain)\n- False-positive requests remain permanent (no expiry)"
                        }
                      },
                      "description": "VulnerabilityRequest encapsulates a request such as deferral request and false-positive request.\n\n**Request Lifecycle:**\n- Creation: New request in PENDING state\n- Approval: Request approved and enforced\n- Denial: Request denied and closed\n- Update: Approved request with pending update\n- Expiry: Request expires automatically or manually\n- Undo: Approved request undone and vulnerabilities re-enabled\n\n**Validation Rules:**\n- New requests must not have ID (auto-generated)\n- Must have at least one comment\n- Must have valid CVE format (e.g., \"CVE-2021-1234\")\n- Must have valid scope (image scope or global scope)\n- Cannot create duplicate requests for same CVE-scope combination\n- Deferral requests must specify expiry\n- False-positive requests are permanent (no expiry)\n- New requests cannot start in APPROVED or DENIED state\n\n**Performance Considerations:**\n- Maximum 1000 requests returned per list operation\n- Requests are processed sequentially to prevent race conditions\n- Duplicate prevention checks are performed during creation"
                    }
                  },
                  "description": "ApproveVulnRequestResponse contains the approved request information."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "application/json": {
                "schema": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "nullable": true,
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "@type": {
                            "nullable": true,
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com. As of May 2023, there are no widely used type server\nimplementations and no plans to implement one.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          }
                        },
                        "additionalProperties": {
                          "nullable": true,
                          "type": "object"
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n    // or ...\n    if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n      foo = any.unpack(Foo.getDefaultInstance());\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "x-codegen-request-body-name": "body"
      }
    },
    "/v1/cve/requests/{id}/deny": {
      "post": {
        "tags": [
          "VulnerabilityRequestService"
        ],
        "summary": "DenyVulnRequest denies a vulnerability request.",
        "description": "**Denial Behavior:**\n- Request is denied and permanently closed\n- No impact on vulnerability detection\n- Comment is required for denial\n\n**Denial Rules:**\n- Only pending requests can be denied\n- Comment is required for denial\n- Denied requests are permanently closed\n\n**Error Cases:**\n- 400: Missing comment or request not in pending state\n- 403: Insufficient permissions to deny requests\n- 404: Request with specified ID does not exist\n- 410: Service deprecated (when UnifiedCVEDeferral feature is enabled)",
        "operationId": "VulnerabilityRequestService_DenyVulnerabilityRequest",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of the vulnerability request to deny.",
            "required": true,
            "schema": {
              "nullable": true,
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "comment": {
                    "nullable": true,
                    "type": "string",
                    "description": "Comment explaining the denial decision.\nRequired for denial action."
                  }
                },
                "description": "DenyVulnRequest contains parameters for denying a vulnerability request.\n\n**Denial Rules:**\n- Comment is required for denial\n- Only pending requests can be denied\n- Denied requests are permanently closed"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "requestInfo": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "id": {
                          "nullable": true,
                          "type": "string",
                          "description": "Unique identifier for the vulnerability request (auto-generated).\nNew requests must not specify this field."
                        },
                        "name": {
                          "nullable": true,
                          "type": "string",
                          "description": "Human-readable name for the request (auto-generated).\nMust be unique across all requests."
                        },
                        "targetState": {
                          "nullable": true,
                          "type": "string",
                          "description": "VulnerabilityState indicates if vulnerability is being observed or deferred(/suppressed). By default, it vulnerabilities are observed.\n\n - OBSERVED: [Default state]",
                          "default": "OBSERVED",
                          "enum": [
                            "OBSERVED",
                            "DEFERRED",
                            "FALSE_POSITIVE"
                          ]
                        },
                        "status": {
                          "nullable": true,
                          "type": "string",
                          "description": "RequestStatus indicates the status of a vulnerability request.\n\n**Status Lifecycle:**\n- PENDING: Default state for new requests awaiting approval/denial\n- APPROVED: Request approved and enforced\n- DENIED: Request denied and permanently closed\n- APPROVED_PENDING_UPDATE: Approved request with pending update\n\n**Status Rules:**\n- New requests must start in PENDING state\n- Only PENDING requests can be approved or denied\n- APPROVED requests can be updated (creates APPROVED_PENDING_UPDATE)\n- DENIED requests are permanently closed\n- Cancelled requests are not persisted (except in audit logs)\n\n - PENDING: Default request state. It indicates that the request has not been fulfilled and that an action (approve/deny) is required.\nOnly requests in this state can be approved, denied, or updated.\n - APPROVED: Indicates that the request has been approved by the approver.\nApproved requests are immediately enforced and suppress vulnerability detection.\nOnly PENDING requests can transition to this state.\n - DENIED: Indicates that the request has been denied by the approver.\nDenied requests are permanently closed and have no impact on vulnerability detection.\nOnly PENDING requests can transition to this state.\n - APPROVED_PENDING_UPDATE: Indicates that the original request was approved, but an update is still pending an approval or denial.\nThis state occurs when an approved request is updated.\nThe original approval remains in effect until the update is processed.",
                          "default": "PENDING",
                          "enum": [
                            "PENDING",
                            "APPROVED",
                            "DENIED",
                            "APPROVED_PENDING_UPDATE"
                          ]
                        },
                        "expired": {
                          "type": "boolean",
                          "description": "Indicates if this request is a historical request that is no longer in effect\ndue to deferral expiry, cancellation, or restarting cve observation.\nExpired requests are retained for audit purposes."
                        },
                        "requestor": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "id": {
                              "nullable": true,
                              "type": "string"
                            },
                            "name": {
                              "nullable": true,
                              "type": "string"
                            }
                          }
                        },
                        "approvers": {
                          "type": "array",
                          "description": "DEPRECATED: Use approvers_v2 instead.\nUsers who can approve or deny the request.",
                          "items": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "id": {
                                "nullable": true,
                                "type": "string"
                              },
                              "name": {
                                "nullable": true,
                                "type": "string"
                              }
                            }
                          }
                        },
                        "createdAt": {
                          "nullable": true,
                          "type": "string",
                          "description": "Timestamp when the request was created.",
                          "format": "date-time"
                        },
                        "lastUpdated": {
                          "nullable": true,
                          "type": "string",
                          "description": "Timestamp when the request was last updated.",
                          "format": "date-time"
                        },
                        "comments": {
                          "type": "array",
                          "description": "Comments on the request providing audit trail.\nMust have at least one comment for new requests.",
                          "items": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "id": {
                                "nullable": true,
                                "type": "string",
                                "description": "Unique identifier for the comment."
                              },
                              "message": {
                                "nullable": true,
                                "type": "string",
                                "description": "The comment message content.\nRequired for all request actions."
                              },
                              "user": {
                                "nullable": true,
                                "type": "object",
                                "properties": {
                                  "id": {
                                    "nullable": true,
                                    "type": "string"
                                  },
                                  "name": {
                                    "nullable": true,
                                    "type": "string"
                                  }
                                }
                              },
                              "createdAt": {
                                "nullable": true,
                                "type": "string",
                                "description": "Timestamp when the comment was created.",
                                "format": "date-time"
                              }
                            },
                            "description": "RequestComment represents a comment on a vulnerability request.\n\n**Comment Rules:**\n- Comments are required for all request actions (create, approve, deny, update)\n- Each comment is associated with a user and timestamp\n- Comments provide audit trail for request lifecycle"
                          }
                        },
                        "scope": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "imageScope": {
                              "nullable": true,
                              "type": "object",
                              "properties": {
                                "registry": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "Container registry (e.g., \"docker.io\", \"gcr.io\").\nRequired for image scope."
                                },
                                "remote": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "Image repository name (e.g., \"stackrox/main\").\nRequired for image scope."
                                },
                                "tag": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "Image tag (e.g., \"latest\", \"v1.0.0\").\nRequired for image scope."
                                }
                              },
                              "description": "Image scope applies the request to specific container images."
                            },
                            "globalScope": {
                              "nullable": true,
                              "type": "object",
                              "description": "Global scope applies the request system-wide (deprecated)."
                            }
                          },
                          "description": "Scope defines the scope where the vulnerability request applies."
                        },
                        "requesterV2": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "id": {
                              "nullable": true,
                              "type": "string",
                              "description": "Unique identifier for the requester."
                            },
                            "name": {
                              "nullable": true,
                              "type": "string",
                              "description": "Display name of the requester."
                            }
                          },
                          "description": "Requester represents the user who created the vulnerability request.\n\n**Requester Rules:**\n- Must be specified for all new requests\n- Cannot be changed after request creation\n- Used for audit trail and permission checks"
                        },
                        "approversV2": {
                          "type": "array",
                          "description": "Users who can approve or deny the request (v2).\nMultiple approvers can be assigned.",
                          "items": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "id": {
                                "nullable": true,
                                "type": "string",
                                "description": "Unique identifier for the approver."
                              },
                              "name": {
                                "nullable": true,
                                "type": "string",
                                "description": "Display name of the approver."
                              }
                            },
                            "description": "Approver represents a user who can approve or deny vulnerability requests.\n\n**Approver Rules:**\n- Multiple approvers can be assigned to a request\n- Any approver can approve or deny the request\n- Used for audit trail and permission checks"
                          }
                        },
                        "deferralReq": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "expiry": {
                              "nullable": true,
                              "type": "object",
                              "properties": {
                                "expiresWhenFixed": {
                                  "type": "boolean",
                                  "description": "Indicates that this request expires when the associated vulnerability is fixed.\nCannot be used with expires_on.\nOnly applicable to deferral requests."
                                },
                                "expiresOn": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "Indicates the timestamp when this request expires.\nCannot be used with expires_when_fixed.\nMust be a future timestamp.",
                                  "format": "date-time"
                                },
                                "expiryType": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "ExpiryType indicates the type of expiry for the request.\nThis field is under development, DO NOT USE FOR NON-DEVELOPMENT PURPOSES.\n\n - TIME: Request has a fixed expiry time. If used, expires_on must be set.\n - ALL_CVE_FIXABLE: Request expires if all CVEs in the request are fixable.\n - ANY_CVE_FIXABLE: Request expires if any CVE in the request is fixable.",
                                  "default": "TIME",
                                  "enum": [
                                    "TIME",
                                    "ALL_CVE_FIXABLE",
                                    "ANY_CVE_FIXABLE"
                                  ]
                                }
                              },
                              "description": "RequestExpiry defines the expiration configuration for deferral requests.\n\n**Expiry Rules:**\n- Deferral requests must specify expiry (either expires_when_fixed or expires_on)\n- False-positive requests do not have expiry (permanent)\n- Cannot specify both expiry options\n- Expiry type is under development (do not use for non-development purposes)"
                            }
                          },
                          "description": "DeferralRequest represents a request to temporarily defer vulnerability detection.\n\n**Deferral Rules:**\n- Must specify expiry configuration\n- Expiry can be time-based or fix-based\n- Deferrals are temporary and expire automatically"
                        },
                        "fpRequest": {
                          "nullable": true,
                          "type": "object",
                          "description": "FalsePositiveRequest represents a request to permanently mark vulnerabilities as false-positive.\n\n**False-Positive Rules:**\n- No expiry configuration (permanent)\n- False-positives are permanently suppressed\n- Cannot be undone except through request management"
                        },
                        "cves": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "cves": {
                              "type": "array",
                              "description": "These are (NVD) vulnerability identifiers, `cve` field of `storage.CVE`, and *not* the `id` field.\nFor example, CVE-2021-44832.\nMust be in valid CVE format and not already covered by approved requests.",
                              "items": {
                                "nullable": true,
                                "type": "string"
                              }
                            }
                          },
                          "description": "CVEs represents the list of CVE identifiers in the request."
                        },
                        "updatedDeferralReq": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "expiry": {
                              "nullable": true,
                              "type": "object",
                              "properties": {
                                "expiresWhenFixed": {
                                  "type": "boolean",
                                  "description": "Indicates that this request expires when the associated vulnerability is fixed.\nCannot be used with expires_on.\nOnly applicable to deferral requests."
                                },
                                "expiresOn": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "Indicates the timestamp when this request expires.\nCannot be used with expires_when_fixed.\nMust be a future timestamp.",
                                  "format": "date-time"
                                },
                                "expiryType": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "ExpiryType indicates the type of expiry for the request.\nThis field is under development, DO NOT USE FOR NON-DEVELOPMENT PURPOSES.\n\n - TIME: Request has a fixed expiry time. If used, expires_on must be set.\n - ALL_CVE_FIXABLE: Request expires if all CVEs in the request are fixable.\n - ANY_CVE_FIXABLE: Request expires if any CVE in the request is fixable.",
                                  "default": "TIME",
                                  "enum": [
                                    "TIME",
                                    "ALL_CVE_FIXABLE",
                                    "ANY_CVE_FIXABLE"
                                  ]
                                }
                              },
                              "description": "RequestExpiry defines the expiration configuration for deferral requests.\n\n**Expiry Rules:**\n- Deferral requests must specify expiry (either expires_when_fixed or expires_on)\n- False-positive requests do not have expiry (permanent)\n- Cannot specify both expiry options\n- Expiry type is under development (do not use for non-development purposes)"
                            }
                          },
                          "description": "DeferralRequest represents a request to temporarily defer vulnerability detection.\n\n**Deferral Rules:**\n- Must specify expiry configuration\n- Expiry can be time-based or fix-based\n- Deferrals are temporary and expire automatically"
                        },
                        "deferralUpdate": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "CVEs": {
                              "type": "array",
                              "description": "CVEs to be updated in the deferral request.\nCannot be empty (at least one CVE must remain).",
                              "items": {
                                "nullable": true,
                                "type": "string"
                              }
                            },
                            "expiry": {
                              "nullable": true,
                              "type": "object",
                              "properties": {
                                "expiresWhenFixed": {
                                  "type": "boolean",
                                  "description": "Indicates that this request expires when the associated vulnerability is fixed.\nCannot be used with expires_on.\nOnly applicable to deferral requests."
                                },
                                "expiresOn": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "Indicates the timestamp when this request expires.\nCannot be used with expires_when_fixed.\nMust be a future timestamp.",
                                  "format": "date-time"
                                },
                                "expiryType": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "ExpiryType indicates the type of expiry for the request.\nThis field is under development, DO NOT USE FOR NON-DEVELOPMENT PURPOSES.\n\n - TIME: Request has a fixed expiry time. If used, expires_on must be set.\n - ALL_CVE_FIXABLE: Request expires if all CVEs in the request are fixable.\n - ANY_CVE_FIXABLE: Request expires if any CVE in the request is fixable.",
                                  "default": "TIME",
                                  "enum": [
                                    "TIME",
                                    "ALL_CVE_FIXABLE",
                                    "ANY_CVE_FIXABLE"
                                  ]
                                }
                              },
                              "description": "RequestExpiry defines the expiration configuration for deferral requests.\n\n**Expiry Rules:**\n- Deferral requests must specify expiry (either expires_when_fixed or expires_on)\n- False-positive requests do not have expiry (permanent)\n- Cannot specify both expiry options\n- Expiry type is under development (do not use for non-development purposes)"
                            }
                          },
                          "description": "DeferralUpdate represents an update to an existing deferral request.\n\n**Update Rules:**\n- Can add or remove CVEs from the request\n- Cannot remove all CVEs (at least one CVE must remain)\n- Can update expiry configuration\n- Creates a new pending update request"
                        },
                        "falsePositiveUpdate": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "CVEs": {
                              "type": "array",
                              "description": "CVEs to be updated in the false-positive request.\nCannot be empty (at least one CVE must remain).",
                              "items": {
                                "nullable": true,
                                "type": "string"
                              }
                            }
                          },
                          "description": "FalsePositiveUpdate represents an update to an existing false-positive request.\n\n**Update Rules:**\n- Can add or remove CVEs from the request\n- Cannot remove all CVEs (at least one CVE must remain)\n- False-positive requests remain permanent (no expiry)"
                        }
                      },
                      "description": "VulnerabilityRequest encapsulates a request such as deferral request and false-positive request.\n\n**Request Lifecycle:**\n- Creation: New request in PENDING state\n- Approval: Request approved and enforced\n- Denial: Request denied and closed\n- Update: Approved request with pending update\n- Expiry: Request expires automatically or manually\n- Undo: Approved request undone and vulnerabilities re-enabled\n\n**Validation Rules:**\n- New requests must not have ID (auto-generated)\n- Must have at least one comment\n- Must have valid CVE format (e.g., \"CVE-2021-1234\")\n- Must have valid scope (image scope or global scope)\n- Cannot create duplicate requests for same CVE-scope combination\n- Deferral requests must specify expiry\n- False-positive requests are permanent (no expiry)\n- New requests cannot start in APPROVED or DENIED state\n\n**Performance Considerations:**\n- Maximum 1000 requests returned per list operation\n- Requests are processed sequentially to prevent race conditions\n- Duplicate prevention checks are performed during creation"
                    }
                  },
                  "description": "DenyVulnRequestResponse contains the denied request information."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "application/json": {
                "schema": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "nullable": true,
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "@type": {
                            "nullable": true,
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com. As of May 2023, there are no widely used type server\nimplementations and no plans to implement one.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          }
                        },
                        "additionalProperties": {
                          "nullable": true,
                          "type": "object"
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n    // or ...\n    if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n      foo = any.unpack(Foo.getDefaultInstance());\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "x-codegen-request-body-name": "body"
      }
    },
    "/v1/cve/requests/{id}/undo": {
      "post": {
        "tags": [
          "VulnerabilityRequestService"
        ],
        "summary": "UndoVulnerabilityRequest undoes a vulnerability request.",
        "description": "**Undo Behavior:**\n- Request is marked as inactive\n- Vulnerabilities are re-enabled for detection\n- May not re-enable if other active requests cover same CVEs\n\n**Undo Rules:**\n- Only approved requests can be undone\n- Undo may not re-enable vulnerabilities if other active requests exist\n- Request is permanently marked as inactive\n\n**Error Cases:**\n- 403: Insufficient permissions to undo requests\n- 404: Request with specified ID does not exist\n- 410: Service deprecated (when UnifiedCVEDeferral feature is enabled)",
        "operationId": "VulnerabilityRequestService_UndoVulnerabilityRequest",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "nullable": true,
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "requestInfo": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "id": {
                          "nullable": true,
                          "type": "string",
                          "description": "Unique identifier for the vulnerability request (auto-generated).\nNew requests must not specify this field."
                        },
                        "name": {
                          "nullable": true,
                          "type": "string",
                          "description": "Human-readable name for the request (auto-generated).\nMust be unique across all requests."
                        },
                        "targetState": {
                          "nullable": true,
                          "type": "string",
                          "description": "VulnerabilityState indicates if vulnerability is being observed or deferred(/suppressed). By default, it vulnerabilities are observed.\n\n - OBSERVED: [Default state]",
                          "default": "OBSERVED",
                          "enum": [
                            "OBSERVED",
                            "DEFERRED",
                            "FALSE_POSITIVE"
                          ]
                        },
                        "status": {
                          "nullable": true,
                          "type": "string",
                          "description": "RequestStatus indicates the status of a vulnerability request.\n\n**Status Lifecycle:**\n- PENDING: Default state for new requests awaiting approval/denial\n- APPROVED: Request approved and enforced\n- DENIED: Request denied and permanently closed\n- APPROVED_PENDING_UPDATE: Approved request with pending update\n\n**Status Rules:**\n- New requests must start in PENDING state\n- Only PENDING requests can be approved or denied\n- APPROVED requests can be updated (creates APPROVED_PENDING_UPDATE)\n- DENIED requests are permanently closed\n- Cancelled requests are not persisted (except in audit logs)\n\n - PENDING: Default request state. It indicates that the request has not been fulfilled and that an action (approve/deny) is required.\nOnly requests in this state can be approved, denied, or updated.\n - APPROVED: Indicates that the request has been approved by the approver.\nApproved requests are immediately enforced and suppress vulnerability detection.\nOnly PENDING requests can transition to this state.\n - DENIED: Indicates that the request has been denied by the approver.\nDenied requests are permanently closed and have no impact on vulnerability detection.\nOnly PENDING requests can transition to this state.\n - APPROVED_PENDING_UPDATE: Indicates that the original request was approved, but an update is still pending an approval or denial.\nThis state occurs when an approved request is updated.\nThe original approval remains in effect until the update is processed.",
                          "default": "PENDING",
                          "enum": [
                            "PENDING",
                            "APPROVED",
                            "DENIED",
                            "APPROVED_PENDING_UPDATE"
                          ]
                        },
                        "expired": {
                          "type": "boolean",
                          "description": "Indicates if this request is a historical request that is no longer in effect\ndue to deferral expiry, cancellation, or restarting cve observation.\nExpired requests are retained for audit purposes."
                        },
                        "requestor": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "id": {
                              "nullable": true,
                              "type": "string"
                            },
                            "name": {
                              "nullable": true,
                              "type": "string"
                            }
                          }
                        },
                        "approvers": {
                          "type": "array",
                          "description": "DEPRECATED: Use approvers_v2 instead.\nUsers who can approve or deny the request.",
                          "items": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "id": {
                                "nullable": true,
                                "type": "string"
                              },
                              "name": {
                                "nullable": true,
                                "type": "string"
                              }
                            }
                          }
                        },
                        "createdAt": {
                          "nullable": true,
                          "type": "string",
                          "description": "Timestamp when the request was created.",
                          "format": "date-time"
                        },
                        "lastUpdated": {
                          "nullable": true,
                          "type": "string",
                          "description": "Timestamp when the request was last updated.",
                          "format": "date-time"
                        },
                        "comments": {
                          "type": "array",
                          "description": "Comments on the request providing audit trail.\nMust have at least one comment for new requests.",
                          "items": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "id": {
                                "nullable": true,
                                "type": "string",
                                "description": "Unique identifier for the comment."
                              },
                              "message": {
                                "nullable": true,
                                "type": "string",
                                "description": "The comment message content.\nRequired for all request actions."
                              },
                              "user": {
                                "nullable": true,
                                "type": "object",
                                "properties": {
                                  "id": {
                                    "nullable": true,
                                    "type": "string"
                                  },
                                  "name": {
                                    "nullable": true,
                                    "type": "string"
                                  }
                                }
                              },
                              "createdAt": {
                                "nullable": true,
                                "type": "string",
                                "description": "Timestamp when the comment was created.",
                                "format": "date-time"
                              }
                            },
                            "description": "RequestComment represents a comment on a vulnerability request.\n\n**Comment Rules:**\n- Comments are required for all request actions (create, approve, deny, update)\n- Each comment is associated with a user and timestamp\n- Comments provide audit trail for request lifecycle"
                          }
                        },
                        "scope": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "imageScope": {
                              "nullable": true,
                              "type": "object",
                              "properties": {
                                "registry": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "Container registry (e.g., \"docker.io\", \"gcr.io\").\nRequired for image scope."
                                },
                                "remote": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "Image repository name (e.g., \"stackrox/main\").\nRequired for image scope."
                                },
                                "tag": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "Image tag (e.g., \"latest\", \"v1.0.0\").\nRequired for image scope."
                                }
                              },
                              "description": "Image scope applies the request to specific container images."
                            },
                            "globalScope": {
                              "nullable": true,
                              "type": "object",
                              "description": "Global scope applies the request system-wide (deprecated)."
                            }
                          },
                          "description": "Scope defines the scope where the vulnerability request applies."
                        },
                        "requesterV2": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "id": {
                              "nullable": true,
                              "type": "string",
                              "description": "Unique identifier for the requester."
                            },
                            "name": {
                              "nullable": true,
                              "type": "string",
                              "description": "Display name of the requester."
                            }
                          },
                          "description": "Requester represents the user who created the vulnerability request.\n\n**Requester Rules:**\n- Must be specified for all new requests\n- Cannot be changed after request creation\n- Used for audit trail and permission checks"
                        },
                        "approversV2": {
                          "type": "array",
                          "description": "Users who can approve or deny the request (v2).\nMultiple approvers can be assigned.",
                          "items": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "id": {
                                "nullable": true,
                                "type": "string",
                                "description": "Unique identifier for the approver."
                              },
                              "name": {
                                "nullable": true,
                                "type": "string",
                                "description": "Display name of the approver."
                              }
                            },
                            "description": "Approver represents a user who can approve or deny vulnerability requests.\n\n**Approver Rules:**\n- Multiple approvers can be assigned to a request\n- Any approver can approve or deny the request\n- Used for audit trail and permission checks"
                          }
                        },
                        "deferralReq": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "expiry": {
                              "nullable": true,
                              "type": "object",
                              "properties": {
                                "expiresWhenFixed": {
                                  "type": "boolean",
                                  "description": "Indicates that this request expires when the associated vulnerability is fixed.\nCannot be used with expires_on.\nOnly applicable to deferral requests."
                                },
                                "expiresOn": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "Indicates the timestamp when this request expires.\nCannot be used with expires_when_fixed.\nMust be a future timestamp.",
                                  "format": "date-time"
                                },
                                "expiryType": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "ExpiryType indicates the type of expiry for the request.\nThis field is under development, DO NOT USE FOR NON-DEVELOPMENT PURPOSES.\n\n - TIME: Request has a fixed expiry time. If used, expires_on must be set.\n - ALL_CVE_FIXABLE: Request expires if all CVEs in the request are fixable.\n - ANY_CVE_FIXABLE: Request expires if any CVE in the request is fixable.",
                                  "default": "TIME",
                                  "enum": [
                                    "TIME",
                                    "ALL_CVE_FIXABLE",
                                    "ANY_CVE_FIXABLE"
                                  ]
                                }
                              },
                              "description": "RequestExpiry defines the expiration configuration for deferral requests.\n\n**Expiry Rules:**\n- Deferral requests must specify expiry (either expires_when_fixed or expires_on)\n- False-positive requests do not have expiry (permanent)\n- Cannot specify both expiry options\n- Expiry type is under development (do not use for non-development purposes)"
                            }
                          },
                          "description": "DeferralRequest represents a request to temporarily defer vulnerability detection.\n\n**Deferral Rules:**\n- Must specify expiry configuration\n- Expiry can be time-based or fix-based\n- Deferrals are temporary and expire automatically"
                        },
                        "fpRequest": {
                          "nullable": true,
                          "type": "object",
                          "description": "FalsePositiveRequest represents a request to permanently mark vulnerabilities as false-positive.\n\n**False-Positive Rules:**\n- No expiry configuration (permanent)\n- False-positives are permanently suppressed\n- Cannot be undone except through request management"
                        },
                        "cves": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "cves": {
                              "type": "array",
                              "description": "These are (NVD) vulnerability identifiers, `cve` field of `storage.CVE`, and *not* the `id` field.\nFor example, CVE-2021-44832.\nMust be in valid CVE format and not already covered by approved requests.",
                              "items": {
                                "nullable": true,
                                "type": "string"
                              }
                            }
                          },
                          "description": "CVEs represents the list of CVE identifiers in the request."
                        },
                        "updatedDeferralReq": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "expiry": {
                              "nullable": true,
                              "type": "object",
                              "properties": {
                                "expiresWhenFixed": {
                                  "type": "boolean",
                                  "description": "Indicates that this request expires when the associated vulnerability is fixed.\nCannot be used with expires_on.\nOnly applicable to deferral requests."
                                },
                                "expiresOn": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "Indicates the timestamp when this request expires.\nCannot be used with expires_when_fixed.\nMust be a future timestamp.",
                                  "format": "date-time"
                                },
                                "expiryType": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "ExpiryType indicates the type of expiry for the request.\nThis field is under development, DO NOT USE FOR NON-DEVELOPMENT PURPOSES.\n\n - TIME: Request has a fixed expiry time. If used, expires_on must be set.\n - ALL_CVE_FIXABLE: Request expires if all CVEs in the request are fixable.\n - ANY_CVE_FIXABLE: Request expires if any CVE in the request is fixable.",
                                  "default": "TIME",
                                  "enum": [
                                    "TIME",
                                    "ALL_CVE_FIXABLE",
                                    "ANY_CVE_FIXABLE"
                                  ]
                                }
                              },
                              "description": "RequestExpiry defines the expiration configuration for deferral requests.\n\n**Expiry Rules:**\n- Deferral requests must specify expiry (either expires_when_fixed or expires_on)\n- False-positive requests do not have expiry (permanent)\n- Cannot specify both expiry options\n- Expiry type is under development (do not use for non-development purposes)"
                            }
                          },
                          "description": "DeferralRequest represents a request to temporarily defer vulnerability detection.\n\n**Deferral Rules:**\n- Must specify expiry configuration\n- Expiry can be time-based or fix-based\n- Deferrals are temporary and expire automatically"
                        },
                        "deferralUpdate": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "CVEs": {
                              "type": "array",
                              "description": "CVEs to be updated in the deferral request.\nCannot be empty (at least one CVE must remain).",
                              "items": {
                                "nullable": true,
                                "type": "string"
                              }
                            },
                            "expiry": {
                              "nullable": true,
                              "type": "object",
                              "properties": {
                                "expiresWhenFixed": {
                                  "type": "boolean",
                                  "description": "Indicates that this request expires when the associated vulnerability is fixed.\nCannot be used with expires_on.\nOnly applicable to deferral requests."
                                },
                                "expiresOn": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "Indicates the timestamp when this request expires.\nCannot be used with expires_when_fixed.\nMust be a future timestamp.",
                                  "format": "date-time"
                                },
                                "expiryType": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "ExpiryType indicates the type of expiry for the request.\nThis field is under development, DO NOT USE FOR NON-DEVELOPMENT PURPOSES.\n\n - TIME: Request has a fixed expiry time. If used, expires_on must be set.\n - ALL_CVE_FIXABLE: Request expires if all CVEs in the request are fixable.\n - ANY_CVE_FIXABLE: Request expires if any CVE in the request is fixable.",
                                  "default": "TIME",
                                  "enum": [
                                    "TIME",
                                    "ALL_CVE_FIXABLE",
                                    "ANY_CVE_FIXABLE"
                                  ]
                                }
                              },
                              "description": "RequestExpiry defines the expiration configuration for deferral requests.\n\n**Expiry Rules:**\n- Deferral requests must specify expiry (either expires_when_fixed or expires_on)\n- False-positive requests do not have expiry (permanent)\n- Cannot specify both expiry options\n- Expiry type is under development (do not use for non-development purposes)"
                            }
                          },
                          "description": "DeferralUpdate represents an update to an existing deferral request.\n\n**Update Rules:**\n- Can add or remove CVEs from the request\n- Cannot remove all CVEs (at least one CVE must remain)\n- Can update expiry configuration\n- Creates a new pending update request"
                        },
                        "falsePositiveUpdate": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "CVEs": {
                              "type": "array",
                              "description": "CVEs to be updated in the false-positive request.\nCannot be empty (at least one CVE must remain).",
                              "items": {
                                "nullable": true,
                                "type": "string"
                              }
                            }
                          },
                          "description": "FalsePositiveUpdate represents an update to an existing false-positive request.\n\n**Update Rules:**\n- Can add or remove CVEs from the request\n- Cannot remove all CVEs (at least one CVE must remain)\n- False-positive requests remain permanent (no expiry)"
                        }
                      },
                      "description": "VulnerabilityRequest encapsulates a request such as deferral request and false-positive request.\n\n**Request Lifecycle:**\n- Creation: New request in PENDING state\n- Approval: Request approved and enforced\n- Denial: Request denied and closed\n- Update: Approved request with pending update\n- Expiry: Request expires automatically or manually\n- Undo: Approved request undone and vulnerabilities re-enabled\n\n**Validation Rules:**\n- New requests must not have ID (auto-generated)\n- Must have at least one comment\n- Must have valid CVE format (e.g., \"CVE-2021-1234\")\n- Must have valid scope (image scope or global scope)\n- Cannot create duplicate requests for same CVE-scope combination\n- Deferral requests must specify expiry\n- False-positive requests are permanent (no expiry)\n- New requests cannot start in APPROVED or DENIED state\n\n**Performance Considerations:**\n- Maximum 1000 requests returned per list operation\n- Requests are processed sequentially to prevent race conditions\n- Duplicate prevention checks are performed during creation"
                    }
                  },
                  "description": "UndoVulnRequestResponse contains the undone request information."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "application/json": {
                "schema": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "nullable": true,
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "@type": {
                            "nullable": true,
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com. As of May 2023, there are no widely used type server\nimplementations and no plans to implement one.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          }
                        },
                        "additionalProperties": {
                          "nullable": true,
                          "type": "object"
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n    // or ...\n    if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n      foo = any.unpack(Foo.getDefaultInstance());\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/v1/cve/requests/{id}/update": {
      "post": {
        "tags": [
          "VulnerabilityRequestService"
        ],
        "summary": "UpdateVulnerabilityRequest updates an existing vulnerability request.",
        "description": "**Update Limitations:**\n- Currently, only expiry can be updated\n- Comment is required for update\n- Only pending requests can be updated\n- Update creates a new pending update request\n\n**Update Behavior:**\n- Creates a new pending update request\n- Original request remains in effect until update is approved\n- Only expiry configuration can be modified\n\n**Error Cases:**\n- 400: Missing comment, invalid expiry, or request not in pending state\n- 403: Insufficient permissions to update requests\n- 404: Request with specified ID does not exist\n- 410: Service deprecated (when UnifiedCVEDeferral feature is enabled)",
        "operationId": "VulnerabilityRequestService_UpdateVulnerabilityRequest",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID of the vulnerability request to update.",
            "required": true,
            "schema": {
              "nullable": true,
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "comment": {
                    "nullable": true,
                    "type": "string",
                    "description": "Comment explaining the update.\nRequired for update action."
                  },
                  "expiry": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "expiresWhenFixed": {
                        "type": "boolean",
                        "description": "Indicates that this request expires when the associated vulnerability is fixed.\nCannot be used with expires_on.\nOnly applicable to deferral requests."
                      },
                      "expiresOn": {
                        "nullable": true,
                        "type": "string",
                        "description": "Indicates the timestamp when this request expires.\nCannot be used with expires_when_fixed.\nMust be a future timestamp.",
                        "format": "date-time"
                      },
                      "expiryType": {
                        "nullable": true,
                        "type": "string",
                        "description": "ExpiryType indicates the type of expiry for the request.\nThis field is under development, DO NOT USE FOR NON-DEVELOPMENT PURPOSES.\n\n - TIME: Request has a fixed expiry time. If used, expires_on must be set.\n - ALL_CVE_FIXABLE: Request expires if all CVEs in the request are fixable.\n - ANY_CVE_FIXABLE: Request expires if any CVE in the request is fixable.",
                        "default": "TIME",
                        "enum": [
                          "TIME",
                          "ALL_CVE_FIXABLE",
                          "ANY_CVE_FIXABLE"
                        ]
                      }
                    },
                    "description": "RequestExpiry defines the expiration configuration for deferral requests.\n\n**Expiry Rules:**\n- Deferral requests must specify expiry (either expires_when_fixed or expires_on)\n- False-positive requests do not have expiry (permanent)\n- Cannot specify both expiry options\n- Expiry type is under development (do not use for non-development purposes)"
                  }
                },
                "description": "UpdateVulnRequest contains parameters for updating a vulnerability request.\n\n**Update Limitations:**\n- Currently, only expiry can be updated\n- Comment is required for update\n- Only pending requests can be updated\n- Update creates a new pending update request"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "requestInfo": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "id": {
                          "nullable": true,
                          "type": "string",
                          "description": "Unique identifier for the vulnerability request (auto-generated).\nNew requests must not specify this field."
                        },
                        "name": {
                          "nullable": true,
                          "type": "string",
                          "description": "Human-readable name for the request (auto-generated).\nMust be unique across all requests."
                        },
                        "targetState": {
                          "nullable": true,
                          "type": "string",
                          "description": "VulnerabilityState indicates if vulnerability is being observed or deferred(/suppressed). By default, it vulnerabilities are observed.\n\n - OBSERVED: [Default state]",
                          "default": "OBSERVED",
                          "enum": [
                            "OBSERVED",
                            "DEFERRED",
                            "FALSE_POSITIVE"
                          ]
                        },
                        "status": {
                          "nullable": true,
                          "type": "string",
                          "description": "RequestStatus indicates the status of a vulnerability request.\n\n**Status Lifecycle:**\n- PENDING: Default state for new requests awaiting approval/denial\n- APPROVED: Request approved and enforced\n- DENIED: Request denied and permanently closed\n- APPROVED_PENDING_UPDATE: Approved request with pending update\n\n**Status Rules:**\n- New requests must start in PENDING state\n- Only PENDING requests can be approved or denied\n- APPROVED requests can be updated (creates APPROVED_PENDING_UPDATE)\n- DENIED requests are permanently closed\n- Cancelled requests are not persisted (except in audit logs)\n\n - PENDING: Default request state. It indicates that the request has not been fulfilled and that an action (approve/deny) is required.\nOnly requests in this state can be approved, denied, or updated.\n - APPROVED: Indicates that the request has been approved by the approver.\nApproved requests are immediately enforced and suppress vulnerability detection.\nOnly PENDING requests can transition to this state.\n - DENIED: Indicates that the request has been denied by the approver.\nDenied requests are permanently closed and have no impact on vulnerability detection.\nOnly PENDING requests can transition to this state.\n - APPROVED_PENDING_UPDATE: Indicates that the original request was approved, but an update is still pending an approval or denial.\nThis state occurs when an approved request is updated.\nThe original approval remains in effect until the update is processed.",
                          "default": "PENDING",
                          "enum": [
                            "PENDING",
                            "APPROVED",
                            "DENIED",
                            "APPROVED_PENDING_UPDATE"
                          ]
                        },
                        "expired": {
                          "type": "boolean",
                          "description": "Indicates if this request is a historical request that is no longer in effect\ndue to deferral expiry, cancellation, or restarting cve observation.\nExpired requests are retained for audit purposes."
                        },
                        "requestor": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "id": {
                              "nullable": true,
                              "type": "string"
                            },
                            "name": {
                              "nullable": true,
                              "type": "string"
                            }
                          }
                        },
                        "approvers": {
                          "type": "array",
                          "description": "DEPRECATED: Use approvers_v2 instead.\nUsers who can approve or deny the request.",
                          "items": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "id": {
                                "nullable": true,
                                "type": "string"
                              },
                              "name": {
                                "nullable": true,
                                "type": "string"
                              }
                            }
                          }
                        },
                        "createdAt": {
                          "nullable": true,
                          "type": "string",
                          "description": "Timestamp when the request was created.",
                          "format": "date-time"
                        },
                        "lastUpdated": {
                          "nullable": true,
                          "type": "string",
                          "description": "Timestamp when the request was last updated.",
                          "format": "date-time"
                        },
                        "comments": {
                          "type": "array",
                          "description": "Comments on the request providing audit trail.\nMust have at least one comment for new requests.",
                          "items": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "id": {
                                "nullable": true,
                                "type": "string",
                                "description": "Unique identifier for the comment."
                              },
                              "message": {
                                "nullable": true,
                                "type": "string",
                                "description": "The comment message content.\nRequired for all request actions."
                              },
                              "user": {
                                "nullable": true,
                                "type": "object",
                                "properties": {
                                  "id": {
                                    "nullable": true,
                                    "type": "string"
                                  },
                                  "name": {
                                    "nullable": true,
                                    "type": "string"
                                  }
                                }
                              },
                              "createdAt": {
                                "nullable": true,
                                "type": "string",
                                "description": "Timestamp when the comment was created.",
                                "format": "date-time"
                              }
                            },
                            "description": "RequestComment represents a comment on a vulnerability request.\n\n**Comment Rules:**\n- Comments are required for all request actions (create, approve, deny, update)\n- Each comment is associated with a user and timestamp\n- Comments provide audit trail for request lifecycle"
                          }
                        },
                        "scope": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "imageScope": {
                              "nullable": true,
                              "type": "object",
                              "properties": {
                                "registry": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "Container registry (e.g., \"docker.io\", \"gcr.io\").\nRequired for image scope."
                                },
                                "remote": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "Image repository name (e.g., \"stackrox/main\").\nRequired for image scope."
                                },
                                "tag": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "Image tag (e.g., \"latest\", \"v1.0.0\").\nRequired for image scope."
                                }
                              },
                              "description": "Image scope applies the request to specific container images."
                            },
                            "globalScope": {
                              "nullable": true,
                              "type": "object",
                              "description": "Global scope applies the request system-wide (deprecated)."
                            }
                          },
                          "description": "Scope defines the scope where the vulnerability request applies."
                        },
                        "requesterV2": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "id": {
                              "nullable": true,
                              "type": "string",
                              "description": "Unique identifier for the requester."
                            },
                            "name": {
                              "nullable": true,
                              "type": "string",
                              "description": "Display name of the requester."
                            }
                          },
                          "description": "Requester represents the user who created the vulnerability request.\n\n**Requester Rules:**\n- Must be specified for all new requests\n- Cannot be changed after request creation\n- Used for audit trail and permission checks"
                        },
                        "approversV2": {
                          "type": "array",
                          "description": "Users who can approve or deny the request (v2).\nMultiple approvers can be assigned.",
                          "items": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "id": {
                                "nullable": true,
                                "type": "string",
                                "description": "Unique identifier for the approver."
                              },
                              "name": {
                                "nullable": true,
                                "type": "string",
                                "description": "Display name of the approver."
                              }
                            },
                            "description": "Approver represents a user who can approve or deny vulnerability requests.\n\n**Approver Rules:**\n- Multiple approvers can be assigned to a request\n- Any approver can approve or deny the request\n- Used for audit trail and permission checks"
                          }
                        },
                        "deferralReq": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "expiry": {
                              "nullable": true,
                              "type": "object",
                              "properties": {
                                "expiresWhenFixed": {
                                  "type": "boolean",
                                  "description": "Indicates that this request expires when the associated vulnerability is fixed.\nCannot be used with expires_on.\nOnly applicable to deferral requests."
                                },
                                "expiresOn": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "Indicates the timestamp when this request expires.\nCannot be used with expires_when_fixed.\nMust be a future timestamp.",
                                  "format": "date-time"
                                },
                                "expiryType": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "ExpiryType indicates the type of expiry for the request.\nThis field is under development, DO NOT USE FOR NON-DEVELOPMENT PURPOSES.\n\n - TIME: Request has a fixed expiry time. If used, expires_on must be set.\n - ALL_CVE_FIXABLE: Request expires if all CVEs in the request are fixable.\n - ANY_CVE_FIXABLE: Request expires if any CVE in the request is fixable.",
                                  "default": "TIME",
                                  "enum": [
                                    "TIME",
                                    "ALL_CVE_FIXABLE",
                                    "ANY_CVE_FIXABLE"
                                  ]
                                }
                              },
                              "description": "RequestExpiry defines the expiration configuration for deferral requests.\n\n**Expiry Rules:**\n- Deferral requests must specify expiry (either expires_when_fixed or expires_on)\n- False-positive requests do not have expiry (permanent)\n- Cannot specify both expiry options\n- Expiry type is under development (do not use for non-development purposes)"
                            }
                          },
                          "description": "DeferralRequest represents a request to temporarily defer vulnerability detection.\n\n**Deferral Rules:**\n- Must specify expiry configuration\n- Expiry can be time-based or fix-based\n- Deferrals are temporary and expire automatically"
                        },
                        "fpRequest": {
                          "nullable": true,
                          "type": "object",
                          "description": "FalsePositiveRequest represents a request to permanently mark vulnerabilities as false-positive.\n\n**False-Positive Rules:**\n- No expiry configuration (permanent)\n- False-positives are permanently suppressed\n- Cannot be undone except through request management"
                        },
                        "cves": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "cves": {
                              "type": "array",
                              "description": "These are (NVD) vulnerability identifiers, `cve` field of `storage.CVE`, and *not* the `id` field.\nFor example, CVE-2021-44832.\nMust be in valid CVE format and not already covered by approved requests.",
                              "items": {
                                "nullable": true,
                                "type": "string"
                              }
                            }
                          },
                          "description": "CVEs represents the list of CVE identifiers in the request."
                        },
                        "updatedDeferralReq": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "expiry": {
                              "nullable": true,
                              "type": "object",
                              "properties": {
                                "expiresWhenFixed": {
                                  "type": "boolean",
                                  "description": "Indicates that this request expires when the associated vulnerability is fixed.\nCannot be used with expires_on.\nOnly applicable to deferral requests."
                                },
                                "expiresOn": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "Indicates the timestamp when this request expires.\nCannot be used with expires_when_fixed.\nMust be a future timestamp.",
                                  "format": "date-time"
                                },
                                "expiryType": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "ExpiryType indicates the type of expiry for the request.\nThis field is under development, DO NOT USE FOR NON-DEVELOPMENT PURPOSES.\n\n - TIME: Request has a fixed expiry time. If used, expires_on must be set.\n - ALL_CVE_FIXABLE: Request expires if all CVEs in the request are fixable.\n - ANY_CVE_FIXABLE: Request expires if any CVE in the request is fixable.",
                                  "default": "TIME",
                                  "enum": [
                                    "TIME",
                                    "ALL_CVE_FIXABLE",
                                    "ANY_CVE_FIXABLE"
                                  ]
                                }
                              },
                              "description": "RequestExpiry defines the expiration configuration for deferral requests.\n\n**Expiry Rules:**\n- Deferral requests must specify expiry (either expires_when_fixed or expires_on)\n- False-positive requests do not have expiry (permanent)\n- Cannot specify both expiry options\n- Expiry type is under development (do not use for non-development purposes)"
                            }
                          },
                          "description": "DeferralRequest represents a request to temporarily defer vulnerability detection.\n\n**Deferral Rules:**\n- Must specify expiry configuration\n- Expiry can be time-based or fix-based\n- Deferrals are temporary and expire automatically"
                        },
                        "deferralUpdate": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "CVEs": {
                              "type": "array",
                              "description": "CVEs to be updated in the deferral request.\nCannot be empty (at least one CVE must remain).",
                              "items": {
                                "nullable": true,
                                "type": "string"
                              }
                            },
                            "expiry": {
                              "nullable": true,
                              "type": "object",
                              "properties": {
                                "expiresWhenFixed": {
                                  "type": "boolean",
                                  "description": "Indicates that this request expires when the associated vulnerability is fixed.\nCannot be used with expires_on.\nOnly applicable to deferral requests."
                                },
                                "expiresOn": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "Indicates the timestamp when this request expires.\nCannot be used with expires_when_fixed.\nMust be a future timestamp.",
                                  "format": "date-time"
                                },
                                "expiryType": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": "ExpiryType indicates the type of expiry for the request.\nThis field is under development, DO NOT USE FOR NON-DEVELOPMENT PURPOSES.\n\n - TIME: Request has a fixed expiry time. If used, expires_on must be set.\n - ALL_CVE_FIXABLE: Request expires if all CVEs in the request are fixable.\n - ANY_CVE_FIXABLE: Request expires if any CVE in the request is fixable.",
                                  "default": "TIME",
                                  "enum": [
                                    "TIME",
                                    "ALL_CVE_FIXABLE",
                                    "ANY_CVE_FIXABLE"
                                  ]
                                }
                              },
                              "description": "RequestExpiry defines the expiration configuration for deferral requests.\n\n**Expiry Rules:**\n- Deferral requests must specify expiry (either expires_when_fixed or expires_on)\n- False-positive requests do not have expiry (permanent)\n- Cannot specify both expiry options\n- Expiry type is under development (do not use for non-development purposes)"
                            }
                          },
                          "description": "DeferralUpdate represents an update to an existing deferral request.\n\n**Update Rules:**\n- Can add or remove CVEs from the request\n- Cannot remove all CVEs (at least one CVE must remain)\n- Can update expiry configuration\n- Creates a new pending update request"
                        },
                        "falsePositiveUpdate": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "CVEs": {
                              "type": "array",
                              "description": "CVEs to be updated in the false-positive request.\nCannot be empty (at least one CVE must remain).",
                              "items": {
                                "nullable": true,
                                "type": "string"
                              }
                            }
                          },
                          "description": "FalsePositiveUpdate represents an update to an existing false-positive request.\n\n**Update Rules:**\n- Can add or remove CVEs from the request\n- Cannot remove all CVEs (at least one CVE must remain)\n- False-positive requests remain permanent (no expiry)"
                        }
                      },
                      "description": "VulnerabilityRequest encapsulates a request such as deferral request and false-positive request.\n\n**Request Lifecycle:**\n- Creation: New request in PENDING state\n- Approval: Request approved and enforced\n- Denial: Request denied and closed\n- Update: Approved request with pending update\n- Expiry: Request expires automatically or manually\n- Undo: Approved request undone and vulnerabilities re-enabled\n\n**Validation Rules:**\n- New requests must not have ID (auto-generated)\n- Must have at least one comment\n- Must have valid CVE format (e.g., \"CVE-2021-1234\")\n- Must have valid scope (image scope or global scope)\n- Cannot create duplicate requests for same CVE-scope combination\n- Deferral requests must specify expiry\n- False-positive requests are permanent (no expiry)\n- New requests cannot start in APPROVED or DENIED state\n\n**Performance Considerations:**\n- Maximum 1000 requests returned per list operation\n- Requests are processed sequentially to prevent race conditions\n- Duplicate prevention checks are performed during creation"
                    }
                  },
                  "description": "UpdateVulnRequestResponse contains the updated request information."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "application/json": {
                "schema": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "nullable": true,
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "@type": {
                            "nullable": true,
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com. As of May 2023, there are no widely used type server\nimplementations and no plans to implement one.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          }
                        },
                        "additionalProperties": {
                          "nullable": true,
                          "type": "object"
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n    // or ...\n    if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n      foo = any.unpack(Foo.getDefaultInstance());\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "x-codegen-request-body-name": "body"
      }
    },
    "/v1/deployments": {
      "get": {
        "tags": [
          "DeploymentService"
        ],
        "summary": "ListDeployments returns the list of deployments.",
        "operationId": "DeploymentService_ListDeployments",
        "parameters": [
          {
            "name": "query",
            "in": "query",
            "schema": {
              "nullable": true,
              "type": "string"
            }
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "pagination.sortOption.field",
            "in": "query",
            "schema": {
              "nullable": true,
              "type": "string"
            }
          },
          {
            "name": "pagination.sortOption.reversed",
            "in": "query",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "pagination.sortOption.aggregateBy.aggrFunc",
            "in": "query",
            "schema": {
              "nullable": true,
              "type": "string",
              "default": "UNSET",
              "enum": [
                "UNSET",
                "COUNT",
                "MIN",
                "MAX"
              ]
            }
          },
          {
            "name": "pagination.sortOption.aggregateBy.distinct",
            "in": "query",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "deployments": {
                      "type": "array",
                      "items": {
                        "title": "Next available tag: 9",
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "id": {
                            "nullable": true,
                            "type": "string"
                          },
                          "hash": {
                            "nullable": true,
                            "type": "string",
                            "format": "uint64"
                          },
                          "name": {
                            "nullable": true,
                            "type": "string"
                          },
                          "cluster": {
                            "nullable": true,
                            "type": "string"
                          },
                          "clusterId": {
                            "nullable": true,
                            "type": "string"
                          },
                          "namespace": {
                            "nullable": true,
                            "type": "string"
                          },
                          "created": {
                            "nullable": true,
                            "type": "string",
                            "format": "date-time"
                          },
                          "priority": {
                            "nullable": true,
                            "type": "string",
                            "format": "int64"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "application/json": {
                "schema": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "nullable": true,
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "@type": {
                            "nullable": true,
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com. As of May 2023, there are no widely used type server\nimplementations and no plans to implement one.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          }
                        },
                        "additionalProperties": {
                          "nullable": true,
                          "type": "object"
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n    // or ...\n    if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n      foo = any.unpack(Foo.getDefaultInstance());\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/v1/namespaces": {
      "get": {
        "tags": [
          "NamespaceService"
        ],
        "operationId": "NamespaceService_GetNamespaces",
        "parameters": [
          {
            "name": "query.query",
            "in": "query",
            "schema": {
              "nullable": true,
              "type": "string"
            }
          },
          {
            "name": "query.pagination.limit",
            "in": "query",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "query.pagination.offset",
            "in": "query",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "query.pagination.sortOption.field",
            "in": "query",
            "schema": {
              "nullable": true,
              "type": "string"
            }
          },
          {
            "name": "query.pagination.sortOption.reversed",
            "in": "query",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "query.pagination.sortOption.aggregateBy.aggrFunc",
            "in": "query",
            "schema": {
              "nullable": true,
              "type": "string",
              "default": "UNSET",
              "enum": [
                "UNSET",
                "COUNT",
                "MIN",
                "MAX"
              ]
            }
          },
          {
            "name": "query.pagination.sortOption.aggregateBy.distinct",
            "in": "query",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "namespaces": {
                      "type": "array",
                      "items": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "metadata": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "id": {
                                "nullable": true,
                                "type": "string"
                              },
                              "name": {
                                "nullable": true,
                                "type": "string"
                              },
                              "clusterId": {
                                "nullable": true,
                                "type": "string"
                              },
                              "clusterName": {
                                "nullable": true,
                                "type": "string"
                              },
                              "labels": {
                                "nullable": true,
                                "type": "object",
                                "additionalProperties": {
                                  "nullable": true,
                                  "type": "string"
                                }
                              },
                              "creationTime": {
                                "nullable": true,
                                "type": "string",
                                "format": "date-time"
                              },
                              "priority": {
                                "nullable": true,
                                "type": "string",
                                "format": "int64"
                              },
                              "annotations": {
                                "nullable": true,
                                "type": "object",
                                "additionalProperties": {
                                  "nullable": true,
                                  "type": "string"
                                }
                              }
                            }
                          },
                          "numDeployments": {
                            "type": "integer",
                            "format": "int32"
                          },
                          "numSecrets": {
                            "type": "integer",
                            "format": "int32"
                          },
                          "numNetworkPolicies": {
                            "type": "integer",
                            "format": "int32"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "application/json": {
                "schema": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "nullable": true,
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "@type": {
                            "nullable": true,
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com. As of May 2023, there are no widely used type server\nimplementations and no plans to implement one.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          }
                        },
                        "additionalProperties": {
                          "nullable": true,
                          "type": "object"
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n    // or ...\n    if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n      foo = any.unpack(Foo.getDefaultInstance());\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/v1/deploymentswithrisk/{id}": {
      "get": {
        "tags": [
          "DeploymentService"
        ],
        "summary": "GetDeploymentWithRisk returns a deployment and its risk given its ID.",
        "operationId": "DeploymentService_GetDeploymentWithRisk",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "nullable": true,
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "deployment": {
                      "title": "Next available tag: 36",
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "id": {
                          "nullable": true,
                          "type": "string"
                        },
                        "name": {
                          "nullable": true,
                          "type": "string"
                        },
                        "hash": {
                          "nullable": true,
                          "type": "string",
                          "format": "uint64"
                        },
                        "type": {
                          "nullable": true,
                          "type": "string"
                        },
                        "namespace": {
                          "nullable": true,
                          "type": "string"
                        },
                        "namespaceId": {
                          "nullable": true,
                          "type": "string"
                        },
                        "orchestratorComponent": {
                          "type": "boolean"
                        },
                        "replicas": {
                          "nullable": true,
                          "type": "string",
                          "format": "int64"
                        },
                        "labels": {
                          "nullable": true,
                          "type": "object",
                          "additionalProperties": {
                            "nullable": true,
                            "type": "string"
                          }
                        },
                        "podLabels": {
                          "nullable": true,
                          "type": "object",
                          "additionalProperties": {
                            "nullable": true,
                            "type": "string"
                          }
                        },
                        "labelSelector": {
                          "title": "Label selector components are joined with logical AND, see\n    https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/",
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "matchLabels": {
                              "nullable": true,
                              "type": "object",
                              "additionalProperties": {
                                "nullable": true,
                                "type": "string"
                              },
                              "description": "This is actually a oneof, but we can't make it one due to backwards\ncompatibility constraints."
                            },
                            "requirements": {
                              "type": "array",
                              "items": {
                                "title": "Next available tag: 4",
                                "nullable": true,
                                "type": "object",
                                "properties": {
                                  "key": {
                                    "nullable": true,
                                    "type": "string"
                                  },
                                  "op": {
                                    "nullable": true,
                                    "type": "string",
                                    "default": "UNKNOWN",
                                    "enum": [
                                      "UNKNOWN",
                                      "IN",
                                      "NOT_IN",
                                      "EXISTS",
                                      "NOT_EXISTS"
                                    ]
                                  },
                                  "values": {
                                    "type": "array",
                                    "items": {
                                      "nullable": true,
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            }
                          },
                          "description": "Next available tag: 3"
                        },
                        "created": {
                          "nullable": true,
                          "type": "string",
                          "format": "date-time"
                        },
                        "clusterId": {
                          "nullable": true,
                          "type": "string"
                        },
                        "clusterName": {
                          "nullable": true,
                          "type": "string"
                        },
                        "containers": {
                          "type": "array",
                          "items": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "id": {
                                "nullable": true,
                                "type": "string"
                              },
                              "config": {
                                "nullable": true,
                                "type": "object",
                                "properties": {
                                  "env": {
                                    "type": "array",
                                    "items": {
                                      "nullable": true,
                                      "type": "object",
                                      "properties": {
                                        "key": {
                                          "nullable": true,
                                          "type": "string"
                                        },
                                        "value": {
                                          "nullable": true,
                                          "type": "string"
                                        },
                                        "envVarSource": {
                                          "title": "For any update to EnvVarSource, please also update 'ui/src/messages/common.js'",
                                          "nullable": true,
                                          "type": "string",
                                          "default": "UNSET",
                                          "enum": [
                                            "UNSET",
                                            "RAW",
                                            "SECRET_KEY",
                                            "CONFIG_MAP_KEY",
                                            "FIELD",
                                            "RESOURCE_FIELD",
                                            "UNKNOWN"
                                          ]
                                        }
                                      }
                                    }
                                  },
                                  "command": {
                                    "type": "array",
                                    "items": {
                                      "nullable": true,
                                      "type": "string"
                                    }
                                  },
                                  "args": {
                                    "type": "array",
                                    "items": {
                                      "nullable": true,
                                      "type": "string"
                                    }
                                  },
                                  "directory": {
                                    "nullable": true,
                                    "type": "string"
                                  },
                                  "user": {
                                    "nullable": true,
                                    "type": "string"
                                  },
                                  "uid": {
                                    "nullable": true,
                                    "type": "string",
                                    "format": "int64"
                                  },
                                  "appArmorProfile": {
                                    "nullable": true,
                                    "type": "string"
                                  }
                                }
                              },
                              "image": {
                                "title": "Next tag: 13",
                                "nullable": true,
                                "type": "object",
                                "properties": {
                                  "id": {
                                    "nullable": true,
                                    "type": "string"
                                  },
                                  "name": {
                                    "nullable": true,
                                    "type": "object",
                                    "properties": {
                                      "registry": {
                                        "nullable": true,
                                        "type": "string"
                                      },
                                      "remote": {
                                        "nullable": true,
                                        "type": "string"
                                      },
                                      "tag": {
                                        "nullable": true,
                                        "type": "string"
                                      },
                                      "fullName": {
                                        "nullable": true,
                                        "type": "string"
                                      }
                                    }
                                  },
                                  "notPullable": {
                                    "type": "boolean"
                                  },
                                  "isClusterLocal": {
                                    "type": "boolean"
                                  },
                                  "idV2": {
                                    "nullable": true,
                                    "type": "string"
                                  }
                                }
                              },
                              "securityContext": {
                                "nullable": true,
                                "type": "object",
                                "properties": {
                                  "privileged": {
                                    "type": "boolean"
                                  },
                                  "selinux": {
                                    "nullable": true,
                                    "type": "object",
                                    "properties": {
                                      "user": {
                                        "nullable": true,
                                        "type": "string"
                                      },
                                      "role": {
                                        "nullable": true,
                                        "type": "string"
                                      },
                                      "type": {
                                        "nullable": true,
                                        "type": "string"
                                      },
                                      "level": {
                                        "nullable": true,
                                        "type": "string"
                                      }
                                    }
                                  },
                                  "dropCapabilities": {
                                    "type": "array",
                                    "items": {
                                      "nullable": true,
                                      "type": "string"
                                    }
                                  },
                                  "addCapabilities": {
                                    "type": "array",
                                    "items": {
                                      "nullable": true,
                                      "type": "string"
                                    }
                                  },
                                  "readOnlyRootFilesystem": {
                                    "type": "boolean"
                                  },
                                  "seccompProfile": {
                                    "nullable": true,
                                    "type": "object",
                                    "properties": {
                                      "type": {
                                        "nullable": true,
                                        "type": "string",
                                        "default": "UNCONFINED",
                                        "enum": [
                                          "UNCONFINED",
                                          "RUNTIME_DEFAULT",
                                          "LOCALHOST"
                                        ]
                                      },
                                      "localhostProfile": {
                                        "nullable": true,
                                        "type": "string"
                                      }
                                    }
                                  },
                                  "allowPrivilegeEscalation": {
                                    "type": "boolean"
                                  }
                                }
                              },
                              "volumes": {
                                "type": "array",
                                "items": {
                                  "nullable": true,
                                  "type": "object",
                                  "properties": {
                                    "name": {
                                      "nullable": true,
                                      "type": "string"
                                    },
                                    "source": {
                                      "nullable": true,
                                      "type": "string"
                                    },
                                    "destination": {
                                      "nullable": true,
                                      "type": "string"
                                    },
                                    "readOnly": {
                                      "type": "boolean"
                                    },
                                    "type": {
                                      "nullable": true,
                                      "type": "string"
                                    },
                                    "mountPropagation": {
                                      "nullable": true,
                                      "type": "string",
                                      "default": "NONE",
                                      "enum": [
                                        "NONE",
                                        "HOST_TO_CONTAINER",
                                        "BIDIRECTIONAL"
                                      ]
                                    }
                                  }
                                }
                              },
                              "ports": {
                                "title": "Policies use the port config on the top-level deployment.",
                                "type": "array",
                                "items": {
                                  "title": "Next Available Tag: 6",
                                  "nullable": true,
                                  "type": "object",
                                  "properties": {
                                    "name": {
                                      "nullable": true,
                                      "type": "string"
                                    },
                                    "containerPort": {
                                      "type": "integer",
                                      "format": "int32"
                                    },
                                    "protocol": {
                                      "nullable": true,
                                      "type": "string"
                                    },
                                    "exposure": {
                                      "nullable": true,
                                      "type": "string",
                                      "default": "UNSET",
                                      "enum": [
                                        "UNSET",
                                        "EXTERNAL",
                                        "NODE",
                                        "INTERNAL",
                                        "HOST",
                                        "ROUTE"
                                      ]
                                    },
                                    "exposedPort": {
                                      "type": "integer",
                                      "format": "int32"
                                    },
                                    "exposureInfos": {
                                      "type": "array",
                                      "items": {
                                        "nullable": true,
                                        "type": "object",
                                        "properties": {
                                          "level": {
                                            "nullable": true,
                                            "type": "string",
                                            "default": "UNSET",
                                            "enum": [
                                              "UNSET",
                                              "EXTERNAL",
                                              "NODE",
                                              "INTERNAL",
                                              "HOST",
                                              "ROUTE"
                                            ]
                                          },
                                          "serviceName": {
                                            "title": "only set if level is not HOST",
                                            "nullable": true,
                                            "type": "string"
                                          },
                                          "serviceId": {
                                            "nullable": true,
                                            "type": "string"
                                          },
                                          "serviceClusterIp": {
                                            "nullable": true,
                                            "type": "string"
                                          },
                                          "servicePort": {
                                            "type": "integer",
                                            "format": "int32"
                                          },
                                          "nodePort": {
                                            "title": "only set if level is HOST, NODE, EXTERNAL or ROUTE",
                                            "type": "integer",
                                            "format": "int32"
                                          },
                                          "externalIps": {
                                            "title": "only set if level is EXTERNAL",
                                            "type": "array",
                                            "items": {
                                              "nullable": true,
                                              "type": "string"
                                            }
                                          },
                                          "externalHostnames": {
                                            "title": "only set if level is EXTERNAL or ROUTE",
                                            "type": "array",
                                            "items": {
                                              "nullable": true,
                                              "type": "string"
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              },
                              "secrets": {
                                "type": "array",
                                "items": {
                                  "nullable": true,
                                  "type": "object",
                                  "properties": {
                                    "name": {
                                      "nullable": true,
                                      "type": "string"
                                    },
                                    "path": {
                                      "nullable": true,
                                      "type": "string"
                                    }
                                  }
                                }
                              },
                              "resources": {
                                "nullable": true,
                                "type": "object",
                                "properties": {
                                  "cpuCoresRequest": {
                                    "type": "number",
                                    "format": "float"
                                  },
                                  "cpuCoresLimit": {
                                    "type": "number",
                                    "format": "float"
                                  },
                                  "memoryMbRequest": {
                                    "type": "number",
                                    "format": "float"
                                  },
                                  "memoryMbLimit": {
                                    "type": "number",
                                    "format": "float"
                                  }
                                }
                              },
                              "name": {
                                "nullable": true,
                                "type": "string"
                              },
                              "livenessProbe": {
                                "nullable": true,
                                "type": "object",
                                "properties": {
                                  "defined": {
                                    "type": "boolean"
                                  }
                                }
                              },
                              "readinessProbe": {
                                "nullable": true,
                                "type": "object",
                                "properties": {
                                  "defined": {
                                    "type": "boolean"
                                  }
                                }
                              }
                            }
                          }
                        },
                        "annotations": {
                          "nullable": true,
                          "type": "object",
                          "additionalProperties": {
                            "nullable": true,
                            "type": "string"
                          }
                        },
                        "priority": {
                          "nullable": true,
                          "type": "string",
                          "format": "int64"
                        },
                        "inactive": {
                          "type": "boolean"
                        },
                        "imagePullSecrets": {
                          "type": "array",
                          "items": {
                            "nullable": true,
                            "type": "string"
                          }
                        },
                        "serviceAccount": {
                          "nullable": true,
                          "type": "string"
                        },
                        "serviceAccountPermissionLevel": {
                          "title": "For any update to PermissionLevel, also update:\n- pkg/searchbasedpolicies/builders/k8s_rbac.go\n- ui/src/messages/common.js",
                          "nullable": true,
                          "type": "string",
                          "default": "UNSET",
                          "enum": [
                            "UNSET",
                            "NONE",
                            "DEFAULT",
                            "ELEVATED_IN_NAMESPACE",
                            "ELEVATED_CLUSTER_WIDE",
                            "CLUSTER_ADMIN"
                          ]
                        },
                        "automountServiceAccountToken": {
                          "type": "boolean"
                        },
                        "hostNetwork": {
                          "type": "boolean"
                        },
                        "hostPid": {
                          "type": "boolean"
                        },
                        "hostIpc": {
                          "type": "boolean"
                        },
                        "runtimeClass": {
                          "nullable": true,
                          "type": "string"
                        },
                        "tolerations": {
                          "type": "array",
                          "items": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "key": {
                                "nullable": true,
                                "type": "string"
                              },
                              "operator": {
                                "nullable": true,
                                "type": "string",
                                "default": "TOLERATION_OPERATION_UNKNOWN",
                                "enum": [
                                  "TOLERATION_OPERATION_UNKNOWN",
                                  "TOLERATION_OPERATOR_EXISTS",
                                  "TOLERATION_OPERATOR_EQUAL"
                                ]
                              },
                              "value": {
                                "nullable": true,
                                "type": "string"
                              },
                              "taintEffect": {
                                "nullable": true,
                                "type": "string",
                                "default": "UNKNOWN_TAINT_EFFECT",
                                "enum": [
                                  "UNKNOWN_TAINT_EFFECT",
                                  "NO_SCHEDULE_TAINT_EFFECT",
                                  "PREFER_NO_SCHEDULE_TAINT_EFFECT",
                                  "NO_EXECUTE_TAINT_EFFECT"
                                ]
                              }
                            }
                          }
                        },
                        "ports": {
                          "type": "array",
                          "items": {
                            "title": "Next Available Tag: 6",
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "name": {
                                "nullable": true,
                                "type": "string"
                              },
                              "containerPort": {
                                "type": "integer",
                                "format": "int32"
                              },
                              "protocol": {
                                "nullable": true,
                                "type": "string"
                              },
                              "exposure": {
                                "nullable": true,
                                "type": "string",
                                "default": "UNSET",
                                "enum": [
                                  "UNSET",
                                  "EXTERNAL",
                                  "NODE",
                                  "INTERNAL",
                                  "HOST",
                                  "ROUTE"
                                ]
                              },
                              "exposedPort": {
                                "type": "integer",
                                "format": "int32"
                              },
                              "exposureInfos": {
                                "type": "array",
                                "items": {
                                  "nullable": true,
                                  "type": "object",
                                  "properties": {
                                    "level": {
                                      "nullable": true,
                                      "type": "string",
                                      "default": "UNSET",
                                      "enum": [
                                        "UNSET",
                                        "EXTERNAL",
                                        "NODE",
                                        "INTERNAL",
                                        "HOST",
                                        "ROUTE"
                                      ]
                                    },
                                    "serviceName": {
                                      "title": "only set if level is not HOST",
                                      "nullable": true,
                                      "type": "string"
                                    },
                                    "serviceId": {
                                      "nullable": true,
                                      "type": "string"
                                    },
                                    "serviceClusterIp": {
                                      "nullable": true,
                                      "type": "string"
                                    },
                                    "servicePort": {
                                      "type": "integer",
                                      "format": "int32"
                                    },
                                    "nodePort": {
                                      "title": "only set if level is HOST, NODE, EXTERNAL or ROUTE",
                                      "type": "integer",
                                      "format": "int32"
                                    },
                                    "externalIps": {
                                      "title": "only set if level is EXTERNAL",
                                      "type": "array",
                                      "items": {
                                        "nullable": true,
                                        "type": "string"
                                      }
                                    },
                                    "externalHostnames": {
                                      "title": "only set if level is EXTERNAL or ROUTE",
                                      "type": "array",
                                      "items": {
                                        "nullable": true,
                                        "type": "string"
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        },
                        "stateTimestamp": {
                          "title": "Internal use only",
                          "nullable": true,
                          "type": "string",
                          "format": "int64"
                        },
                        "riskScore": {
                          "type": "number",
                          "format": "float"
                        },
                        "platformComponent": {
                          "type": "boolean"
                        }
                      }
                    },
                    "risk": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "id": {
                          "nullable": true,
                          "type": "string"
                        },
                        "subject": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "id": {
                              "nullable": true,
                              "type": "string"
                            },
                            "namespace": {
                              "nullable": true,
                              "type": "string"
                            },
                            "clusterId": {
                              "nullable": true,
                              "type": "string"
                            },
                            "type": {
                              "title": "Next tag: 9",
                              "nullable": true,
                              "type": "string",
                              "default": "UNKNOWN",
                              "enum": [
                                "UNKNOWN",
                                "DEPLOYMENT",
                                "NAMESPACE",
                                "CLUSTER",
                                "NODE",
                                "NODE_COMPONENT",
                                "IMAGE",
                                "IMAGE_COMPONENT",
                                "SERVICEACCOUNT"
                              ]
                            }
                          }
                        },
                        "score": {
                          "type": "number",
                          "format": "float"
                        },
                        "results": {
                          "type": "array",
                          "items": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "name": {
                                "nullable": true,
                                "type": "string"
                              },
                              "factors": {
                                "type": "array",
                                "items": {
                                  "nullable": true,
                                  "type": "object",
                                  "properties": {
                                    "message": {
                                      "nullable": true,
                                      "type": "string"
                                    },
                                    "url": {
                                      "nullable": true,
                                      "type": "string"
                                    }
                                  }
                                }
                              },
                              "score": {
                                "type": "number",
                                "format": "float"
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "application/json": {
                "schema": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "nullable": true,
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "@type": {
                            "nullable": true,
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com. As of May 2023, there are no widely used type server\nimplementations and no plans to implement one.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          }
                        },
                        "additionalProperties": {
                          "nullable": true,
                          "type": "object"
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n    // or ...\n    if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n      foo = any.unpack(Foo.getDefaultInstance());\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/v1/policies": {
      "get": {
        "tags": [
          "PolicyService"
        ],
        "summary": "ListPolicies returns the list of policies.",
        "operationId": "PolicyService_ListPolicies",
        "parameters": [
          {
            "name": "query",
            "in": "query",
            "schema": {
              "nullable": true,
              "type": "string"
            }
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "pagination.sortOption.field",
            "in": "query",
            "schema": {
              "nullable": true,
              "type": "string"
            }
          },
          {
            "name": "pagination.sortOption.reversed",
            "in": "query",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "pagination.sortOption.aggregateBy.aggrFunc",
            "in": "query",
            "schema": {
              "nullable": true,
              "type": "string",
              "default": "UNSET",
              "enum": [
                "UNSET",
                "COUNT",
                "MIN",
                "MAX"
              ]
            }
          },
          {
            "name": "pagination.sortOption.aggregateBy.distinct",
            "in": "query",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "policies": {
                      "type": "array",
                      "items": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "id": {
                            "nullable": true,
                            "type": "string"
                          },
                          "name": {
                            "nullable": true,
                            "type": "string"
                          },
                          "description": {
                            "nullable": true,
                            "type": "string"
                          },
                          "severity": {
                            "nullable": true,
                            "type": "string",
                            "default": "UNSET_SEVERITY",
                            "enum": [
                              "UNSET_SEVERITY",
                              "LOW_SEVERITY",
                              "MEDIUM_SEVERITY",
                              "HIGH_SEVERITY",
                              "CRITICAL_SEVERITY"
                            ]
                          },
                          "disabled": {
                            "type": "boolean"
                          },
                          "lifecycleStages": {
                            "type": "array",
                            "items": {
                              "nullable": true,
                              "type": "string",
                              "default": "DEPLOY",
                              "enum": [
                                "DEPLOY",
                                "BUILD",
                                "RUNTIME"
                              ]
                            }
                          },
                          "notifiers": {
                            "type": "array",
                            "items": {
                              "nullable": true,
                              "type": "string"
                            }
                          },
                          "lastUpdated": {
                            "nullable": true,
                            "type": "string",
                            "format": "date-time"
                          },
                          "eventSource": {
                            "nullable": true,
                            "type": "string",
                            "default": "NOT_APPLICABLE",
                            "enum": [
                              "NOT_APPLICABLE",
                              "DEPLOYMENT_EVENT",
                              "AUDIT_LOG_EVENT"
                            ]
                          },
                          "isDefault": {
                            "type": "boolean"
                          },
                          "source": {
                            "nullable": true,
                            "type": "string",
                            "default": "IMPERATIVE",
                            "enum": [
                              "IMPERATIVE",
                              "DECLARATIVE"
                            ]
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "application/json": {
                "schema": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "nullable": true,
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "@type": {
                            "nullable": true,
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com. As of May 2023, there are no widely used type server\nimplementations and no plans to implement one.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          }
                        },
                        "additionalProperties": {
                          "nullable": true,
                          "type": "object"
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n    // or ...\n    if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n      foo = any.unpack(Foo.getDefaultInstance());\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "PolicyService"
        ],
        "summary": "PostPolicy creates a new security policy in the system.",
        "description": "This endpoint creates a new policy with comprehensive validation. The policy will be\nvalidated before creation and can be tested using the dry-run functionality.\n\n**Key Constraints:**\n- Policy ID must be empty (will be auto-generated)\n- Policy name must be unique across all policies\n- Policy name must be 5-128 characters with no newlines or dollar signs\n- Description must not exceed 800 characters and cannot contain dollar signs\n- At least one lifecycle stage must be specified\n- At least one category must be specified\n- Severity must be set (not UNSET_SEVERITY)\n- Policy sections must contain valid criteria for the specified lifecycle stages\n- Runtime policies must contain at least one runtime criterion\n- Audit log event policies require both KubeResource and KubeAPIVerb criteria\n- Enforcement actions must be compatible with lifecycle stages\n- Notifier IDs must reference existing notifiers\n- Scope and exclusion configurations must be valid\n\n**Validation Levels:**\n- Basic validation: Always performed (field requirements, syntax, etc.)\n- Strict validation: When enableStrictValidation=true, includes additional checks:\n  - Environment variable source restrictions (ROX-5208)\n  - Dockerfile FROM line restrictions\n  - Enhanced field validation\n\n**Lifecycle Stage Requirements:**\n- BUILD: Must contain image-related criteria only\n- DEPLOY: Cannot contain runtime criteria\n- RUNTIME: Must contain at least one runtime criterion (process, network, audit, k8s events)\n\n**Event Source Rules:**\n- Runtime policies with NOT_APPLICABLE event source are invalid\n- Build/Deploy policies with non-NOT_APPLICABLE event source are invalid\n- Audit log event policies cannot have enforcement actions\n- Audit log event policies cannot use label-based scopes or exclusions\n\nReturns the created policy with generated ID, timestamps, and metadata.",
        "operationId": "PolicyService_PostPolicy",
        "parameters": [
          {
            "name": "enableStrictValidation",
            "in": "query",
            "description": "When true, performs additional validation checks including:\n- Environment variable source restrictions (ROX-5208)\n  - Only UNSET, RAW, UNKNOWN sources allowed for value checking\n  - SECRET_KEY, CONFIG_MAP_KEY, FIELD, RESOURCE_FIELD sources restricted\n- Dockerfile FROM line restrictions\n- Enhanced field validation and cross-field consistency checks\n- Stricter regex validation for field values\n\n**Environment Variable Restrictions (when enabled):**\n- Valid: \"UNSET=key=value\", \"RAW=key=value\", \"UNKNOWN=key=value\"\n- Valid: \"SECRET_KEY=key=\", \"CONFIG_MAP_KEY=key=\" (empty value only)\n- Invalid: \"SECRET_KEY=key=value\", \"CONFIG_MAP_KEY=key=value\" (with value)\n\nRecommended for development/testing environments. Defaults to false in production.\nWhen enabled, provides detailed error messages for validation failures.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "requestBody": {
          "description": "The policy configuration to create. Must include all required fields and valid criteria.\n\n**Critical Constraints:**\n- id field MUST be empty (will be auto-generated)\n- name must be unique across all policies\n- policyVersion must be \"1.1\"\n- lifecycleStages must be compatible with policySections criteria\n- enforcement actions must be compatible with lifecycle stages\n- notifier IDs must reference existing notifiers\n- scope and exclusion configurations must be valid\n\n**Policy Section Requirements:**\n- Each section must have a unique sectionName\n- Each policy group must have a valid fieldName and at least one value\n- Field names must be valid for the specified lifecycle stages\n- Values must match the expected format for each field type\n- Boolean operators must be compatible with field requirements\n- Negation must be allowed for the field type\n\n**Runtime Policy Requirements:**\n- Must contain at least one runtime criterion (process, network, audit, k8s events)\n- Runtime criteria must be in separate sections\n- Audit log policies require both KubeResource and KubeAPIVerb criteria\n\n**Enforcement Action Compatibility:**\n- FAIL_BUILD_ENFORCEMENT: BUILD lifecycle only\n- SCALE_TO_ZERO_ENFORCEMENT: DEPLOY lifecycle only\n- UNSATISFIABLE_NODE_CONSTRAINT_ENFORCEMENT: DEPLOY lifecycle only\n- KILL_POD_ENFORCEMENT: RUNTIME lifecycle only\n- FAIL_KUBE_REQUEST_ENFORCEMENT: RUNTIME lifecycle only\n- FAIL_DEPLOYMENT_CREATE_ENFORCEMENT: DEPLOY lifecycle only\n- FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT: DEPLOY lifecycle only",
          "content": {
            "application/json": {
              "schema": {
                "title": "Next tag: 28",
                "nullable": true,
                "type": "object",
                "properties": {
                  "id": {
                    "title": "Unique identifier generated by the system. Must be empty for new policies.\nFormat: UUID v4, auto-generated during creation",
                    "nullable": true,
                    "type": "string"
                  },
                  "name": {
                    "title": "Name of the policy. Must be unique across all policies.\nValidation: 5-128 characters, no newlines or dollar signs\nPattern: ^[^\\n\\r\\$]{5,128}$",
                    "nullable": true,
                    "type": "string"
                  },
                  "description": {
                    "title": "Free-form text description of this policy.\nValidation: Max 800 characters, no dollar signs\nPattern: ^[^\\$]{0,800}$",
                    "nullable": true,
                    "type": "string"
                  },
                  "rationale": {
                    "nullable": true,
                    "type": "string",
                    "description": "Business justification for why this policy exists.\nUsed for compliance and audit purposes."
                  },
                  "remediation": {
                    "nullable": true,
                    "type": "string",
                    "description": "Describes how to remediate a violation of this policy.\nShould be actionable and specific to the policy type."
                  },
                  "disabled": {
                    "title": "Toggles whether or not this policy will be executing and actively firing alerts.\nDefault: false",
                    "type": "boolean"
                  },
                  "categories": {
                    "title": "List of categories that this policy falls under. Category names must already exist in Central.\nValidation: At least one category required, no duplicates",
                    "type": "array",
                    "items": {
                      "nullable": true,
                      "type": "string"
                    }
                  },
                  "lifecycleStages": {
                    "title": "Describes which policy lifecycle stages this policy applies to. Choices are DEPLOY, BUILD, and RUNTIME.\nValidation: At least one stage required\n- BUILD: Must contain image-related criteria only\n- DEPLOY: Cannot contain runtime criteria\n- RUNTIME: Must contain at least one runtime criterion",
                    "type": "array",
                    "items": {
                      "nullable": true,
                      "type": "string",
                      "default": "DEPLOY",
                      "enum": [
                        "DEPLOY",
                        "BUILD",
                        "RUNTIME"
                      ]
                    }
                  },
                  "eventSource": {
                    "nullable": true,
                    "type": "string",
                    "default": "NOT_APPLICABLE",
                    "enum": [
                      "NOT_APPLICABLE",
                      "DEPLOYMENT_EVENT",
                      "AUDIT_LOG_EVENT"
                    ]
                  },
                  "exclusions": {
                    "title": "Define deployments or images that should be excluded from this policy.\nValidation:\n- Deployment exclusions: Only valid for DEPLOY and RUNTIME lifecycles\n- Image exclusions: Only valid for BUILD lifecycle\n- Must have at least one criteria (name, scope, or image)",
                    "type": "array",
                    "items": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "name": {
                          "nullable": true,
                          "type": "string",
                          "description": "Name of the exclusion. Used for identification and documentation."
                        },
                        "deployment": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "name": {
                              "title": "Name of the deployment to exclude. Optional if scope is provided.\nValidation: Must be provided if scope is not specified",
                              "nullable": true,
                              "type": "string"
                            },
                            "scope": {
                              "nullable": true,
                              "type": "object",
                              "properties": {
                                "cluster": {
                                  "nullable": true,
                                  "type": "string"
                                },
                                "namespace": {
                                  "nullable": true,
                                  "type": "string"
                                },
                                "label": {
                                  "nullable": true,
                                  "type": "object",
                                  "properties": {
                                    "key": {
                                      "nullable": true,
                                      "type": "string"
                                    },
                                    "value": {
                                      "nullable": true,
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            }
                          }
                        },
                        "image": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "name": {
                              "title": "Name of the image to exclude.\nValidation: Must be non-empty",
                              "nullable": true,
                              "type": "string"
                            }
                          }
                        },
                        "expiration": {
                          "nullable": true,
                          "type": "string",
                          "description": "Expiration timestamp for this exclusion.\nWhen expired, the exclusion is automatically removed.",
                          "format": "date-time"
                        }
                      }
                    }
                  },
                  "scope": {
                    "title": "Defines clusters, namespaces, and deployments that should be included in this policy.\nNo scopes defined includes everything.\nValidation: Must have at least one field populated (cluster, namespace, or label)",
                    "type": "array",
                    "items": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "cluster": {
                          "nullable": true,
                          "type": "string"
                        },
                        "namespace": {
                          "nullable": true,
                          "type": "string"
                        },
                        "label": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "key": {
                              "nullable": true,
                              "type": "string"
                            },
                            "value": {
                              "nullable": true,
                              "type": "string"
                            }
                          }
                        }
                      }
                    }
                  },
                  "severity": {
                    "nullable": true,
                    "type": "string",
                    "default": "UNSET_SEVERITY",
                    "enum": [
                      "UNSET_SEVERITY",
                      "LOW_SEVERITY",
                      "MEDIUM_SEVERITY",
                      "HIGH_SEVERITY",
                      "CRITICAL_SEVERITY"
                    ]
                  },
                  "enforcementActions": {
                    "title": "Lists the enforcement actions to take when a violation from this policy is identified.\nValidation: Must be compatible with lifecycle stages\n- FAIL_BUILD_ENFORCEMENT: BUILD lifecycle only\n- SCALE_TO_ZERO_ENFORCEMENT: DEPLOY lifecycle only\n- UNSATISFIABLE_NODE_CONSTRAINT_ENFORCEMENT: DEPLOY lifecycle only\n- KILL_POD_ENFORCEMENT: RUNTIME lifecycle only\n- FAIL_KUBE_REQUEST_ENFORCEMENT: RUNTIME lifecycle only\n- FAIL_DEPLOYMENT_CREATE_ENFORCEMENT: DEPLOY lifecycle only\n- FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT: DEPLOY lifecycle only\n- Audit log policies: No enforcement actions allowed",
                    "type": "array",
                    "items": {
                      "nullable": true,
                      "type": "string",
                      "description": " - FAIL_KUBE_REQUEST_ENFORCEMENT: FAIL_KUBE_REQUEST_ENFORCEMENT takes effect only if admission control webhook is enabled to listen on exec and port-forward events.\n - FAIL_DEPLOYMENT_CREATE_ENFORCEMENT: FAIL_DEPLOYMENT_CREATE_ENFORCEMENT takes effect only if admission control webhook is configured to enforce on object creates.\n - FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT: FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT takes effect only if admission control webhook is configured to enforce on object updates.",
                      "default": "UNSET_ENFORCEMENT",
                      "enum": [
                        "UNSET_ENFORCEMENT",
                        "SCALE_TO_ZERO_ENFORCEMENT",
                        "UNSATISFIABLE_NODE_CONSTRAINT_ENFORCEMENT",
                        "KILL_POD_ENFORCEMENT",
                        "FAIL_BUILD_ENFORCEMENT",
                        "FAIL_KUBE_REQUEST_ENFORCEMENT",
                        "FAIL_DEPLOYMENT_CREATE_ENFORCEMENT",
                        "FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT"
                      ]
                    }
                  },
                  "notifiers": {
                    "title": "List of IDs of the notifiers that should be triggered when a violation from this policy is identified.\nIDs should be in the form of a UUID and are found through the Central API.\nValidation: All notifier IDs must reference existing notifiers",
                    "type": "array",
                    "items": {
                      "nullable": true,
                      "type": "string"
                    }
                  },
                  "lastUpdated": {
                    "nullable": true,
                    "type": "string",
                    "description": "Timestamp when the policy was last updated. Auto-generated during creation/update.",
                    "format": "date-time"
                  },
                  "SORTName": {
                    "nullable": true,
                    "type": "string",
                    "description": "For internal use only."
                  },
                  "SORTLifecycleStage": {
                    "nullable": true,
                    "type": "string",
                    "description": "For internal use only."
                  },
                  "SORTEnforcement": {
                    "type": "boolean",
                    "description": "For internal use only."
                  },
                  "policyVersion": {
                    "title": "Policy version. Must be \"1.1\" (current supported version).\nValidation: Only version 1.1 is supported",
                    "nullable": true,
                    "type": "string"
                  },
                  "policySections": {
                    "title": "PolicySections define the violation criteria for this policy.\nValidation Requirements:\n- Each section must have a unique sectionName\n- Each policy group must have a valid fieldName and at least one value\n- Field names must be valid for the specified lifecycle stages\n- Values must match the expected format for each field type\n- Boolean operators must be compatible with field requirements\n- Negation must be allowed for the field type\n- Runtime policies must contain at least one runtime criterion\n- Runtime criteria must be in separate sections\n- Audit log policies require both KubeResource and KubeAPIVerb criteria",
                    "type": "array",
                    "items": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "sectionName": {
                          "nullable": true,
                          "type": "string",
                          "description": "Name of the policy section. Must be unique within the policy.\nUsed for organizing policy criteria into logical groups."
                        },
                        "policyGroups": {
                          "title": "The set of policy groups that make up this section. Each group can be considered an individual criterion.\nValidation Requirements:\n- Each group must have a valid fieldName and at least one value\n- Field names must be valid for the specified lifecycle stages\n- Values must match the expected format for each field type\n- Boolean operators must be compatible with field requirements\n- Negation must be allowed for the field type\n- Runtime criteria must be in separate sections\n- Audit log policies require both KubeResource and KubeAPIVerb criteria",
                          "type": "array",
                          "items": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "fieldName": {
                                "title": "Defines which field on a deployment or image this PolicyGroup evaluates.\nSee https://docs.openshift.com/acs/operating/manage-security-policies.html#policy-criteria_manage-security-policies for a complete list of possible values.\nValidation Requirements:\n- Must be a valid field name for the specified lifecycle stages\n- Field must support the specified boolean operator\n- Field must allow negation if negate=true\n- Field must support multiple values if more than one value is provided\n- Some fields have special restrictions (e.g., ImageSignatureVerifiedBy cannot use AND operator)",
                                "nullable": true,
                                "type": "string"
                              },
                              "booleanOperator": {
                                "nullable": true,
                                "type": "string",
                                "default": "OR",
                                "enum": [
                                  "OR",
                                  "AND"
                                ]
                              },
                              "negate": {
                                "title": "Determines if the evaluation of this PolicyGroup is negated. Default to false.\nValidation: Must be allowed for the field type\n- Some fields cannot be negated (negationForbidden=true)",
                                "type": "boolean"
                              },
                              "values": {
                                "title": "List of values for the specified field.\nValidation Requirements:\n- Must have at least one value\n- Values must match the expected regex pattern for the field type\n- Some fields only support single values\n- Values must be valid for the field's data type and constraints\n- Environment variable values have special format requirements\n- Dockerfile line values have special restrictions (e.g., no FROM with strict validation)",
                                "type": "array",
                                "items": {
                                  "nullable": true,
                                  "type": "object",
                                  "properties": {
                                    "value": {
                                      "title": "The actual value for the policy criterion.\nValidation: Must match the expected format for the field type\nExamples:\n- CVE: \"CVE-2021-1234\"\n- Image Tag: \"latest\"\n- Environment Variable: \"UNSET=key=value\" or \"SECRET_KEY=key=\"\n- Dockerfile Line: \"ADD=.\" or \"RUN=apt-get update\"\n- Process Name: \"nginx\"\n- Network Flow: \"tcp:80\"",
                                      "nullable": true,
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  },
                  "mitreAttackVectors": {
                    "type": "array",
                    "description": "MITRE ATT&CK framework mappings for this policy.\nUsed for threat intelligence and compliance reporting.",
                    "items": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "tactic": {
                          "nullable": true,
                          "type": "string"
                        },
                        "techniques": {
                          "type": "array",
                          "items": {
                            "nullable": true,
                            "type": "string"
                          }
                        }
                      }
                    }
                  },
                  "criteriaLocked": {
                    "type": "boolean",
                    "description": "Read-only field. If true, the policy's criteria fields are rendered read-only."
                  },
                  "mitreVectorsLocked": {
                    "type": "boolean",
                    "description": "Read-only field. If true, the policy's MITRE ATT&CK fields are rendered read-only."
                  },
                  "isDefault": {
                    "type": "boolean",
                    "description": "Read-only field. Indicates the policy is a default policy if true and a custom policy if false."
                  },
                  "source": {
                    "nullable": true,
                    "type": "string",
                    "default": "IMPERATIVE",
                    "enum": [
                      "IMPERATIVE",
                      "DECLARATIVE"
                    ]
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "title": "Next tag: 28",
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "id": {
                      "title": "Unique identifier generated by the system. Must be empty for new policies.\nFormat: UUID v4, auto-generated during creation",
                      "nullable": true,
                      "type": "string"
                    },
                    "name": {
                      "title": "Name of the policy. Must be unique across all policies.\nValidation: 5-128 characters, no newlines or dollar signs\nPattern: ^[^\\n\\r\\$]{5,128}$",
                      "nullable": true,
                      "type": "string"
                    },
                    "description": {
                      "title": "Free-form text description of this policy.\nValidation: Max 800 characters, no dollar signs\nPattern: ^[^\\$]{0,800}$",
                      "nullable": true,
                      "type": "string"
                    },
                    "rationale": {
                      "nullable": true,
                      "type": "string",
                      "description": "Business justification for why this policy exists.\nUsed for compliance and audit purposes."
                    },
                    "remediation": {
                      "nullable": true,
                      "type": "string",
                      "description": "Describes how to remediate a violation of this policy.\nShould be actionable and specific to the policy type."
                    },
                    "disabled": {
                      "title": "Toggles whether or not this policy will be executing and actively firing alerts.\nDefault: false",
                      "type": "boolean"
                    },
                    "categories": {
                      "title": "List of categories that this policy falls under. Category names must already exist in Central.\nValidation: At least one category required, no duplicates",
                      "type": "array",
                      "items": {
                        "nullable": true,
                        "type": "string"
                      }
                    },
                    "lifecycleStages": {
                      "title": "Describes which policy lifecycle stages this policy applies to. Choices are DEPLOY, BUILD, and RUNTIME.\nValidation: At least one stage required\n- BUILD: Must contain image-related criteria only\n- DEPLOY: Cannot contain runtime criteria\n- RUNTIME: Must contain at least one runtime criterion",
                      "type": "array",
                      "items": {
                        "nullable": true,
                        "type": "string",
                        "default": "DEPLOY",
                        "enum": [
                          "DEPLOY",
                          "BUILD",
                          "RUNTIME"
                        ]
                      }
                    },
                    "eventSource": {
                      "nullable": true,
                      "type": "string",
                      "default": "NOT_APPLICABLE",
                      "enum": [
                        "NOT_APPLICABLE",
                        "DEPLOYMENT_EVENT",
                        "AUDIT_LOG_EVENT"
                      ]
                    },
                    "exclusions": {
                      "title": "Define deployments or images that should be excluded from this policy.\nValidation:\n- Deployment exclusions: Only valid for DEPLOY and RUNTIME lifecycles\n- Image exclusions: Only valid for BUILD lifecycle\n- Must have at least one criteria (name, scope, or image)",
                      "type": "array",
                      "items": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "name": {
                            "nullable": true,
                            "type": "string",
                            "description": "Name of the exclusion. Used for identification and documentation."
                          },
                          "deployment": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "name": {
                                "title": "Name of the deployment to exclude. Optional if scope is provided.\nValidation: Must be provided if scope is not specified",
                                "nullable": true,
                                "type": "string"
                              },
                              "scope": {
                                "nullable": true,
                                "type": "object",
                                "properties": {
                                  "cluster": {
                                    "nullable": true,
                                    "type": "string"
                                  },
                                  "namespace": {
                                    "nullable": true,
                                    "type": "string"
                                  },
                                  "label": {
                                    "nullable": true,
                                    "type": "object",
                                    "properties": {
                                      "key": {
                                        "nullable": true,
                                        "type": "string"
                                      },
                                      "value": {
                                        "nullable": true,
                                        "type": "string"
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          },
                          "image": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "name": {
                                "title": "Name of the image to exclude.\nValidation: Must be non-empty",
                                "nullable": true,
                                "type": "string"
                              }
                            }
                          },
                          "expiration": {
                            "nullable": true,
                            "type": "string",
                            "description": "Expiration timestamp for this exclusion.\nWhen expired, the exclusion is automatically removed.",
                            "format": "date-time"
                          }
                        }
                      }
                    },
                    "scope": {
                      "title": "Defines clusters, namespaces, and deployments that should be included in this policy.\nNo scopes defined includes everything.\nValidation: Must have at least one field populated (cluster, namespace, or label)",
                      "type": "array",
                      "items": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "cluster": {
                            "nullable": true,
                            "type": "string"
                          },
                          "namespace": {
                            "nullable": true,
                            "type": "string"
                          },
                          "label": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "key": {
                                "nullable": true,
                                "type": "string"
                              },
                              "value": {
                                "nullable": true,
                                "type": "string"
                              }
                            }
                          }
                        }
                      }
                    },
                    "severity": {
                      "nullable": true,
                      "type": "string",
                      "default": "UNSET_SEVERITY",
                      "enum": [
                        "UNSET_SEVERITY",
                        "LOW_SEVERITY",
                        "MEDIUM_SEVERITY",
                        "HIGH_SEVERITY",
                        "CRITICAL_SEVERITY"
                      ]
                    },
                    "enforcementActions": {
                      "title": "Lists the enforcement actions to take when a violation from this policy is identified.\nValidation: Must be compatible with lifecycle stages\n- FAIL_BUILD_ENFORCEMENT: BUILD lifecycle only\n- SCALE_TO_ZERO_ENFORCEMENT: DEPLOY lifecycle only\n- UNSATISFIABLE_NODE_CONSTRAINT_ENFORCEMENT: DEPLOY lifecycle only\n- KILL_POD_ENFORCEMENT: RUNTIME lifecycle only\n- FAIL_KUBE_REQUEST_ENFORCEMENT: RUNTIME lifecycle only\n- FAIL_DEPLOYMENT_CREATE_ENFORCEMENT: DEPLOY lifecycle only\n- FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT: DEPLOY lifecycle only\n- Audit log policies: No enforcement actions allowed",
                      "type": "array",
                      "items": {
                        "nullable": true,
                        "type": "string",
                        "description": " - FAIL_KUBE_REQUEST_ENFORCEMENT: FAIL_KUBE_REQUEST_ENFORCEMENT takes effect only if admission control webhook is enabled to listen on exec and port-forward events.\n - FAIL_DEPLOYMENT_CREATE_ENFORCEMENT: FAIL_DEPLOYMENT_CREATE_ENFORCEMENT takes effect only if admission control webhook is configured to enforce on object creates.\n - FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT: FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT takes effect only if admission control webhook is configured to enforce on object updates.",
                        "default": "UNSET_ENFORCEMENT",
                        "enum": [
                          "UNSET_ENFORCEMENT",
                          "SCALE_TO_ZERO_ENFORCEMENT",
                          "UNSATISFIABLE_NODE_CONSTRAINT_ENFORCEMENT",
                          "KILL_POD_ENFORCEMENT",
                          "FAIL_BUILD_ENFORCEMENT",
                          "FAIL_KUBE_REQUEST_ENFORCEMENT",
                          "FAIL_DEPLOYMENT_CREATE_ENFORCEMENT",
                          "FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT"
                        ]
                      }
                    },
                    "notifiers": {
                      "title": "List of IDs of the notifiers that should be triggered when a violation from this policy is identified.\nIDs should be in the form of a UUID and are found through the Central API.\nValidation: All notifier IDs must reference existing notifiers",
                      "type": "array",
                      "items": {
                        "nullable": true,
                        "type": "string"
                      }
                    },
                    "lastUpdated": {
                      "nullable": true,
                      "type": "string",
                      "description": "Timestamp when the policy was last updated. Auto-generated during creation/update.",
                      "format": "date-time"
                    },
                    "SORTName": {
                      "nullable": true,
                      "type": "string",
                      "description": "For internal use only."
                    },
                    "SORTLifecycleStage": {
                      "nullable": true,
                      "type": "string",
                      "description": "For internal use only."
                    },
                    "SORTEnforcement": {
                      "type": "boolean",
                      "description": "For internal use only."
                    },
                    "policyVersion": {
                      "title": "Policy version. Must be \"1.1\" (current supported version).\nValidation: Only version 1.1 is supported",
                      "nullable": true,
                      "type": "string"
                    },
                    "policySections": {
                      "title": "PolicySections define the violation criteria for this policy.\nValidation Requirements:\n- Each section must have a unique sectionName\n- Each policy group must have a valid fieldName and at least one value\n- Field names must be valid for the specified lifecycle stages\n- Values must match the expected format for each field type\n- Boolean operators must be compatible with field requirements\n- Negation must be allowed for the field type\n- Runtime policies must contain at least one runtime criterion\n- Runtime criteria must be in separate sections\n- Audit log policies require both KubeResource and KubeAPIVerb criteria",
                      "type": "array",
                      "items": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "sectionName": {
                            "nullable": true,
                            "type": "string",
                            "description": "Name of the policy section. Must be unique within the policy.\nUsed for organizing policy criteria into logical groups."
                          },
                          "policyGroups": {
                            "title": "The set of policy groups that make up this section. Each group can be considered an individual criterion.\nValidation Requirements:\n- Each group must have a valid fieldName and at least one value\n- Field names must be valid for the specified lifecycle stages\n- Values must match the expected format for each field type\n- Boolean operators must be compatible with field requirements\n- Negation must be allowed for the field type\n- Runtime criteria must be in separate sections\n- Audit log policies require both KubeResource and KubeAPIVerb criteria",
                            "type": "array",
                            "items": {
                              "nullable": true,
                              "type": "object",
                              "properties": {
                                "fieldName": {
                                  "title": "Defines which field on a deployment or image this PolicyGroup evaluates.\nSee https://docs.openshift.com/acs/operating/manage-security-policies.html#policy-criteria_manage-security-policies for a complete list of possible values.\nValidation Requirements:\n- Must be a valid field name for the specified lifecycle stages\n- Field must support the specified boolean operator\n- Field must allow negation if negate=true\n- Field must support multiple values if more than one value is provided\n- Some fields have special restrictions (e.g., ImageSignatureVerifiedBy cannot use AND operator)",
                                  "nullable": true,
                                  "type": "string"
                                },
                                "booleanOperator": {
                                  "nullable": true,
                                  "type": "string",
                                  "default": "OR",
                                  "enum": [
                                    "OR",
                                    "AND"
                                  ]
                                },
                                "negate": {
                                  "title": "Determines if the evaluation of this PolicyGroup is negated. Default to false.\nValidation: Must be allowed for the field type\n- Some fields cannot be negated (negationForbidden=true)",
                                  "type": "boolean"
                                },
                                "values": {
                                  "title": "List of values for the specified field.\nValidation Requirements:\n- Must have at least one value\n- Values must match the expected regex pattern for the field type\n- Some fields only support single values\n- Values must be valid for the field's data type and constraints\n- Environment variable values have special format requirements\n- Dockerfile line values have special restrictions (e.g., no FROM with strict validation)",
                                  "type": "array",
                                  "items": {
                                    "nullable": true,
                                    "type": "object",
                                    "properties": {
                                      "value": {
                                        "title": "The actual value for the policy criterion.\nValidation: Must match the expected format for the field type\nExamples:\n- CVE: \"CVE-2021-1234\"\n- Image Tag: \"latest\"\n- Environment Variable: \"UNSET=key=value\" or \"SECRET_KEY=key=\"\n- Dockerfile Line: \"ADD=.\" or \"RUN=apt-get update\"\n- Process Name: \"nginx\"\n- Network Flow: \"tcp:80\"",
                                        "nullable": true,
                                        "type": "string"
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    },
                    "mitreAttackVectors": {
                      "type": "array",
                      "description": "MITRE ATT&CK framework mappings for this policy.\nUsed for threat intelligence and compliance reporting.",
                      "items": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "tactic": {
                            "nullable": true,
                            "type": "string"
                          },
                          "techniques": {
                            "type": "array",
                            "items": {
                              "nullable": true,
                              "type": "string"
                            }
                          }
                        }
                      }
                    },
                    "criteriaLocked": {
                      "type": "boolean",
                      "description": "Read-only field. If true, the policy's criteria fields are rendered read-only."
                    },
                    "mitreVectorsLocked": {
                      "type": "boolean",
                      "description": "Read-only field. If true, the policy's MITRE ATT&CK fields are rendered read-only."
                    },
                    "isDefault": {
                      "type": "boolean",
                      "description": "Read-only field. Indicates the policy is a default policy if true and a custom policy if false."
                    },
                    "source": {
                      "nullable": true,
                      "type": "string",
                      "default": "IMPERATIVE",
                      "enum": [
                        "IMPERATIVE",
                        "DECLARATIVE"
                      ]
                    }
                  }
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "application/json": {
                "schema": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "nullable": true,
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "@type": {
                            "nullable": true,
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com. As of May 2023, there are no widely used type server\nimplementations and no plans to implement one.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          }
                        },
                        "additionalProperties": {
                          "nullable": true,
                          "type": "object"
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n    // or ...\n    if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n      foo = any.unpack(Foo.getDefaultInstance());\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "x-codegen-request-body-name": "policy"
      }
    },
    "/v1/policies/{id}": {
      "get": {
        "tags": [
          "PolicyService"
        ],
        "summary": "GetPolicy returns the requested policy by ID.",
        "operationId": "PolicyService_GetPolicy",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "nullable": true,
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "title": "Next tag: 28",
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "id": {
                      "title": "Unique identifier generated by the system. Must be empty for new policies.\nFormat: UUID v4, auto-generated during creation",
                      "nullable": true,
                      "type": "string"
                    },
                    "name": {
                      "title": "Name of the policy. Must be unique across all policies.\nValidation: 5-128 characters, no newlines or dollar signs\nPattern: ^[^\\n\\r\\$]{5,128}$",
                      "nullable": true,
                      "type": "string"
                    },
                    "description": {
                      "title": "Free-form text description of this policy.\nValidation: Max 800 characters, no dollar signs\nPattern: ^[^\\$]{0,800}$",
                      "nullable": true,
                      "type": "string"
                    },
                    "rationale": {
                      "nullable": true,
                      "type": "string",
                      "description": "Business justification for why this policy exists.\nUsed for compliance and audit purposes."
                    },
                    "remediation": {
                      "nullable": true,
                      "type": "string",
                      "description": "Describes how to remediate a violation of this policy.\nShould be actionable and specific to the policy type."
                    },
                    "disabled": {
                      "title": "Toggles whether or not this policy will be executing and actively firing alerts.\nDefault: false",
                      "type": "boolean"
                    },
                    "categories": {
                      "title": "List of categories that this policy falls under. Category names must already exist in Central.\nValidation: At least one category required, no duplicates",
                      "type": "array",
                      "items": {
                        "nullable": true,
                        "type": "string"
                      }
                    },
                    "lifecycleStages": {
                      "title": "Describes which policy lifecycle stages this policy applies to. Choices are DEPLOY, BUILD, and RUNTIME.\nValidation: At least one stage required\n- BUILD: Must contain image-related criteria only\n- DEPLOY: Cannot contain runtime criteria\n- RUNTIME: Must contain at least one runtime criterion",
                      "type": "array",
                      "items": {
                        "nullable": true,
                        "type": "string",
                        "default": "DEPLOY",
                        "enum": [
                          "DEPLOY",
                          "BUILD",
                          "RUNTIME"
                        ]
                      }
                    },
                    "eventSource": {
                      "nullable": true,
                      "type": "string",
                      "default": "NOT_APPLICABLE",
                      "enum": [
                        "NOT_APPLICABLE",
                        "DEPLOYMENT_EVENT",
                        "AUDIT_LOG_EVENT"
                      ]
                    },
                    "exclusions": {
                      "title": "Define deployments or images that should be excluded from this policy.\nValidation:\n- Deployment exclusions: Only valid for DEPLOY and RUNTIME lifecycles\n- Image exclusions: Only valid for BUILD lifecycle\n- Must have at least one criteria (name, scope, or image)",
                      "type": "array",
                      "items": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "name": {
                            "nullable": true,
                            "type": "string",
                            "description": "Name of the exclusion. Used for identification and documentation."
                          },
                          "deployment": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "name": {
                                "title": "Name of the deployment to exclude. Optional if scope is provided.\nValidation: Must be provided if scope is not specified",
                                "nullable": true,
                                "type": "string"
                              },
                              "scope": {
                                "nullable": true,
                                "type": "object",
                                "properties": {
                                  "cluster": {
                                    "nullable": true,
                                    "type": "string"
                                  },
                                  "namespace": {
                                    "nullable": true,
                                    "type": "string"
                                  },
                                  "label": {
                                    "nullable": true,
                                    "type": "object",
                                    "properties": {
                                      "key": {
                                        "nullable": true,
                                        "type": "string"
                                      },
                                      "value": {
                                        "nullable": true,
                                        "type": "string"
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          },
                          "image": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "name": {
                                "title": "Name of the image to exclude.\nValidation: Must be non-empty",
                                "nullable": true,
                                "type": "string"
                              }
                            }
                          },
                          "expiration": {
                            "nullable": true,
                            "type": "string",
                            "description": "Expiration timestamp for this exclusion.\nWhen expired, the exclusion is automatically removed.",
                            "format": "date-time"
                          }
                        }
                      }
                    },
                    "scope": {
                      "title": "Defines clusters, namespaces, and deployments that should be included in this policy.\nNo scopes defined includes everything.\nValidation: Must have at least one field populated (cluster, namespace, or label)",
                      "type": "array",
                      "items": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "cluster": {
                            "nullable": true,
                            "type": "string"
                          },
                          "namespace": {
                            "nullable": true,
                            "type": "string"
                          },
                          "label": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "key": {
                                "nullable": true,
                                "type": "string"
                              },
                              "value": {
                                "nullable": true,
                                "type": "string"
                              }
                            }
                          }
                        }
                      }
                    },
                    "severity": {
                      "nullable": true,
                      "type": "string",
                      "default": "UNSET_SEVERITY",
                      "enum": [
                        "UNSET_SEVERITY",
                        "LOW_SEVERITY",
                        "MEDIUM_SEVERITY",
                        "HIGH_SEVERITY",
                        "CRITICAL_SEVERITY"
                      ]
                    },
                    "enforcementActions": {
                      "title": "Lists the enforcement actions to take when a violation from this policy is identified.\nValidation: Must be compatible with lifecycle stages\n- FAIL_BUILD_ENFORCEMENT: BUILD lifecycle only\n- SCALE_TO_ZERO_ENFORCEMENT: DEPLOY lifecycle only\n- UNSATISFIABLE_NODE_CONSTRAINT_ENFORCEMENT: DEPLOY lifecycle only\n- KILL_POD_ENFORCEMENT: RUNTIME lifecycle only\n- FAIL_KUBE_REQUEST_ENFORCEMENT: RUNTIME lifecycle only\n- FAIL_DEPLOYMENT_CREATE_ENFORCEMENT: DEPLOY lifecycle only\n- FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT: DEPLOY lifecycle only\n- Audit log policies: No enforcement actions allowed",
                      "type": "array",
                      "items": {
                        "nullable": true,
                        "type": "string",
                        "description": " - FAIL_KUBE_REQUEST_ENFORCEMENT: FAIL_KUBE_REQUEST_ENFORCEMENT takes effect only if admission control webhook is enabled to listen on exec and port-forward events.\n - FAIL_DEPLOYMENT_CREATE_ENFORCEMENT: FAIL_DEPLOYMENT_CREATE_ENFORCEMENT takes effect only if admission control webhook is configured to enforce on object creates.\n - FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT: FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT takes effect only if admission control webhook is configured to enforce on object updates.",
                        "default": "UNSET_ENFORCEMENT",
                        "enum": [
                          "UNSET_ENFORCEMENT",
                          "SCALE_TO_ZERO_ENFORCEMENT",
                          "UNSATISFIABLE_NODE_CONSTRAINT_ENFORCEMENT",
                          "KILL_POD_ENFORCEMENT",
                          "FAIL_BUILD_ENFORCEMENT",
                          "FAIL_KUBE_REQUEST_ENFORCEMENT",
                          "FAIL_DEPLOYMENT_CREATE_ENFORCEMENT",
                          "FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT"
                        ]
                      }
                    },
                    "notifiers": {
                      "title": "List of IDs of the notifiers that should be triggered when a violation from this policy is identified.\nIDs should be in the form of a UUID and are found through the Central API.\nValidation: All notifier IDs must reference existing notifiers",
                      "type": "array",
                      "items": {
                        "nullable": true,
                        "type": "string"
                      }
                    },
                    "lastUpdated": {
                      "nullable": true,
                      "type": "string",
                      "description": "Timestamp when the policy was last updated. Auto-generated during creation/update.",
                      "format": "date-time"
                    },
                    "SORTName": {
                      "nullable": true,
                      "type": "string",
                      "description": "For internal use only."
                    },
                    "SORTLifecycleStage": {
                      "nullable": true,
                      "type": "string",
                      "description": "For internal use only."
                    },
                    "SORTEnforcement": {
                      "type": "boolean",
                      "description": "For internal use only."
                    },
                    "policyVersion": {
                      "title": "Policy version. Must be \"1.1\" (current supported version).\nValidation: Only version 1.1 is supported",
                      "nullable": true,
                      "type": "string"
                    },
                    "policySections": {
                      "title": "PolicySections define the violation criteria for this policy.\nValidation Requirements:\n- Each section must have a unique sectionName\n- Each policy group must have a valid fieldName and at least one value\n- Field names must be valid for the specified lifecycle stages\n- Values must match the expected format for each field type\n- Boolean operators must be compatible with field requirements\n- Negation must be allowed for the field type\n- Runtime policies must contain at least one runtime criterion\n- Runtime criteria must be in separate sections\n- Audit log policies require both KubeResource and KubeAPIVerb criteria",
                      "type": "array",
                      "items": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "sectionName": {
                            "nullable": true,
                            "type": "string",
                            "description": "Name of the policy section. Must be unique within the policy.\nUsed for organizing policy criteria into logical groups."
                          },
                          "policyGroups": {
                            "title": "The set of policy groups that make up this section. Each group can be considered an individual criterion.\nValidation Requirements:\n- Each group must have a valid fieldName and at least one value\n- Field names must be valid for the specified lifecycle stages\n- Values must match the expected format for each field type\n- Boolean operators must be compatible with field requirements\n- Negation must be allowed for the field type\n- Runtime criteria must be in separate sections\n- Audit log policies require both KubeResource and KubeAPIVerb criteria",
                            "type": "array",
                            "items": {
                              "nullable": true,
                              "type": "object",
                              "properties": {
                                "fieldName": {
                                  "title": "Defines which field on a deployment or image this PolicyGroup evaluates.\nSee https://docs.openshift.com/acs/operating/manage-security-policies.html#policy-criteria_manage-security-policies for a complete list of possible values.\nValidation Requirements:\n- Must be a valid field name for the specified lifecycle stages\n- Field must support the specified boolean operator\n- Field must allow negation if negate=true\n- Field must support multiple values if more than one value is provided\n- Some fields have special restrictions (e.g., ImageSignatureVerifiedBy cannot use AND operator)",
                                  "nullable": true,
                                  "type": "string"
                                },
                                "booleanOperator": {
                                  "nullable": true,
                                  "type": "string",
                                  "default": "OR",
                                  "enum": [
                                    "OR",
                                    "AND"
                                  ]
                                },
                                "negate": {
                                  "title": "Determines if the evaluation of this PolicyGroup is negated. Default to false.\nValidation: Must be allowed for the field type\n- Some fields cannot be negated (negationForbidden=true)",
                                  "type": "boolean"
                                },
                                "values": {
                                  "title": "List of values for the specified field.\nValidation Requirements:\n- Must have at least one value\n- Values must match the expected regex pattern for the field type\n- Some fields only support single values\n- Values must be valid for the field's data type and constraints\n- Environment variable values have special format requirements\n- Dockerfile line values have special restrictions (e.g., no FROM with strict validation)",
                                  "type": "array",
                                  "items": {
                                    "nullable": true,
                                    "type": "object",
                                    "properties": {
                                      "value": {
                                        "title": "The actual value for the policy criterion.\nValidation: Must match the expected format for the field type\nExamples:\n- CVE: \"CVE-2021-1234\"\n- Image Tag: \"latest\"\n- Environment Variable: \"UNSET=key=value\" or \"SECRET_KEY=key=\"\n- Dockerfile Line: \"ADD=.\" or \"RUN=apt-get update\"\n- Process Name: \"nginx\"\n- Network Flow: \"tcp:80\"",
                                        "nullable": true,
                                        "type": "string"
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    },
                    "mitreAttackVectors": {
                      "type": "array",
                      "description": "MITRE ATT&CK framework mappings for this policy.\nUsed for threat intelligence and compliance reporting.",
                      "items": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "tactic": {
                            "nullable": true,
                            "type": "string"
                          },
                          "techniques": {
                            "type": "array",
                            "items": {
                              "nullable": true,
                              "type": "string"
                            }
                          }
                        }
                      }
                    },
                    "criteriaLocked": {
                      "type": "boolean",
                      "description": "Read-only field. If true, the policy's criteria fields are rendered read-only."
                    },
                    "mitreVectorsLocked": {
                      "type": "boolean",
                      "description": "Read-only field. If true, the policy's MITRE ATT&CK fields are rendered read-only."
                    },
                    "isDefault": {
                      "type": "boolean",
                      "description": "Read-only field. Indicates the policy is a default policy if true and a custom policy if false."
                    },
                    "source": {
                      "nullable": true,
                      "type": "string",
                      "default": "IMPERATIVE",
                      "enum": [
                        "IMPERATIVE",
                        "DECLARATIVE"
                      ]
                    }
                  }
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "application/json": {
                "schema": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "nullable": true,
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "@type": {
                            "nullable": true,
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com. As of May 2023, there are no widely used type server\nimplementations and no plans to implement one.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          }
                        },
                        "additionalProperties": {
                          "nullable": true,
                          "type": "object"
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n    // or ...\n    if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n      foo = any.unpack(Foo.getDefaultInstance());\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "PolicyService"
        ],
        "summary": "PutPolicy modifies an existing policy.",
        "operationId": "PolicyService_PutPolicy",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Unique identifier generated by the system. Must be empty for new policies.\nFormat: UUID v4, auto-generated during creation",
            "required": true,
            "schema": {
              "nullable": true,
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "title": "Next tag: 28",
                "nullable": true,
                "type": "object",
                "properties": {
                  "name": {
                    "title": "Name of the policy. Must be unique across all policies.\nValidation: 5-128 characters, no newlines or dollar signs\nPattern: ^[^\\n\\r\\$]{5,128}$",
                    "nullable": true,
                    "type": "string"
                  },
                  "description": {
                    "title": "Free-form text description of this policy.\nValidation: Max 800 characters, no dollar signs\nPattern: ^[^\\$]{0,800}$",
                    "nullable": true,
                    "type": "string"
                  },
                  "rationale": {
                    "nullable": true,
                    "type": "string",
                    "description": "Business justification for why this policy exists.\nUsed for compliance and audit purposes."
                  },
                  "remediation": {
                    "nullable": true,
                    "type": "string",
                    "description": "Describes how to remediate a violation of this policy.\nShould be actionable and specific to the policy type."
                  },
                  "disabled": {
                    "title": "Toggles whether or not this policy will be executing and actively firing alerts.\nDefault: false",
                    "type": "boolean"
                  },
                  "categories": {
                    "title": "List of categories that this policy falls under. Category names must already exist in Central.\nValidation: At least one category required, no duplicates",
                    "type": "array",
                    "items": {
                      "nullable": true,
                      "type": "string"
                    }
                  },
                  "lifecycleStages": {
                    "title": "Describes which policy lifecycle stages this policy applies to. Choices are DEPLOY, BUILD, and RUNTIME.\nValidation: At least one stage required\n- BUILD: Must contain image-related criteria only\n- DEPLOY: Cannot contain runtime criteria\n- RUNTIME: Must contain at least one runtime criterion",
                    "type": "array",
                    "items": {
                      "nullable": true,
                      "type": "string",
                      "default": "DEPLOY",
                      "enum": [
                        "DEPLOY",
                        "BUILD",
                        "RUNTIME"
                      ]
                    }
                  },
                  "eventSource": {
                    "nullable": true,
                    "type": "string",
                    "default": "NOT_APPLICABLE",
                    "enum": [
                      "NOT_APPLICABLE",
                      "DEPLOYMENT_EVENT",
                      "AUDIT_LOG_EVENT"
                    ]
                  },
                  "exclusions": {
                    "title": "Define deployments or images that should be excluded from this policy.\nValidation:\n- Deployment exclusions: Only valid for DEPLOY and RUNTIME lifecycles\n- Image exclusions: Only valid for BUILD lifecycle\n- Must have at least one criteria (name, scope, or image)",
                    "type": "array",
                    "items": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "name": {
                          "nullable": true,
                          "type": "string",
                          "description": "Name of the exclusion. Used for identification and documentation."
                        },
                        "deployment": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "name": {
                              "title": "Name of the deployment to exclude. Optional if scope is provided.\nValidation: Must be provided if scope is not specified",
                              "nullable": true,
                              "type": "string"
                            },
                            "scope": {
                              "nullable": true,
                              "type": "object",
                              "properties": {
                                "cluster": {
                                  "nullable": true,
                                  "type": "string"
                                },
                                "namespace": {
                                  "nullable": true,
                                  "type": "string"
                                },
                                "label": {
                                  "nullable": true,
                                  "type": "object",
                                  "properties": {
                                    "key": {
                                      "nullable": true,
                                      "type": "string"
                                    },
                                    "value": {
                                      "nullable": true,
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            }
                          }
                        },
                        "image": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "name": {
                              "title": "Name of the image to exclude.\nValidation: Must be non-empty",
                              "nullable": true,
                              "type": "string"
                            }
                          }
                        },
                        "expiration": {
                          "nullable": true,
                          "type": "string",
                          "description": "Expiration timestamp for this exclusion.\nWhen expired, the exclusion is automatically removed.",
                          "format": "date-time"
                        }
                      }
                    }
                  },
                  "scope": {
                    "title": "Defines clusters, namespaces, and deployments that should be included in this policy.\nNo scopes defined includes everything.\nValidation: Must have at least one field populated (cluster, namespace, or label)",
                    "type": "array",
                    "items": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "cluster": {
                          "nullable": true,
                          "type": "string"
                        },
                        "namespace": {
                          "nullable": true,
                          "type": "string"
                        },
                        "label": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "key": {
                              "nullable": true,
                              "type": "string"
                            },
                            "value": {
                              "nullable": true,
                              "type": "string"
                            }
                          }
                        }
                      }
                    }
                  },
                  "severity": {
                    "nullable": true,
                    "type": "string",
                    "default": "UNSET_SEVERITY",
                    "enum": [
                      "UNSET_SEVERITY",
                      "LOW_SEVERITY",
                      "MEDIUM_SEVERITY",
                      "HIGH_SEVERITY",
                      "CRITICAL_SEVERITY"
                    ]
                  },
                  "enforcementActions": {
                    "title": "Lists the enforcement actions to take when a violation from this policy is identified.\nValidation: Must be compatible with lifecycle stages\n- FAIL_BUILD_ENFORCEMENT: BUILD lifecycle only\n- SCALE_TO_ZERO_ENFORCEMENT: DEPLOY lifecycle only\n- UNSATISFIABLE_NODE_CONSTRAINT_ENFORCEMENT: DEPLOY lifecycle only\n- KILL_POD_ENFORCEMENT: RUNTIME lifecycle only\n- FAIL_KUBE_REQUEST_ENFORCEMENT: RUNTIME lifecycle only\n- FAIL_DEPLOYMENT_CREATE_ENFORCEMENT: DEPLOY lifecycle only\n- FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT: DEPLOY lifecycle only\n- Audit log policies: No enforcement actions allowed",
                    "type": "array",
                    "items": {
                      "nullable": true,
                      "type": "string",
                      "description": " - FAIL_KUBE_REQUEST_ENFORCEMENT: FAIL_KUBE_REQUEST_ENFORCEMENT takes effect only if admission control webhook is enabled to listen on exec and port-forward events.\n - FAIL_DEPLOYMENT_CREATE_ENFORCEMENT: FAIL_DEPLOYMENT_CREATE_ENFORCEMENT takes effect only if admission control webhook is configured to enforce on object creates.\n - FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT: FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT takes effect only if admission control webhook is configured to enforce on object updates.",
                      "default": "UNSET_ENFORCEMENT",
                      "enum": [
                        "UNSET_ENFORCEMENT",
                        "SCALE_TO_ZERO_ENFORCEMENT",
                        "UNSATISFIABLE_NODE_CONSTRAINT_ENFORCEMENT",
                        "KILL_POD_ENFORCEMENT",
                        "FAIL_BUILD_ENFORCEMENT",
                        "FAIL_KUBE_REQUEST_ENFORCEMENT",
                        "FAIL_DEPLOYMENT_CREATE_ENFORCEMENT",
                        "FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT"
                      ]
                    }
                  },
                  "notifiers": {
                    "title": "List of IDs of the notifiers that should be triggered when a violation from this policy is identified.\nIDs should be in the form of a UUID and are found through the Central API.\nValidation: All notifier IDs must reference existing notifiers",
                    "type": "array",
                    "items": {
                      "nullable": true,
                      "type": "string"
                    }
                  },
                  "lastUpdated": {
                    "nullable": true,
                    "type": "string",
                    "description": "Timestamp when the policy was last updated. Auto-generated during creation/update.",
                    "format": "date-time"
                  },
                  "SORTName": {
                    "nullable": true,
                    "type": "string",
                    "description": "For internal use only."
                  },
                  "SORTLifecycleStage": {
                    "nullable": true,
                    "type": "string",
                    "description": "For internal use only."
                  },
                  "SORTEnforcement": {
                    "type": "boolean",
                    "description": "For internal use only."
                  },
                  "policyVersion": {
                    "title": "Policy version. Must be \"1.1\" (current supported version).\nValidation: Only version 1.1 is supported",
                    "nullable": true,
                    "type": "string"
                  },
                  "policySections": {
                    "title": "PolicySections define the violation criteria for this policy.\nValidation Requirements:\n- Each section must have a unique sectionName\n- Each policy group must have a valid fieldName and at least one value\n- Field names must be valid for the specified lifecycle stages\n- Values must match the expected format for each field type\n- Boolean operators must be compatible with field requirements\n- Negation must be allowed for the field type\n- Runtime policies must contain at least one runtime criterion\n- Runtime criteria must be in separate sections\n- Audit log policies require both KubeResource and KubeAPIVerb criteria",
                    "type": "array",
                    "items": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "sectionName": {
                          "nullable": true,
                          "type": "string",
                          "description": "Name of the policy section. Must be unique within the policy.\nUsed for organizing policy criteria into logical groups."
                        },
                        "policyGroups": {
                          "title": "The set of policy groups that make up this section. Each group can be considered an individual criterion.\nValidation Requirements:\n- Each group must have a valid fieldName and at least one value\n- Field names must be valid for the specified lifecycle stages\n- Values must match the expected format for each field type\n- Boolean operators must be compatible with field requirements\n- Negation must be allowed for the field type\n- Runtime criteria must be in separate sections\n- Audit log policies require both KubeResource and KubeAPIVerb criteria",
                          "type": "array",
                          "items": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "fieldName": {
                                "title": "Defines which field on a deployment or image this PolicyGroup evaluates.\nSee https://docs.openshift.com/acs/operating/manage-security-policies.html#policy-criteria_manage-security-policies for a complete list of possible values.\nValidation Requirements:\n- Must be a valid field name for the specified lifecycle stages\n- Field must support the specified boolean operator\n- Field must allow negation if negate=true\n- Field must support multiple values if more than one value is provided\n- Some fields have special restrictions (e.g., ImageSignatureVerifiedBy cannot use AND operator)",
                                "nullable": true,
                                "type": "string"
                              },
                              "booleanOperator": {
                                "nullable": true,
                                "type": "string",
                                "default": "OR",
                                "enum": [
                                  "OR",
                                  "AND"
                                ]
                              },
                              "negate": {
                                "title": "Determines if the evaluation of this PolicyGroup is negated. Default to false.\nValidation: Must be allowed for the field type\n- Some fields cannot be negated (negationForbidden=true)",
                                "type": "boolean"
                              },
                              "values": {
                                "title": "List of values for the specified field.\nValidation Requirements:\n- Must have at least one value\n- Values must match the expected regex pattern for the field type\n- Some fields only support single values\n- Values must be valid for the field's data type and constraints\n- Environment variable values have special format requirements\n- Dockerfile line values have special restrictions (e.g., no FROM with strict validation)",
                                "type": "array",
                                "items": {
                                  "nullable": true,
                                  "type": "object",
                                  "properties": {
                                    "value": {
                                      "title": "The actual value for the policy criterion.\nValidation: Must match the expected format for the field type\nExamples:\n- CVE: \"CVE-2021-1234\"\n- Image Tag: \"latest\"\n- Environment Variable: \"UNSET=key=value\" or \"SECRET_KEY=key=\"\n- Dockerfile Line: \"ADD=.\" or \"RUN=apt-get update\"\n- Process Name: \"nginx\"\n- Network Flow: \"tcp:80\"",
                                      "nullable": true,
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  },
                  "mitreAttackVectors": {
                    "type": "array",
                    "description": "MITRE ATT&CK framework mappings for this policy.\nUsed for threat intelligence and compliance reporting.",
                    "items": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "tactic": {
                          "nullable": true,
                          "type": "string"
                        },
                        "techniques": {
                          "type": "array",
                          "items": {
                            "nullable": true,
                            "type": "string"
                          }
                        }
                      }
                    }
                  },
                  "criteriaLocked": {
                    "type": "boolean",
                    "description": "Read-only field. If true, the policy's criteria fields are rendered read-only."
                  },
                  "mitreVectorsLocked": {
                    "type": "boolean",
                    "description": "Read-only field. If true, the policy's MITRE ATT&CK fields are rendered read-only."
                  },
                  "isDefault": {
                    "type": "boolean",
                    "description": "Read-only field. Indicates the policy is a default policy if true and a custom policy if false."
                  },
                  "source": {
                    "nullable": true,
                    "type": "string",
                    "default": "IMPERATIVE",
                    "enum": [
                      "IMPERATIVE",
                      "DECLARATIVE"
                    ]
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "nullable": true,
                  "type": "object"
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "application/json": {
                "schema": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "nullable": true,
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "@type": {
                            "nullable": true,
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com. As of May 2023, there are no widely used type server\nimplementations and no plans to implement one.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          }
                        },
                        "additionalProperties": {
                          "nullable": true,
                          "type": "object"
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n    // or ...\n    if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n      foo = any.unpack(Foo.getDefaultInstance());\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "x-codegen-request-body-name": "body"
      },
      "delete": {
        "tags": [
          "PolicyService"
        ],
        "summary": "DeletePolicy removes a policy by ID.",
        "operationId": "PolicyService_DeletePolicy",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "nullable": true,
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "nullable": true,
                  "type": "object"
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "application/json": {
                "schema": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "nullable": true,
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "@type": {
                            "nullable": true,
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com. As of May 2023, there are no widely used type server\nimplementations and no plans to implement one.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          }
                        },
                        "additionalProperties": {
                          "nullable": true,
                          "type": "object"
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n    // or ...\n    if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n      foo = any.unpack(Foo.getDefaultInstance());\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      },
      "patch": {
        "tags": [
          "PolicyService"
        ],
        "summary": "PatchPolicy edits an existing policy.",
        "operationId": "PolicyService_PatchPolicy",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "nullable": true,
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "disabled": {
                    "type": "boolean"
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "nullable": true,
                  "type": "object"
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "application/json": {
                "schema": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "nullable": true,
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "@type": {
                            "nullable": true,
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com. As of May 2023, there are no widely used type server\nimplementations and no plans to implement one.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          }
                        },
                        "additionalProperties": {
                          "nullable": true,
                          "type": "object"
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n    // or ...\n    if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n      foo = any.unpack(Foo.getDefaultInstance());\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "x-codegen-request-body-name": "body"
      }
    }
  },
  "components": {
    "schemas": {
      "protobufAny": {
        "nullable": true,
        "type": "object",
        "properties": {
          "@type": {
            "nullable": true,
            "type": "string",
            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com. As of May 2023, there are no widely used type server\nimplementations and no plans to implement one.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
          }
        },
        "additionalProperties": {
          "nullable": true,
          "type": "object"
        },
        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n    // or ...\n    if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n      foo = any.unpack(Foo.getDefaultInstance());\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
      },
      "googlerpcStatus": {
        "nullable": true,
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "format": "int32"
          },
          "message": {
            "nullable": true,
            "type": "string"
          },
          "details": {
            "type": "array",
            "items": {
              "nullable": true,
              "type": "object",
              "properties": {
                "@type": {
                  "nullable": true,
                  "type": "string",
                  "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com. As of May 2023, there are no widely used type server\nimplementations and no plans to implement one.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                }
              },
              "additionalProperties": {
                "nullable": true,
                "type": "object"
              },
              "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n    // or ...\n    if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n      foo = any.unpack(Foo.getDefaultInstance());\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
            }
          }
        }
      },
      "storageLifecycleStage": {
        "nullable": true,
        "type": "string",
        "default": "DEPLOY",
        "enum": [
          "DEPLOY",
          "BUILD",
          "RUNTIME"
        ]
      },
      "storageSeverity": {
        "nullable": true,
        "type": "string",
        "default": "UNSET_SEVERITY",
        "enum": [
          "UNSET_SEVERITY",
          "LOW_SEVERITY",
          "MEDIUM_SEVERITY",
          "HIGH_SEVERITY",
          "CRITICAL_SEVERITY"
        ]
      },
      "ListAlertPolicyDevFields": {
        "nullable": true,
        "type": "object",
        "properties": {
          "SORTName": {
            "nullable": true,
            "type": "string"
          }
        }
      },
      "storageListAlertPolicy": {
        "nullable": true,
        "type": "object",
        "properties": {
          "id": {
            "nullable": true,
            "type": "string"
          },
          "name": {
            "nullable": true,
            "type": "string"
          },
          "severity": {
            "nullable": true,
            "type": "string",
            "default": "UNSET_SEVERITY",
            "enum": [
              "UNSET_SEVERITY",
              "LOW_SEVERITY",
              "MEDIUM_SEVERITY",
              "HIGH_SEVERITY",
              "CRITICAL_SEVERITY"
            ]
          },
          "description": {
            "nullable": true,
            "type": "string"
          },
          "categories": {
            "type": "array",
            "items": {
              "nullable": true,
              "type": "string"
            }
          },
          "developerInternalFields": {
            "nullable": true,
            "type": "object",
            "properties": {
              "SORTName": {
                "nullable": true,
                "type": "string"
              }
            }
          }
        }
      },
      "storageViolationState": {
        "nullable": true,
        "type": "string",
        "description": " - ACTIVE: Alert is currently active and requires attention.\nThis is the default state for new alerts.\nActive alerts can be resolved but cannot be deleted.\n - RESOLVED: Alert has been resolved (manually or automatically).\nResolved alerts can be deleted for maintenance purposes.\nOnly RESOLVED alerts can be deleted via DeleteAlerts API.\n - ATTEMPTED: Enforcement action was attempted but failed.\nThese alerts can be resolved to acknowledge the failed enforcement.\nCommon for alerts where enforcement actions are not fully configured.",
        "default": "ACTIVE",
        "enum": [
          "ACTIVE",
          "RESOLVED",
          "ATTEMPTED"
        ]
      },
      "storageEnforcementAction": {
        "nullable": true,
        "type": "string",
        "description": " - FAIL_KUBE_REQUEST_ENFORCEMENT: FAIL_KUBE_REQUEST_ENFORCEMENT takes effect only if admission control webhook is enabled to listen on exec and port-forward events.\n - FAIL_DEPLOYMENT_CREATE_ENFORCEMENT: FAIL_DEPLOYMENT_CREATE_ENFORCEMENT takes effect only if admission control webhook is configured to enforce on object creates.\n - FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT: FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT takes effect only if admission control webhook is configured to enforce on object updates.",
        "default": "UNSET_ENFORCEMENT",
        "enum": [
          "UNSET_ENFORCEMENT",
          "SCALE_TO_ZERO_ENFORCEMENT",
          "UNSATISFIABLE_NODE_CONSTRAINT_ENFORCEMENT",
          "KILL_POD_ENFORCEMENT",
          "FAIL_BUILD_ENFORCEMENT",
          "FAIL_KUBE_REQUEST_ENFORCEMENT",
          "FAIL_DEPLOYMENT_CREATE_ENFORCEMENT",
          "FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT"
        ]
      },
      "storageListAlertResourceType": {
        "title": "A special ListAlert-only enumeration of all resource types. Unlike Alert.Resource.ResourceType this also includes deployment as a type\nThis must be kept in sync with Alert.Resource.ResourceType (excluding the deployment value)",
        "nullable": true,
        "type": "string",
        "default": "DEPLOYMENT",
        "enum": [
          "DEPLOYMENT",
          "SECRETS",
          "CONFIGMAPS",
          "CLUSTER_ROLES",
          "CLUSTER_ROLE_BINDINGS",
          "NETWORK_POLICIES",
          "SECURITY_CONTEXT_CONSTRAINTS",
          "EGRESS_FIREWALLS"
        ]
      },
      "ListAlertCommonEntityInfo": {
        "nullable": true,
        "type": "object",
        "properties": {
          "clusterName": {
            "nullable": true,
            "type": "string"
          },
          "namespace": {
            "nullable": true,
            "type": "string"
          },
          "clusterId": {
            "nullable": true,
            "type": "string"
          },
          "namespaceId": {
            "nullable": true,
            "type": "string"
          },
          "resourceType": {
            "title": "A special ListAlert-only enumeration of all resource types. Unlike Alert.Resource.ResourceType this also includes deployment as a type\nThis must be kept in sync with Alert.Resource.ResourceType (excluding the deployment value)",
            "nullable": true,
            "type": "string",
            "default": "DEPLOYMENT",
            "enum": [
              "DEPLOYMENT",
              "SECRETS",
              "CONFIGMAPS",
              "CLUSTER_ROLES",
              "CLUSTER_ROLE_BINDINGS",
              "NETWORK_POLICIES",
              "SECURITY_CONTEXT_CONSTRAINTS",
              "EGRESS_FIREWALLS"
            ]
          }
        },
        "description": "Fields common to all entities that an alert might belong to."
      },
      "storageListAlertDeployment": {
        "nullable": true,
        "type": "object",
        "properties": {
          "id": {
            "nullable": true,
            "type": "string"
          },
          "name": {
            "nullable": true,
            "type": "string"
          },
          "clusterName": {
            "nullable": true,
            "type": "string",
            "description": "This field is deprecated and can be found in CommonEntityInfo. It will be removed from here in a future release.\n\nThis field has moved to CommonEntityInfo"
          },
          "namespace": {
            "nullable": true,
            "type": "string",
            "description": "This field is deprecated and can be found in CommonEntityInfo. It will be removed from here in a future release.\n\nThis field has moved to CommonEntityInfo"
          },
          "clusterId": {
            "nullable": true,
            "type": "string",
            "description": "This field is deprecated and can be found in CommonEntityInfo. It will be removed from here in a future release.\n\nThis field has moved to CommonEntityInfo"
          },
          "inactive": {
            "type": "boolean"
          },
          "namespaceId": {
            "nullable": true,
            "type": "string",
            "description": "This field is deprecated and can be found in CommonEntityInfo. It will be removed from here in a future release.\n\nThis field has moved to CommonEntityInfo"
          },
          "deploymentType": {
            "nullable": true,
            "type": "string"
          }
        }
      },
      "ListAlertResourceEntity": {
        "nullable": true,
        "type": "object",
        "properties": {
          "name": {
            "nullable": true,
            "type": "string"
          }
        }
      },
      "storageListAlert": {
        "nullable": true,
        "type": "object",
        "properties": {
          "id": {
            "nullable": true,
            "type": "string"
          },
          "lifecycleStage": {
            "nullable": true,
            "type": "string",
            "default": "DEPLOY",
            "enum": [
              "DEPLOY",
              "BUILD",
              "RUNTIME"
            ]
          },
          "time": {
            "nullable": true,
            "type": "string",
            "format": "date-time"
          },
          "policy": {
            "nullable": true,
            "type": "object",
            "properties": {
              "id": {
                "nullable": true,
                "type": "string"
              },
              "name": {
                "nullable": true,
                "type": "string"
              },
              "severity": {
                "nullable": true,
                "type": "string",
                "default": "UNSET_SEVERITY",
                "enum": [
                  "UNSET_SEVERITY",
                  "LOW_SEVERITY",
                  "MEDIUM_SEVERITY",
                  "HIGH_SEVERITY",
                  "CRITICAL_SEVERITY"
                ]
              },
              "description": {
                "nullable": true,
                "type": "string"
              },
              "categories": {
                "type": "array",
                "items": {
                  "nullable": true,
                  "type": "string"
                }
              },
              "developerInternalFields": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "SORTName": {
                    "nullable": true,
                    "type": "string"
                  }
                }
              }
            }
          },
          "state": {
            "nullable": true,
            "type": "string",
            "description": " - ACTIVE: Alert is currently active and requires attention.\nThis is the default state for new alerts.\nActive alerts can be resolved but cannot be deleted.\n - RESOLVED: Alert has been resolved (manually or automatically).\nResolved alerts can be deleted for maintenance purposes.\nOnly RESOLVED alerts can be deleted via DeleteAlerts API.\n - ATTEMPTED: Enforcement action was attempted but failed.\nThese alerts can be resolved to acknowledge the failed enforcement.\nCommon for alerts where enforcement actions are not fully configured.",
            "default": "ACTIVE",
            "enum": [
              "ACTIVE",
              "RESOLVED",
              "ATTEMPTED"
            ]
          },
          "enforcementCount": {
            "type": "integer",
            "format": "int32"
          },
          "enforcementAction": {
            "nullable": true,
            "type": "string",
            "description": " - FAIL_KUBE_REQUEST_ENFORCEMENT: FAIL_KUBE_REQUEST_ENFORCEMENT takes effect only if admission control webhook is enabled to listen on exec and port-forward events.\n - FAIL_DEPLOYMENT_CREATE_ENFORCEMENT: FAIL_DEPLOYMENT_CREATE_ENFORCEMENT takes effect only if admission control webhook is configured to enforce on object creates.\n - FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT: FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT takes effect only if admission control webhook is configured to enforce on object updates.",
            "default": "UNSET_ENFORCEMENT",
            "enum": [
              "UNSET_ENFORCEMENT",
              "SCALE_TO_ZERO_ENFORCEMENT",
              "UNSATISFIABLE_NODE_CONSTRAINT_ENFORCEMENT",
              "KILL_POD_ENFORCEMENT",
              "FAIL_BUILD_ENFORCEMENT",
              "FAIL_KUBE_REQUEST_ENFORCEMENT",
              "FAIL_DEPLOYMENT_CREATE_ENFORCEMENT",
              "FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT"
            ]
          },
          "commonEntityInfo": {
            "nullable": true,
            "type": "object",
            "properties": {
              "clusterName": {
                "nullable": true,
                "type": "string"
              },
              "namespace": {
                "nullable": true,
                "type": "string"
              },
              "clusterId": {
                "nullable": true,
                "type": "string"
              },
              "namespaceId": {
                "nullable": true,
                "type": "string"
              },
              "resourceType": {
                "title": "A special ListAlert-only enumeration of all resource types. Unlike Alert.Resource.ResourceType this also includes deployment as a type\nThis must be kept in sync with Alert.Resource.ResourceType (excluding the deployment value)",
                "nullable": true,
                "type": "string",
                "default": "DEPLOYMENT",
                "enum": [
                  "DEPLOYMENT",
                  "SECRETS",
                  "CONFIGMAPS",
                  "CLUSTER_ROLES",
                  "CLUSTER_ROLE_BINDINGS",
                  "NETWORK_POLICIES",
                  "SECURITY_CONTEXT_CONSTRAINTS",
                  "EGRESS_FIREWALLS"
                ]
              }
            },
            "description": "Fields common to all entities that an alert might belong to."
          },
          "deployment": {
            "nullable": true,
            "type": "object",
            "properties": {
              "id": {
                "nullable": true,
                "type": "string"
              },
              "name": {
                "nullable": true,
                "type": "string"
              },
              "clusterName": {
                "nullable": true,
                "type": "string",
                "description": "This field is deprecated and can be found in CommonEntityInfo. It will be removed from here in a future release.\n\nThis field has moved to CommonEntityInfo"
              },
              "namespace": {
                "nullable": true,
                "type": "string",
                "description": "This field is deprecated and can be found in CommonEntityInfo. It will be removed from here in a future release.\n\nThis field has moved to CommonEntityInfo"
              },
              "clusterId": {
                "nullable": true,
                "type": "string",
                "description": "This field is deprecated and can be found in CommonEntityInfo. It will be removed from here in a future release.\n\nThis field has moved to CommonEntityInfo"
              },
              "inactive": {
                "type": "boolean"
              },
              "namespaceId": {
                "nullable": true,
                "type": "string",
                "description": "This field is deprecated and can be found in CommonEntityInfo. It will be removed from here in a future release.\n\nThis field has moved to CommonEntityInfo"
              },
              "deploymentType": {
                "nullable": true,
                "type": "string"
              }
            }
          },
          "resource": {
            "nullable": true,
            "type": "object",
            "properties": {
              "name": {
                "nullable": true,
                "type": "string"
              }
            }
          }
        }
      },
      "v1ListAlertsResponse": {
        "nullable": true,
        "type": "object",
        "properties": {
          "alerts": {
            "type": "array",
            "description": "List of alerts matching the search criteria.\nLimited to maximum 1000 alerts per request.",
            "items": {
              "nullable": true,
              "type": "object",
              "properties": {
                "id": {
                  "nullable": true,
                  "type": "string"
                },
                "lifecycleStage": {
                  "nullable": true,
                  "type": "string",
                  "default": "DEPLOY",
                  "enum": [
                    "DEPLOY",
                    "BUILD",
                    "RUNTIME"
                  ]
                },
                "time": {
                  "nullable": true,
                  "type": "string",
                  "format": "date-time"
                },
                "policy": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "id": {
                      "nullable": true,
                      "type": "string"
                    },
                    "name": {
                      "nullable": true,
                      "type": "string"
                    },
                    "severity": {
                      "nullable": true,
                      "type": "string",
                      "default": "UNSET_SEVERITY",
                      "enum": [
                        "UNSET_SEVERITY",
                        "LOW_SEVERITY",
                        "MEDIUM_SEVERITY",
                        "HIGH_SEVERITY",
                        "CRITICAL_SEVERITY"
                      ]
                    },
                    "description": {
                      "nullable": true,
                      "type": "string"
                    },
                    "categories": {
                      "type": "array",
                      "items": {
                        "nullable": true,
                        "type": "string"
                      }
                    },
                    "developerInternalFields": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "SORTName": {
                          "nullable": true,
                          "type": "string"
                        }
                      }
                    }
                  }
                },
                "state": {
                  "nullable": true,
                  "type": "string",
                  "description": " - ACTIVE: Alert is currently active and requires attention.\nThis is the default state for new alerts.\nActive alerts can be resolved but cannot be deleted.\n - RESOLVED: Alert has been resolved (manually or automatically).\nResolved alerts can be deleted for maintenance purposes.\nOnly RESOLVED alerts can be deleted via DeleteAlerts API.\n - ATTEMPTED: Enforcement action was attempted but failed.\nThese alerts can be resolved to acknowledge the failed enforcement.\nCommon for alerts where enforcement actions are not fully configured.",
                  "default": "ACTIVE",
                  "enum": [
                    "ACTIVE",
                    "RESOLVED",
                    "ATTEMPTED"
                  ]
                },
                "enforcementCount": {
                  "type": "integer",
                  "format": "int32"
                },
                "enforcementAction": {
                  "nullable": true,
                  "type": "string",
                  "description": " - FAIL_KUBE_REQUEST_ENFORCEMENT: FAIL_KUBE_REQUEST_ENFORCEMENT takes effect only if admission control webhook is enabled to listen on exec and port-forward events.\n - FAIL_DEPLOYMENT_CREATE_ENFORCEMENT: FAIL_DEPLOYMENT_CREATE_ENFORCEMENT takes effect only if admission control webhook is configured to enforce on object creates.\n - FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT: FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT takes effect only if admission control webhook is configured to enforce on object updates.",
                  "default": "UNSET_ENFORCEMENT",
                  "enum": [
                    "UNSET_ENFORCEMENT",
                    "SCALE_TO_ZERO_ENFORCEMENT",
                    "UNSATISFIABLE_NODE_CONSTRAINT_ENFORCEMENT",
                    "KILL_POD_ENFORCEMENT",
                    "FAIL_BUILD_ENFORCEMENT",
                    "FAIL_KUBE_REQUEST_ENFORCEMENT",
                    "FAIL_DEPLOYMENT_CREATE_ENFORCEMENT",
                    "FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT"
                  ]
                },
                "commonEntityInfo": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "clusterName": {
                      "nullable": true,
                      "type": "string"
                    },
                    "namespace": {
                      "nullable": true,
                      "type": "string"
                    },
                    "clusterId": {
                      "nullable": true,
                      "type": "string"
                    },
                    "namespaceId": {
                      "nullable": true,
                      "type": "string"
                    },
                    "resourceType": {
                      "title": "A special ListAlert-only enumeration of all resource types. Unlike Alert.Resource.ResourceType this also includes deployment as a type\nThis must be kept in sync with Alert.Resource.ResourceType (excluding the deployment value)",
                      "nullable": true,
                      "type": "string",
                      "default": "DEPLOYMENT",
                      "enum": [
                        "DEPLOYMENT",
                        "SECRETS",
                        "CONFIGMAPS",
                        "CLUSTER_ROLES",
                        "CLUSTER_ROLE_BINDINGS",
                        "NETWORK_POLICIES",
                        "SECURITY_CONTEXT_CONSTRAINTS",
                        "EGRESS_FIREWALLS"
                      ]
                    }
                  },
                  "description": "Fields common to all entities that an alert might belong to."
                },
                "deployment": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "id": {
                      "nullable": true,
                      "type": "string"
                    },
                    "name": {
                      "nullable": true,
                      "type": "string"
                    },
                    "clusterName": {
                      "nullable": true,
                      "type": "string",
                      "description": "This field is deprecated and can be found in CommonEntityInfo. It will be removed from here in a future release.\n\nThis field has moved to CommonEntityInfo"
                    },
                    "namespace": {
                      "nullable": true,
                      "type": "string",
                      "description": "This field is deprecated and can be found in CommonEntityInfo. It will be removed from here in a future release.\n\nThis field has moved to CommonEntityInfo"
                    },
                    "clusterId": {
                      "nullable": true,
                      "type": "string",
                      "description": "This field is deprecated and can be found in CommonEntityInfo. It will be removed from here in a future release.\n\nThis field has moved to CommonEntityInfo"
                    },
                    "inactive": {
                      "type": "boolean"
                    },
                    "namespaceId": {
                      "nullable": true,
                      "type": "string",
                      "description": "This field is deprecated and can be found in CommonEntityInfo. It will be removed from here in a future release.\n\nThis field has moved to CommonEntityInfo"
                    },
                    "deploymentType": {
                      "nullable": true,
                      "type": "string"
                    }
                  }
                },
                "resource": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "name": {
                      "nullable": true,
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        },
        "description": "ListAlertsResponse contains the list of alerts matching the request criteria."
      },
      "v1DeleteAlertsResponse": {
        "nullable": true,
        "type": "object",
        "properties": {
          "numDeleted": {
            "type": "integer",
            "description": "Number of alerts that were (or would be) deleted.",
            "format": "int64"
          },
          "dryRun": {
            "type": "boolean",
            "description": "True if this was a dry-run (no actual deletion occurred).\nFalse if alerts were actually deleted."
          }
        },
        "description": "DeleteAlertsResponse contains the result of a delete operation."
      },
      "storageEventSource": {
        "nullable": true,
        "type": "string",
        "default": "NOT_APPLICABLE",
        "enum": [
          "NOT_APPLICABLE",
          "DEPLOYMENT_EVENT",
          "AUDIT_LOG_EVENT"
        ]
      },
      "storageScopeLabel": {
        "nullable": true,
        "type": "object",
        "properties": {
          "key": {
            "nullable": true,
            "type": "string"
          },
          "value": {
            "nullable": true,
            "type": "string"
          }
        }
      },
      "storageScope": {
        "nullable": true,
        "type": "object",
        "properties": {
          "cluster": {
            "nullable": true,
            "type": "string"
          },
          "namespace": {
            "nullable": true,
            "type": "string"
          },
          "label": {
            "nullable": true,
            "type": "object",
            "properties": {
              "key": {
                "nullable": true,
                "type": "string"
              },
              "value": {
                "nullable": true,
                "type": "string"
              }
            }
          }
        }
      },
      "storageExclusionDeployment": {
        "nullable": true,
        "type": "object",
        "properties": {
          "name": {
            "title": "Name of the deployment to exclude. Optional if scope is provided.\nValidation: Must be provided if scope is not specified",
            "nullable": true,
            "type": "string"
          },
          "scope": {
            "nullable": true,
            "type": "object",
            "properties": {
              "cluster": {
                "nullable": true,
                "type": "string"
              },
              "namespace": {
                "nullable": true,
                "type": "string"
              },
              "label": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "key": {
                    "nullable": true,
                    "type": "string"
                  },
                  "value": {
                    "nullable": true,
                    "type": "string"
                  }
                }
              }
            }
          }
        }
      },
      "storageExclusionImage": {
        "nullable": true,
        "type": "object",
        "properties": {
          "name": {
            "title": "Name of the image to exclude.\nValidation: Must be non-empty",
            "nullable": true,
            "type": "string"
          }
        }
      },
      "storageExclusion": {
        "nullable": true,
        "type": "object",
        "properties": {
          "name": {
            "nullable": true,
            "type": "string",
            "description": "Name of the exclusion. Used for identification and documentation."
          },
          "deployment": {
            "nullable": true,
            "type": "object",
            "properties": {
              "name": {
                "title": "Name of the deployment to exclude. Optional if scope is provided.\nValidation: Must be provided if scope is not specified",
                "nullable": true,
                "type": "string"
              },
              "scope": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "cluster": {
                    "nullable": true,
                    "type": "string"
                  },
                  "namespace": {
                    "nullable": true,
                    "type": "string"
                  },
                  "label": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "key": {
                        "nullable": true,
                        "type": "string"
                      },
                      "value": {
                        "nullable": true,
                        "type": "string"
                      }
                    }
                  }
                }
              }
            }
          },
          "image": {
            "nullable": true,
            "type": "object",
            "properties": {
              "name": {
                "title": "Name of the image to exclude.\nValidation: Must be non-empty",
                "nullable": true,
                "type": "string"
              }
            }
          },
          "expiration": {
            "nullable": true,
            "type": "string",
            "description": "Expiration timestamp for this exclusion.\nWhen expired, the exclusion is automatically removed.",
            "format": "date-time"
          }
        }
      },
      "storageBooleanOperator": {
        "nullable": true,
        "type": "string",
        "default": "OR",
        "enum": [
          "OR",
          "AND"
        ]
      },
      "storagePolicyValue": {
        "nullable": true,
        "type": "object",
        "properties": {
          "value": {
            "title": "The actual value for the policy criterion.\nValidation: Must match the expected format for the field type\nExamples:\n- CVE: \"CVE-2021-1234\"\n- Image Tag: \"latest\"\n- Environment Variable: \"UNSET=key=value\" or \"SECRET_KEY=key=\"\n- Dockerfile Line: \"ADD=.\" or \"RUN=apt-get update\"\n- Process Name: \"nginx\"\n- Network Flow: \"tcp:80\"",
            "nullable": true,
            "type": "string"
          }
        }
      },
      "storagePolicyGroup": {
        "nullable": true,
        "type": "object",
        "properties": {
          "fieldName": {
            "title": "Defines which field on a deployment or image this PolicyGroup evaluates.\nSee https://docs.openshift.com/acs/operating/manage-security-policies.html#policy-criteria_manage-security-policies for a complete list of possible values.\nValidation Requirements:\n- Must be a valid field name for the specified lifecycle stages\n- Field must support the specified boolean operator\n- Field must allow negation if negate=true\n- Field must support multiple values if more than one value is provided\n- Some fields have special restrictions (e.g., ImageSignatureVerifiedBy cannot use AND operator)",
            "nullable": true,
            "type": "string"
          },
          "booleanOperator": {
            "nullable": true,
            "type": "string",
            "default": "OR",
            "enum": [
              "OR",
              "AND"
            ]
          },
          "negate": {
            "title": "Determines if the evaluation of this PolicyGroup is negated. Default to false.\nValidation: Must be allowed for the field type\n- Some fields cannot be negated (negationForbidden=true)",
            "type": "boolean"
          },
          "values": {
            "title": "List of values for the specified field.\nValidation Requirements:\n- Must have at least one value\n- Values must match the expected regex pattern for the field type\n- Some fields only support single values\n- Values must be valid for the field's data type and constraints\n- Environment variable values have special format requirements\n- Dockerfile line values have special restrictions (e.g., no FROM with strict validation)",
            "type": "array",
            "items": {
              "nullable": true,
              "type": "object",
              "properties": {
                "value": {
                  "title": "The actual value for the policy criterion.\nValidation: Must match the expected format for the field type\nExamples:\n- CVE: \"CVE-2021-1234\"\n- Image Tag: \"latest\"\n- Environment Variable: \"UNSET=key=value\" or \"SECRET_KEY=key=\"\n- Dockerfile Line: \"ADD=.\" or \"RUN=apt-get update\"\n- Process Name: \"nginx\"\n- Network Flow: \"tcp:80\"",
                  "nullable": true,
                  "type": "string"
                }
              }
            }
          }
        }
      },
      "storagePolicySection": {
        "nullable": true,
        "type": "object",
        "properties": {
          "sectionName": {
            "nullable": true,
            "type": "string",
            "description": "Name of the policy section. Must be unique within the policy.\nUsed for organizing policy criteria into logical groups."
          },
          "policyGroups": {
            "title": "The set of policy groups that make up this section. Each group can be considered an individual criterion.\nValidation Requirements:\n- Each group must have a valid fieldName and at least one value\n- Field names must be valid for the specified lifecycle stages\n- Values must match the expected format for each field type\n- Boolean operators must be compatible with field requirements\n- Negation must be allowed for the field type\n- Runtime criteria must be in separate sections\n- Audit log policies require both KubeResource and KubeAPIVerb criteria",
            "type": "array",
            "items": {
              "nullable": true,
              "type": "object",
              "properties": {
                "fieldName": {
                  "title": "Defines which field on a deployment or image this PolicyGroup evaluates.\nSee https://docs.openshift.com/acs/operating/manage-security-policies.html#policy-criteria_manage-security-policies for a complete list of possible values.\nValidation Requirements:\n- Must be a valid field name for the specified lifecycle stages\n- Field must support the specified boolean operator\n- Field must allow negation if negate=true\n- Field must support multiple values if more than one value is provided\n- Some fields have special restrictions (e.g., ImageSignatureVerifiedBy cannot use AND operator)",
                  "nullable": true,
                  "type": "string"
                },
                "booleanOperator": {
                  "nullable": true,
                  "type": "string",
                  "default": "OR",
                  "enum": [
                    "OR",
                    "AND"
                  ]
                },
                "negate": {
                  "title": "Determines if the evaluation of this PolicyGroup is negated. Default to false.\nValidation: Must be allowed for the field type\n- Some fields cannot be negated (negationForbidden=true)",
                  "type": "boolean"
                },
                "values": {
                  "title": "List of values for the specified field.\nValidation Requirements:\n- Must have at least one value\n- Values must match the expected regex pattern for the field type\n- Some fields only support single values\n- Values must be valid for the field's data type and constraints\n- Environment variable values have special format requirements\n- Dockerfile line values have special restrictions (e.g., no FROM with strict validation)",
                  "type": "array",
                  "items": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "value": {
                        "title": "The actual value for the policy criterion.\nValidation: Must match the expected format for the field type\nExamples:\n- CVE: \"CVE-2021-1234\"\n- Image Tag: \"latest\"\n- Environment Variable: \"UNSET=key=value\" or \"SECRET_KEY=key=\"\n- Dockerfile Line: \"ADD=.\" or \"RUN=apt-get update\"\n- Process Name: \"nginx\"\n- Network Flow: \"tcp:80\"",
                        "nullable": true,
                        "type": "string"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      },
      "PolicyMitreAttackVectors": {
        "nullable": true,
        "type": "object",
        "properties": {
          "tactic": {
            "nullable": true,
            "type": "string"
          },
          "techniques": {
            "type": "array",
            "items": {
              "nullable": true,
              "type": "string"
            }
          }
        }
      },
      "storagePolicySource": {
        "nullable": true,
        "type": "string",
        "default": "IMPERATIVE",
        "enum": [
          "IMPERATIVE",
          "DECLARATIVE"
        ]
      },
      "storagePolicy": {
        "title": "Next tag: 28",
        "nullable": true,
        "type": "object",
        "properties": {
          "id": {
            "title": "Unique identifier generated by the system. Must be empty for new policies.\nFormat: UUID v4, auto-generated during creation",
            "nullable": true,
            "type": "string"
          },
          "name": {
            "title": "Name of the policy. Must be unique across all policies.\nValidation: 5-128 characters, no newlines or dollar signs\nPattern: ^[^\\n\\r\\$]{5,128}$",
            "nullable": true,
            "type": "string"
          },
          "description": {
            "title": "Free-form text description of this policy.\nValidation: Max 800 characters, no dollar signs\nPattern: ^[^\\$]{0,800}$",
            "nullable": true,
            "type": "string"
          },
          "rationale": {
            "nullable": true,
            "type": "string",
            "description": "Business justification for why this policy exists.\nUsed for compliance and audit purposes."
          },
          "remediation": {
            "nullable": true,
            "type": "string",
            "description": "Describes how to remediate a violation of this policy.\nShould be actionable and specific to the policy type."
          },
          "disabled": {
            "title": "Toggles whether or not this policy will be executing and actively firing alerts.\nDefault: false",
            "type": "boolean"
          },
          "categories": {
            "title": "List of categories that this policy falls under. Category names must already exist in Central.\nValidation: At least one category required, no duplicates",
            "type": "array",
            "items": {
              "nullable": true,
              "type": "string"
            }
          },
          "lifecycleStages": {
            "title": "Describes which policy lifecycle stages this policy applies to. Choices are DEPLOY, BUILD, and RUNTIME.\nValidation: At least one stage required\n- BUILD: Must contain image-related criteria only\n- DEPLOY: Cannot contain runtime criteria\n- RUNTIME: Must contain at least one runtime criterion",
            "type": "array",
            "items": {
              "nullable": true,
              "type": "string",
              "default": "DEPLOY",
              "enum": [
                "DEPLOY",
                "BUILD",
                "RUNTIME"
              ]
            }
          },
          "eventSource": {
            "nullable": true,
            "type": "string",
            "default": "NOT_APPLICABLE",
            "enum": [
              "NOT_APPLICABLE",
              "DEPLOYMENT_EVENT",
              "AUDIT_LOG_EVENT"
            ]
          },
          "exclusions": {
            "title": "Define deployments or images that should be excluded from this policy.\nValidation:\n- Deployment exclusions: Only valid for DEPLOY and RUNTIME lifecycles\n- Image exclusions: Only valid for BUILD lifecycle\n- Must have at least one criteria (name, scope, or image)",
            "type": "array",
            "items": {
              "nullable": true,
              "type": "object",
              "properties": {
                "name": {
                  "nullable": true,
                  "type": "string",
                  "description": "Name of the exclusion. Used for identification and documentation."
                },
                "deployment": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "name": {
                      "title": "Name of the deployment to exclude. Optional if scope is provided.\nValidation: Must be provided if scope is not specified",
                      "nullable": true,
                      "type": "string"
                    },
                    "scope": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "cluster": {
                          "nullable": true,
                          "type": "string"
                        },
                        "namespace": {
                          "nullable": true,
                          "type": "string"
                        },
                        "label": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "key": {
                              "nullable": true,
                              "type": "string"
                            },
                            "value": {
                              "nullable": true,
                              "type": "string"
                            }
                          }
                        }
                      }
                    }
                  }
                },
                "image": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "name": {
                      "title": "Name of the image to exclude.\nValidation: Must be non-empty",
                      "nullable": true,
                      "type": "string"
                    }
                  }
                },
                "expiration": {
                  "nullable": true,
                  "type": "string",
                  "description": "Expiration timestamp for this exclusion.\nWhen expired, the exclusion is automatically removed.",
                  "format": "date-time"
                }
              }
            }
          },
          "scope": {
            "title": "Defines clusters, namespaces, and deployments that should be included in this policy.\nNo scopes defined includes everything.\nValidation: Must have at least one field populated (cluster, namespace, or label)",
            "type": "array",
            "items": {
              "nullable": true,
              "type": "object",
              "properties": {
                "cluster": {
                  "nullable": true,
                  "type": "string"
                },
                "namespace": {
                  "nullable": true,
                  "type": "string"
                },
                "label": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "key": {
                      "nullable": true,
                      "type": "string"
                    },
                    "value": {
                      "nullable": true,
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "severity": {
            "nullable": true,
            "type": "string",
            "default": "UNSET_SEVERITY",
            "enum": [
              "UNSET_SEVERITY",
              "LOW_SEVERITY",
              "MEDIUM_SEVERITY",
              "HIGH_SEVERITY",
              "CRITICAL_SEVERITY"
            ]
          },
          "enforcementActions": {
            "title": "Lists the enforcement actions to take when a violation from this policy is identified.\nValidation: Must be compatible with lifecycle stages\n- FAIL_BUILD_ENFORCEMENT: BUILD lifecycle only\n- SCALE_TO_ZERO_ENFORCEMENT: DEPLOY lifecycle only\n- UNSATISFIABLE_NODE_CONSTRAINT_ENFORCEMENT: DEPLOY lifecycle only\n- KILL_POD_ENFORCEMENT: RUNTIME lifecycle only\n- FAIL_KUBE_REQUEST_ENFORCEMENT: RUNTIME lifecycle only\n- FAIL_DEPLOYMENT_CREATE_ENFORCEMENT: DEPLOY lifecycle only\n- FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT: DEPLOY lifecycle only\n- Audit log policies: No enforcement actions allowed",
            "type": "array",
            "items": {
              "nullable": true,
              "type": "string",
              "description": " - FAIL_KUBE_REQUEST_ENFORCEMENT: FAIL_KUBE_REQUEST_ENFORCEMENT takes effect only if admission control webhook is enabled to listen on exec and port-forward events.\n - FAIL_DEPLOYMENT_CREATE_ENFORCEMENT: FAIL_DEPLOYMENT_CREATE_ENFORCEMENT takes effect only if admission control webhook is configured to enforce on object creates.\n - FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT: FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT takes effect only if admission control webhook is configured to enforce on object updates.",
              "default": "UNSET_ENFORCEMENT",
              "enum": [
                "UNSET_ENFORCEMENT",
                "SCALE_TO_ZERO_ENFORCEMENT",
                "UNSATISFIABLE_NODE_CONSTRAINT_ENFORCEMENT",
                "KILL_POD_ENFORCEMENT",
                "FAIL_BUILD_ENFORCEMENT",
                "FAIL_KUBE_REQUEST_ENFORCEMENT",
                "FAIL_DEPLOYMENT_CREATE_ENFORCEMENT",
                "FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT"
              ]
            }
          },
          "notifiers": {
            "title": "List of IDs of the notifiers that should be triggered when a violation from this policy is identified.\nIDs should be in the form of a UUID and are found through the Central API.\nValidation: All notifier IDs must reference existing notifiers",
            "type": "array",
            "items": {
              "nullable": true,
              "type": "string"
            }
          },
          "lastUpdated": {
            "nullable": true,
            "type": "string",
            "description": "Timestamp when the policy was last updated. Auto-generated during creation/update.",
            "format": "date-time"
          },
          "SORTName": {
            "nullable": true,
            "type": "string",
            "description": "For internal use only."
          },
          "SORTLifecycleStage": {
            "nullable": true,
            "type": "string",
            "description": "For internal use only."
          },
          "SORTEnforcement": {
            "type": "boolean",
            "description": "For internal use only."
          },
          "policyVersion": {
            "title": "Policy version. Must be \"1.1\" (current supported version).\nValidation: Only version 1.1 is supported",
            "nullable": true,
            "type": "string"
          },
          "policySections": {
            "title": "PolicySections define the violation criteria for this policy.\nValidation Requirements:\n- Each section must have a unique sectionName\n- Each policy group must have a valid fieldName and at least one value\n- Field names must be valid for the specified lifecycle stages\n- Values must match the expected format for each field type\n- Boolean operators must be compatible with field requirements\n- Negation must be allowed for the field type\n- Runtime policies must contain at least one runtime criterion\n- Runtime criteria must be in separate sections\n- Audit log policies require both KubeResource and KubeAPIVerb criteria",
            "type": "array",
            "items": {
              "nullable": true,
              "type": "object",
              "properties": {
                "sectionName": {
                  "nullable": true,
                  "type": "string",
                  "description": "Name of the policy section. Must be unique within the policy.\nUsed for organizing policy criteria into logical groups."
                },
                "policyGroups": {
                  "title": "The set of policy groups that make up this section. Each group can be considered an individual criterion.\nValidation Requirements:\n- Each group must have a valid fieldName and at least one value\n- Field names must be valid for the specified lifecycle stages\n- Values must match the expected format for each field type\n- Boolean operators must be compatible with field requirements\n- Negation must be allowed for the field type\n- Runtime criteria must be in separate sections\n- Audit log policies require both KubeResource and KubeAPIVerb criteria",
                  "type": "array",
                  "items": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "fieldName": {
                        "title": "Defines which field on a deployment or image this PolicyGroup evaluates.\nSee https://docs.openshift.com/acs/operating/manage-security-policies.html#policy-criteria_manage-security-policies for a complete list of possible values.\nValidation Requirements:\n- Must be a valid field name for the specified lifecycle stages\n- Field must support the specified boolean operator\n- Field must allow negation if negate=true\n- Field must support multiple values if more than one value is provided\n- Some fields have special restrictions (e.g., ImageSignatureVerifiedBy cannot use AND operator)",
                        "nullable": true,
                        "type": "string"
                      },
                      "booleanOperator": {
                        "nullable": true,
                        "type": "string",
                        "default": "OR",
                        "enum": [
                          "OR",
                          "AND"
                        ]
                      },
                      "negate": {
                        "title": "Determines if the evaluation of this PolicyGroup is negated. Default to false.\nValidation: Must be allowed for the field type\n- Some fields cannot be negated (negationForbidden=true)",
                        "type": "boolean"
                      },
                      "values": {
                        "title": "List of values for the specified field.\nValidation Requirements:\n- Must have at least one value\n- Values must match the expected regex pattern for the field type\n- Some fields only support single values\n- Values must be valid for the field's data type and constraints\n- Environment variable values have special format requirements\n- Dockerfile line values have special restrictions (e.g., no FROM with strict validation)",
                        "type": "array",
                        "items": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "value": {
                              "title": "The actual value for the policy criterion.\nValidation: Must match the expected format for the field type\nExamples:\n- CVE: \"CVE-2021-1234\"\n- Image Tag: \"latest\"\n- Environment Variable: \"UNSET=key=value\" or \"SECRET_KEY=key=\"\n- Dockerfile Line: \"ADD=.\" or \"RUN=apt-get update\"\n- Process Name: \"nginx\"\n- Network Flow: \"tcp:80\"",
                              "nullable": true,
                              "type": "string"
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "mitreAttackVectors": {
            "type": "array",
            "description": "MITRE ATT&CK framework mappings for this policy.\nUsed for threat intelligence and compliance reporting.",
            "items": {
              "nullable": true,
              "type": "object",
              "properties": {
                "tactic": {
                  "nullable": true,
                  "type": "string"
                },
                "techniques": {
                  "type": "array",
                  "items": {
                    "nullable": true,
                    "type": "string"
                  }
                }
              }
            }
          },
          "criteriaLocked": {
            "type": "boolean",
            "description": "Read-only field. If true, the policy's criteria fields are rendered read-only."
          },
          "mitreVectorsLocked": {
            "type": "boolean",
            "description": "Read-only field. If true, the policy's MITRE ATT&CK fields are rendered read-only."
          },
          "isDefault": {
            "type": "boolean",
            "description": "Read-only field. Indicates the policy is a default policy if true and a custom policy if false."
          },
          "source": {
            "nullable": true,
            "type": "string",
            "default": "IMPERATIVE",
            "enum": [
              "IMPERATIVE",
              "DECLARATIVE"
            ]
          }
        }
      },
      "storageImageName": {
        "nullable": true,
        "type": "object",
        "properties": {
          "registry": {
            "nullable": true,
            "type": "string"
          },
          "remote": {
            "nullable": true,
            "type": "string"
          },
          "tag": {
            "nullable": true,
            "type": "string"
          },
          "fullName": {
            "nullable": true,
            "type": "string"
          }
        }
      },
      "storageContainerImage": {
        "title": "Next tag: 13",
        "nullable": true,
        "type": "object",
        "properties": {
          "id": {
            "nullable": true,
            "type": "string"
          },
          "name": {
            "nullable": true,
            "type": "object",
            "properties": {
              "registry": {
                "nullable": true,
                "type": "string"
              },
              "remote": {
                "nullable": true,
                "type": "string"
              },
              "tag": {
                "nullable": true,
                "type": "string"
              },
              "fullName": {
                "nullable": true,
                "type": "string"
              }
            }
          },
          "notPullable": {
            "type": "boolean"
          },
          "isClusterLocal": {
            "type": "boolean"
          },
          "idV2": {
            "nullable": true,
            "type": "string"
          }
        }
      },
      "AlertDeploymentContainer": {
        "nullable": true,
        "type": "object",
        "properties": {
          "image": {
            "title": "Next tag: 13",
            "nullable": true,
            "type": "object",
            "properties": {
              "id": {
                "nullable": true,
                "type": "string"
              },
              "name": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "registry": {
                    "nullable": true,
                    "type": "string"
                  },
                  "remote": {
                    "nullable": true,
                    "type": "string"
                  },
                  "tag": {
                    "nullable": true,
                    "type": "string"
                  },
                  "fullName": {
                    "nullable": true,
                    "type": "string"
                  }
                }
              },
              "notPullable": {
                "type": "boolean"
              },
              "isClusterLocal": {
                "type": "boolean"
              },
              "idV2": {
                "nullable": true,
                "type": "string"
              }
            }
          },
          "name": {
            "nullable": true,
            "type": "string",
            "description": "Name of the container within the deployment."
          }
        }
      },
      "storageAlertDeployment": {
        "nullable": true,
        "type": "object",
        "properties": {
          "id": {
            "nullable": true,
            "type": "string",
            "description": "Unique identifier for the deployment."
          },
          "name": {
            "nullable": true,
            "type": "string",
            "description": "Human-readable name of the deployment."
          },
          "type": {
            "nullable": true,
            "type": "string",
            "description": "Type of deployment (e.g., \"Deployment\", \"DaemonSet\", \"StatefulSet\")."
          },
          "namespace": {
            "nullable": true,
            "type": "string",
            "description": "Kubernetes namespace containing the deployment.\nThis field has to be duplicated in Alert for scope management and search.\n\nThis field has to be duplicated in Alert for scope management and search."
          },
          "labels": {
            "nullable": true,
            "type": "object",
            "additionalProperties": {
              "nullable": true,
              "type": "string"
            },
            "description": "Kubernetes labels applied to the deployment."
          },
          "clusterId": {
            "nullable": true,
            "type": "string",
            "description": "Unique identifier for the cluster containing the deployment.\nThis field has to be duplicated in Alert for scope management and search.\n\nThis field has to be duplicated in Alert for scope management and search."
          },
          "clusterName": {
            "nullable": true,
            "type": "string",
            "description": "Human-readable name of the cluster containing the deployment.\nThis field has to be duplicated in Alert for scope management and search.\n\nThis field has to be duplicated in Alert for scope management and search."
          },
          "containers": {
            "type": "array",
            "description": "List of containers in the deployment.",
            "items": {
              "nullable": true,
              "type": "object",
              "properties": {
                "image": {
                  "title": "Next tag: 13",
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "id": {
                      "nullable": true,
                      "type": "string"
                    },
                    "name": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "registry": {
                          "nullable": true,
                          "type": "string"
                        },
                        "remote": {
                          "nullable": true,
                          "type": "string"
                        },
                        "tag": {
                          "nullable": true,
                          "type": "string"
                        },
                        "fullName": {
                          "nullable": true,
                          "type": "string"
                        }
                      }
                    },
                    "notPullable": {
                      "type": "boolean"
                    },
                    "isClusterLocal": {
                      "type": "boolean"
                    },
                    "idV2": {
                      "nullable": true,
                      "type": "string"
                    }
                  }
                },
                "name": {
                  "nullable": true,
                  "type": "string",
                  "description": "Name of the container within the deployment."
                }
              }
            }
          },
          "annotations": {
            "nullable": true,
            "type": "object",
            "additionalProperties": {
              "nullable": true,
              "type": "string"
            },
            "description": "Kubernetes annotations applied to the deployment."
          },
          "inactive": {
            "type": "boolean",
            "description": "Whether the deployment is currently inactive."
          }
        }
      },
      "AlertResourceResourceType": {
        "nullable": true,
        "type": "string",
        "default": "UNKNOWN",
        "enum": [
          "UNKNOWN",
          "SECRETS",
          "CONFIGMAPS",
          "CLUSTER_ROLES",
          "CLUSTER_ROLE_BINDINGS",
          "NETWORK_POLICIES",
          "SECURITY_CONTEXT_CONSTRAINTS",
          "EGRESS_FIREWALLS"
        ]
      },
      "storageAlertResource": {
        "title": "Represents an alert on a kubernetes resource other than a deployment (configmaps, secrets, etc.)",
        "nullable": true,
        "type": "object",
        "properties": {
          "resourceType": {
            "nullable": true,
            "type": "string",
            "default": "UNKNOWN",
            "enum": [
              "UNKNOWN",
              "SECRETS",
              "CONFIGMAPS",
              "CLUSTER_ROLES",
              "CLUSTER_ROLE_BINDINGS",
              "NETWORK_POLICIES",
              "SECURITY_CONTEXT_CONSTRAINTS",
              "EGRESS_FIREWALLS"
            ]
          },
          "name": {
            "nullable": true,
            "type": "string",
            "description": "Name of the resource that triggered the alert."
          },
          "clusterId": {
            "nullable": true,
            "type": "string",
            "description": "Unique identifier for the cluster containing the resource.\nThis field has to be duplicated in Alert for scope management and search.\n\nThis field has to be duplicated in Alert for scope management and search."
          },
          "clusterName": {
            "nullable": true,
            "type": "string",
            "description": "Human-readable name of the cluster containing the resource.\nThis field has to be duplicated in Alert for scope management and search.\n\nThis field has to be duplicated in Alert for scope management and search."
          },
          "namespace": {
            "nullable": true,
            "type": "string",
            "description": "Kubernetes namespace containing the resource.\nThis field has to be duplicated in Alert for scope management and search.\n\nThis field has to be duplicated in Alert for scope management and search."
          },
          "namespaceId": {
            "nullable": true,
            "type": "string",
            "description": "Unique identifier for the namespace containing the resource.\nThis field has to be duplicated in Alert for scope management and search.\n\nThis field has to be duplicated in Alert for scope management and search."
          }
        }
      },
      "KeyValueAttrsKeyValueAttr": {
        "nullable": true,
        "type": "object",
        "properties": {
          "key": {
            "nullable": true,
            "type": "string"
          },
          "value": {
            "nullable": true,
            "type": "string"
          }
        }
      },
      "ViolationKeyValueAttrs": {
        "nullable": true,
        "type": "object",
        "properties": {
          "attrs": {
            "type": "array",
            "items": {
              "nullable": true,
              "type": "object",
              "properties": {
                "key": {
                  "nullable": true,
                  "type": "string"
                },
                "value": {
                  "nullable": true,
                  "type": "string"
                }
              }
            }
          }
        }
      },
      "storageL4Protocol": {
        "nullable": true,
        "type": "string",
        "default": "L4_PROTOCOL_UNKNOWN",
        "enum": [
          "L4_PROTOCOL_UNKNOWN",
          "L4_PROTOCOL_TCP",
          "L4_PROTOCOL_UDP",
          "L4_PROTOCOL_ICMP",
          "L4_PROTOCOL_RAW",
          "L4_PROTOCOL_SCTP",
          "L4_PROTOCOL_ANY"
        ]
      },
      "storageNetworkEntityInfoType": {
        "title": "- INTERNAL_ENTITIES: INTERNAL_ENTITIES is for grouping all internal entities under a single network graph node",
        "nullable": true,
        "type": "string",
        "default": "UNKNOWN_TYPE",
        "enum": [
          "UNKNOWN_TYPE",
          "DEPLOYMENT",
          "INTERNET",
          "LISTEN_ENDPOINT",
          "EXTERNAL_SOURCE",
          "INTERNAL_ENTITIES"
        ]
      },
      "NetworkFlowInfoEntity": {
        "nullable": true,
        "type": "object",
        "properties": {
          "name": {
            "nullable": true,
            "type": "string"
          },
          "entityType": {
            "title": "- INTERNAL_ENTITIES: INTERNAL_ENTITIES is for grouping all internal entities under a single network graph node",
            "nullable": true,
            "type": "string",
            "default": "UNKNOWN_TYPE",
            "enum": [
              "UNKNOWN_TYPE",
              "DEPLOYMENT",
              "INTERNET",
              "LISTEN_ENDPOINT",
              "EXTERNAL_SOURCE",
              "INTERNAL_ENTITIES"
            ]
          },
          "deploymentNamespace": {
            "nullable": true,
            "type": "string"
          },
          "deploymentType": {
            "nullable": true,
            "type": "string"
          },
          "port": {
            "type": "integer",
            "format": "int32"
          }
        }
      },
      "ViolationNetworkFlowInfo": {
        "nullable": true,
        "type": "object",
        "properties": {
          "protocol": {
            "nullable": true,
            "type": "string",
            "default": "L4_PROTOCOL_UNKNOWN",
            "enum": [
              "L4_PROTOCOL_UNKNOWN",
              "L4_PROTOCOL_TCP",
              "L4_PROTOCOL_UDP",
              "L4_PROTOCOL_ICMP",
              "L4_PROTOCOL_RAW",
              "L4_PROTOCOL_SCTP",
              "L4_PROTOCOL_ANY"
            ]
          },
          "source": {
            "nullable": true,
            "type": "object",
            "properties": {
              "name": {
                "nullable": true,
                "type": "string"
              },
              "entityType": {
                "title": "- INTERNAL_ENTITIES: INTERNAL_ENTITIES is for grouping all internal entities under a single network graph node",
                "nullable": true,
                "type": "string",
                "default": "UNKNOWN_TYPE",
                "enum": [
                  "UNKNOWN_TYPE",
                  "DEPLOYMENT",
                  "INTERNET",
                  "LISTEN_ENDPOINT",
                  "EXTERNAL_SOURCE",
                  "INTERNAL_ENTITIES"
                ]
              },
              "deploymentNamespace": {
                "nullable": true,
                "type": "string"
              },
              "deploymentType": {
                "nullable": true,
                "type": "string"
              },
              "port": {
                "type": "integer",
                "format": "int32"
              }
            }
          },
          "destination": {
            "nullable": true,
            "type": "object",
            "properties": {
              "name": {
                "nullable": true,
                "type": "string"
              },
              "entityType": {
                "title": "- INTERNAL_ENTITIES: INTERNAL_ENTITIES is for grouping all internal entities under a single network graph node",
                "nullable": true,
                "type": "string",
                "default": "UNKNOWN_TYPE",
                "enum": [
                  "UNKNOWN_TYPE",
                  "DEPLOYMENT",
                  "INTERNET",
                  "LISTEN_ENDPOINT",
                  "EXTERNAL_SOURCE",
                  "INTERNAL_ENTITIES"
                ]
              },
              "deploymentNamespace": {
                "nullable": true,
                "type": "string"
              },
              "deploymentType": {
                "nullable": true,
                "type": "string"
              },
              "port": {
                "type": "integer",
                "format": "int32"
              }
            }
          }
        }
      },
      "AlertViolationType": {
        "title": "- GENERIC: Generic policy violation\n - K8S_EVENT: Kubernetes event violation\n - NETWORK_FLOW: Network flow violation\n - NETWORK_POLICY: Network policy violation",
        "nullable": true,
        "type": "string",
        "default": "GENERIC",
        "enum": [
          "GENERIC",
          "K8S_EVENT",
          "NETWORK_FLOW",
          "NETWORK_POLICY"
        ]
      },
      "AlertViolation": {
        "nullable": true,
        "type": "object",
        "properties": {
          "message": {
            "nullable": true,
            "type": "string",
            "description": "Human-readable message describing the violation."
          },
          "keyValueAttrs": {
            "nullable": true,
            "type": "object",
            "properties": {
              "attrs": {
                "type": "array",
                "items": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "key": {
                      "nullable": true,
                      "type": "string"
                    },
                    "value": {
                      "nullable": true,
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "networkFlowInfo": {
            "nullable": true,
            "type": "object",
            "properties": {
              "protocol": {
                "nullable": true,
                "type": "string",
                "default": "L4_PROTOCOL_UNKNOWN",
                "enum": [
                  "L4_PROTOCOL_UNKNOWN",
                  "L4_PROTOCOL_TCP",
                  "L4_PROTOCOL_UDP",
                  "L4_PROTOCOL_ICMP",
                  "L4_PROTOCOL_RAW",
                  "L4_PROTOCOL_SCTP",
                  "L4_PROTOCOL_ANY"
                ]
              },
              "source": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "name": {
                    "nullable": true,
                    "type": "string"
                  },
                  "entityType": {
                    "title": "- INTERNAL_ENTITIES: INTERNAL_ENTITIES is for grouping all internal entities under a single network graph node",
                    "nullable": true,
                    "type": "string",
                    "default": "UNKNOWN_TYPE",
                    "enum": [
                      "UNKNOWN_TYPE",
                      "DEPLOYMENT",
                      "INTERNET",
                      "LISTEN_ENDPOINT",
                      "EXTERNAL_SOURCE",
                      "INTERNAL_ENTITIES"
                    ]
                  },
                  "deploymentNamespace": {
                    "nullable": true,
                    "type": "string"
                  },
                  "deploymentType": {
                    "nullable": true,
                    "type": "string"
                  },
                  "port": {
                    "type": "integer",
                    "format": "int32"
                  }
                }
              },
              "destination": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "name": {
                    "nullable": true,
                    "type": "string"
                  },
                  "entityType": {
                    "title": "- INTERNAL_ENTITIES: INTERNAL_ENTITIES is for grouping all internal entities under a single network graph node",
                    "nullable": true,
                    "type": "string",
                    "default": "UNKNOWN_TYPE",
                    "enum": [
                      "UNKNOWN_TYPE",
                      "DEPLOYMENT",
                      "INTERNET",
                      "LISTEN_ENDPOINT",
                      "EXTERNAL_SOURCE",
                      "INTERNAL_ENTITIES"
                    ]
                  },
                  "deploymentNamespace": {
                    "nullable": true,
                    "type": "string"
                  },
                  "deploymentType": {
                    "nullable": true,
                    "type": "string"
                  },
                  "port": {
                    "type": "integer",
                    "format": "int32"
                  }
                }
              }
            }
          },
          "type": {
            "title": "- GENERIC: Generic policy violation\n - K8S_EVENT: Kubernetes event violation\n - NETWORK_FLOW: Network flow violation\n - NETWORK_POLICY: Network policy violation",
            "nullable": true,
            "type": "string",
            "default": "GENERIC",
            "enum": [
              "GENERIC",
              "K8S_EVENT",
              "NETWORK_FLOW",
              "NETWORK_POLICY"
            ]
          },
          "time": {
            "nullable": true,
            "type": "string",
            "description": "Indicates violation time. This field differs from top-level field 'time' which represents last time the alert\noccurred in case of multiple occurrences of the policy alert. As of 55.0, this field is set only for kubernetes\nevent violations, but may not be limited to it in future.",
            "format": "date-time"
          }
        }
      },
      "ProcessSignalLineageInfo": {
        "nullable": true,
        "type": "object",
        "properties": {
          "parentUid": {
            "type": "integer",
            "format": "int64"
          },
          "parentExecFilePath": {
            "nullable": true,
            "type": "string"
          }
        }
      },
      "storageProcessSignal": {
        "nullable": true,
        "type": "object",
        "properties": {
          "id": {
            "nullable": true,
            "type": "string",
            "description": "A unique UUID for identifying the message\nWe have this here instead of at the top level\nbecause we want to have each message to be\nself contained."
          },
          "containerId": {
            "title": "ID of container associated with this process",
            "nullable": true,
            "type": "string"
          },
          "time": {
            "title": "Process creation time",
            "nullable": true,
            "type": "string",
            "format": "date-time"
          },
          "name": {
            "title": "Process name",
            "nullable": true,
            "type": "string"
          },
          "args": {
            "title": "Process arguments",
            "nullable": true,
            "type": "string"
          },
          "execFilePath": {
            "title": "Process executable file path",
            "nullable": true,
            "type": "string"
          },
          "pid": {
            "title": "Host process ID",
            "type": "integer",
            "format": "int64"
          },
          "uid": {
            "title": "Real user ID",
            "type": "integer",
            "format": "int64"
          },
          "gid": {
            "title": "Real group ID",
            "type": "integer",
            "format": "int64"
          },
          "lineage": {
            "title": "Process Lineage",
            "type": "array",
            "items": {
              "nullable": true,
              "type": "string"
            }
          },
          "scraped": {
            "title": "Signal origin",
            "type": "boolean"
          },
          "lineageInfo": {
            "title": "Process LineageInfo",
            "type": "array",
            "items": {
              "nullable": true,
              "type": "object",
              "properties": {
                "parentUid": {
                  "type": "integer",
                  "format": "int64"
                },
                "parentExecFilePath": {
                  "nullable": true,
                  "type": "string"
                }
              }
            }
          }
        }
      },
      "storageProcessIndicator": {
        "title": "Next available tag: 13",
        "nullable": true,
        "type": "object",
        "properties": {
          "id": {
            "title": "A unique UUID for the Indicator message",
            "nullable": true,
            "type": "string"
          },
          "deploymentId": {
            "nullable": true,
            "type": "string"
          },
          "containerName": {
            "nullable": true,
            "type": "string"
          },
          "podId": {
            "title": "Pod name",
            "nullable": true,
            "type": "string"
          },
          "podUid": {
            "nullable": true,
            "type": "string"
          },
          "signal": {
            "nullable": true,
            "type": "object",
            "properties": {
              "id": {
                "nullable": true,
                "type": "string",
                "description": "A unique UUID for identifying the message\nWe have this here instead of at the top level\nbecause we want to have each message to be\nself contained."
              },
              "containerId": {
                "title": "ID of container associated with this process",
                "nullable": true,
                "type": "string"
              },
              "time": {
                "title": "Process creation time",
                "nullable": true,
                "type": "string",
                "format": "date-time"
              },
              "name": {
                "title": "Process name",
                "nullable": true,
                "type": "string"
              },
              "args": {
                "title": "Process arguments",
                "nullable": true,
                "type": "string"
              },
              "execFilePath": {
                "title": "Process executable file path",
                "nullable": true,
                "type": "string"
              },
              "pid": {
                "title": "Host process ID",
                "type": "integer",
                "format": "int64"
              },
              "uid": {
                "title": "Real user ID",
                "type": "integer",
                "format": "int64"
              },
              "gid": {
                "title": "Real group ID",
                "type": "integer",
                "format": "int64"
              },
              "lineage": {
                "title": "Process Lineage",
                "type": "array",
                "items": {
                  "nullable": true,
                  "type": "string"
                }
              },
              "scraped": {
                "title": "Signal origin",
                "type": "boolean"
              },
              "lineageInfo": {
                "title": "Process LineageInfo",
                "type": "array",
                "items": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "parentUid": {
                      "type": "integer",
                      "format": "int64"
                    },
                    "parentExecFilePath": {
                      "nullable": true,
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "clusterId": {
            "nullable": true,
            "type": "string"
          },
          "namespace": {
            "nullable": true,
            "type": "string"
          },
          "containerStartTime": {
            "nullable": true,
            "type": "string",
            "format": "date-time"
          },
          "imageId": {
            "nullable": true,
            "type": "string"
          }
        }
      },
      "AlertProcessViolation": {
        "nullable": true,
        "type": "object",
        "properties": {
          "message": {
            "nullable": true,
            "type": "string",
            "description": "Human-readable message describing the process violation."
          },
          "processes": {
            "type": "array",
            "description": "List of processes that violated the policy.\nLimited to maximum 40 processes per runtime alert.",
            "items": {
              "title": "Next available tag: 13",
              "nullable": true,
              "type": "object",
              "properties": {
                "id": {
                  "title": "A unique UUID for the Indicator message",
                  "nullable": true,
                  "type": "string"
                },
                "deploymentId": {
                  "nullable": true,
                  "type": "string"
                },
                "containerName": {
                  "nullable": true,
                  "type": "string"
                },
                "podId": {
                  "title": "Pod name",
                  "nullable": true,
                  "type": "string"
                },
                "podUid": {
                  "nullable": true,
                  "type": "string"
                },
                "signal": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "id": {
                      "nullable": true,
                      "type": "string",
                      "description": "A unique UUID for identifying the message\nWe have this here instead of at the top level\nbecause we want to have each message to be\nself contained."
                    },
                    "containerId": {
                      "title": "ID of container associated with this process",
                      "nullable": true,
                      "type": "string"
                    },
                    "time": {
                      "title": "Process creation time",
                      "nullable": true,
                      "type": "string",
                      "format": "date-time"
                    },
                    "name": {
                      "title": "Process name",
                      "nullable": true,
                      "type": "string"
                    },
                    "args": {
                      "title": "Process arguments",
                      "nullable": true,
                      "type": "string"
                    },
                    "execFilePath": {
                      "title": "Process executable file path",
                      "nullable": true,
                      "type": "string"
                    },
                    "pid": {
                      "title": "Host process ID",
                      "type": "integer",
                      "format": "int64"
                    },
                    "uid": {
                      "title": "Real user ID",
                      "type": "integer",
                      "format": "int64"
                    },
                    "gid": {
                      "title": "Real group ID",
                      "type": "integer",
                      "format": "int64"
                    },
                    "lineage": {
                      "title": "Process Lineage",
                      "type": "array",
                      "items": {
                        "nullable": true,
                        "type": "string"
                      }
                    },
                    "scraped": {
                      "title": "Signal origin",
                      "type": "boolean"
                    },
                    "lineageInfo": {
                      "title": "Process LineageInfo",
                      "type": "array",
                      "items": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "parentUid": {
                            "type": "integer",
                            "format": "int64"
                          },
                          "parentExecFilePath": {
                            "nullable": true,
                            "type": "string"
                          }
                        }
                      }
                    }
                  }
                },
                "clusterId": {
                  "nullable": true,
                  "type": "string"
                },
                "namespace": {
                  "nullable": true,
                  "type": "string"
                },
                "containerStartTime": {
                  "nullable": true,
                  "type": "string",
                  "format": "date-time"
                },
                "imageId": {
                  "nullable": true,
                  "type": "string"
                }
              }
            }
          }
        }
      },
      "AlertEnforcement": {
        "nullable": true,
        "type": "object",
        "properties": {
          "action": {
            "nullable": true,
            "type": "string",
            "description": " - FAIL_KUBE_REQUEST_ENFORCEMENT: FAIL_KUBE_REQUEST_ENFORCEMENT takes effect only if admission control webhook is enabled to listen on exec and port-forward events.\n - FAIL_DEPLOYMENT_CREATE_ENFORCEMENT: FAIL_DEPLOYMENT_CREATE_ENFORCEMENT takes effect only if admission control webhook is configured to enforce on object creates.\n - FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT: FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT takes effect only if admission control webhook is configured to enforce on object updates.",
            "default": "UNSET_ENFORCEMENT",
            "enum": [
              "UNSET_ENFORCEMENT",
              "SCALE_TO_ZERO_ENFORCEMENT",
              "UNSATISFIABLE_NODE_CONSTRAINT_ENFORCEMENT",
              "KILL_POD_ENFORCEMENT",
              "FAIL_BUILD_ENFORCEMENT",
              "FAIL_KUBE_REQUEST_ENFORCEMENT",
              "FAIL_DEPLOYMENT_CREATE_ENFORCEMENT",
              "FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT"
            ]
          },
          "message": {
            "nullable": true,
            "type": "string",
            "description": "Human-readable message describing the enforcement result."
          }
        }
      },
      "AlertEntityType": {
        "title": "- DEPLOYMENT: Alert on a deployment\n - CONTAINER_IMAGE: Alert on a container image\n - RESOURCE: Alert on a Kubernetes resource",
        "nullable": true,
        "type": "string",
        "default": "UNSET",
        "enum": [
          "UNSET",
          "DEPLOYMENT",
          "CONTAINER_IMAGE",
          "RESOURCE"
        ]
      },
      "storageAlert": {
        "title": "Next available tag: 24",
        "nullable": true,
        "type": "object",
        "properties": {
          "id": {
            "nullable": true,
            "type": "string",
            "description": "Unique identifier for the alert."
          },
          "policy": {
            "title": "Next tag: 28",
            "nullable": true,
            "type": "object",
            "properties": {
              "id": {
                "title": "Unique identifier generated by the system. Must be empty for new policies.\nFormat: UUID v4, auto-generated during creation",
                "nullable": true,
                "type": "string"
              },
              "name": {
                "title": "Name of the policy. Must be unique across all policies.\nValidation: 5-128 characters, no newlines or dollar signs\nPattern: ^[^\\n\\r\\$]{5,128}$",
                "nullable": true,
                "type": "string"
              },
              "description": {
                "title": "Free-form text description of this policy.\nValidation: Max 800 characters, no dollar signs\nPattern: ^[^\\$]{0,800}$",
                "nullable": true,
                "type": "string"
              },
              "rationale": {
                "nullable": true,
                "type": "string",
                "description": "Business justification for why this policy exists.\nUsed for compliance and audit purposes."
              },
              "remediation": {
                "nullable": true,
                "type": "string",
                "description": "Describes how to remediate a violation of this policy.\nShould be actionable and specific to the policy type."
              },
              "disabled": {
                "title": "Toggles whether or not this policy will be executing and actively firing alerts.\nDefault: false",
                "type": "boolean"
              },
              "categories": {
                "title": "List of categories that this policy falls under. Category names must already exist in Central.\nValidation: At least one category required, no duplicates",
                "type": "array",
                "items": {
                  "nullable": true,
                  "type": "string"
                }
              },
              "lifecycleStages": {
                "title": "Describes which policy lifecycle stages this policy applies to. Choices are DEPLOY, BUILD, and RUNTIME.\nValidation: At least one stage required\n- BUILD: Must contain image-related criteria only\n- DEPLOY: Cannot contain runtime criteria\n- RUNTIME: Must contain at least one runtime criterion",
                "type": "array",
                "items": {
                  "nullable": true,
                  "type": "string",
                  "default": "DEPLOY",
                  "enum": [
                    "DEPLOY",
                    "BUILD",
                    "RUNTIME"
                  ]
                }
              },
              "eventSource": {
                "nullable": true,
                "type": "string",
                "default": "NOT_APPLICABLE",
                "enum": [
                  "NOT_APPLICABLE",
                  "DEPLOYMENT_EVENT",
                  "AUDIT_LOG_EVENT"
                ]
              },
              "exclusions": {
                "title": "Define deployments or images that should be excluded from this policy.\nValidation:\n- Deployment exclusions: Only valid for DEPLOY and RUNTIME lifecycles\n- Image exclusions: Only valid for BUILD lifecycle\n- Must have at least one criteria (name, scope, or image)",
                "type": "array",
                "items": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "name": {
                      "nullable": true,
                      "type": "string",
                      "description": "Name of the exclusion. Used for identification and documentation."
                    },
                    "deployment": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "name": {
                          "title": "Name of the deployment to exclude. Optional if scope is provided.\nValidation: Must be provided if scope is not specified",
                          "nullable": true,
                          "type": "string"
                        },
                        "scope": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "cluster": {
                              "nullable": true,
                              "type": "string"
                            },
                            "namespace": {
                              "nullable": true,
                              "type": "string"
                            },
                            "label": {
                              "nullable": true,
                              "type": "object",
                              "properties": {
                                "key": {
                                  "nullable": true,
                                  "type": "string"
                                },
                                "value": {
                                  "nullable": true,
                                  "type": "string"
                                }
                              }
                            }
                          }
                        }
                      }
                    },
                    "image": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "name": {
                          "title": "Name of the image to exclude.\nValidation: Must be non-empty",
                          "nullable": true,
                          "type": "string"
                        }
                      }
                    },
                    "expiration": {
                      "nullable": true,
                      "type": "string",
                      "description": "Expiration timestamp for this exclusion.\nWhen expired, the exclusion is automatically removed.",
                      "format": "date-time"
                    }
                  }
                }
              },
              "scope": {
                "title": "Defines clusters, namespaces, and deployments that should be included in this policy.\nNo scopes defined includes everything.\nValidation: Must have at least one field populated (cluster, namespace, or label)",
                "type": "array",
                "items": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "cluster": {
                      "nullable": true,
                      "type": "string"
                    },
                    "namespace": {
                      "nullable": true,
                      "type": "string"
                    },
                    "label": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "key": {
                          "nullable": true,
                          "type": "string"
                        },
                        "value": {
                          "nullable": true,
                          "type": "string"
                        }
                      }
                    }
                  }
                }
              },
              "severity": {
                "nullable": true,
                "type": "string",
                "default": "UNSET_SEVERITY",
                "enum": [
                  "UNSET_SEVERITY",
                  "LOW_SEVERITY",
                  "MEDIUM_SEVERITY",
                  "HIGH_SEVERITY",
                  "CRITICAL_SEVERITY"
                ]
              },
              "enforcementActions": {
                "title": "Lists the enforcement actions to take when a violation from this policy is identified.\nValidation: Must be compatible with lifecycle stages\n- FAIL_BUILD_ENFORCEMENT: BUILD lifecycle only\n- SCALE_TO_ZERO_ENFORCEMENT: DEPLOY lifecycle only\n- UNSATISFIABLE_NODE_CONSTRAINT_ENFORCEMENT: DEPLOY lifecycle only\n- KILL_POD_ENFORCEMENT: RUNTIME lifecycle only\n- FAIL_KUBE_REQUEST_ENFORCEMENT: RUNTIME lifecycle only\n- FAIL_DEPLOYMENT_CREATE_ENFORCEMENT: DEPLOY lifecycle only\n- FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT: DEPLOY lifecycle only\n- Audit log policies: No enforcement actions allowed",
                "type": "array",
                "items": {
                  "nullable": true,
                  "type": "string",
                  "description": " - FAIL_KUBE_REQUEST_ENFORCEMENT: FAIL_KUBE_REQUEST_ENFORCEMENT takes effect only if admission control webhook is enabled to listen on exec and port-forward events.\n - FAIL_DEPLOYMENT_CREATE_ENFORCEMENT: FAIL_DEPLOYMENT_CREATE_ENFORCEMENT takes effect only if admission control webhook is configured to enforce on object creates.\n - FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT: FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT takes effect only if admission control webhook is configured to enforce on object updates.",
                  "default": "UNSET_ENFORCEMENT",
                  "enum": [
                    "UNSET_ENFORCEMENT",
                    "SCALE_TO_ZERO_ENFORCEMENT",
                    "UNSATISFIABLE_NODE_CONSTRAINT_ENFORCEMENT",
                    "KILL_POD_ENFORCEMENT",
                    "FAIL_BUILD_ENFORCEMENT",
                    "FAIL_KUBE_REQUEST_ENFORCEMENT",
                    "FAIL_DEPLOYMENT_CREATE_ENFORCEMENT",
                    "FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT"
                  ]
                }
              },
              "notifiers": {
                "title": "List of IDs of the notifiers that should be triggered when a violation from this policy is identified.\nIDs should be in the form of a UUID and are found through the Central API.\nValidation: All notifier IDs must reference existing notifiers",
                "type": "array",
                "items": {
                  "nullable": true,
                  "type": "string"
                }
              },
              "lastUpdated": {
                "nullable": true,
                "type": "string",
                "description": "Timestamp when the policy was last updated. Auto-generated during creation/update.",
                "format": "date-time"
              },
              "SORTName": {
                "nullable": true,
                "type": "string",
                "description": "For internal use only."
              },
              "SORTLifecycleStage": {
                "nullable": true,
                "type": "string",
                "description": "For internal use only."
              },
              "SORTEnforcement": {
                "type": "boolean",
                "description": "For internal use only."
              },
              "policyVersion": {
                "title": "Policy version. Must be \"1.1\" (current supported version).\nValidation: Only version 1.1 is supported",
                "nullable": true,
                "type": "string"
              },
              "policySections": {
                "title": "PolicySections define the violation criteria for this policy.\nValidation Requirements:\n- Each section must have a unique sectionName\n- Each policy group must have a valid fieldName and at least one value\n- Field names must be valid for the specified lifecycle stages\n- Values must match the expected format for each field type\n- Boolean operators must be compatible with field requirements\n- Negation must be allowed for the field type\n- Runtime policies must contain at least one runtime criterion\n- Runtime criteria must be in separate sections\n- Audit log policies require both KubeResource and KubeAPIVerb criteria",
                "type": "array",
                "items": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "sectionName": {
                      "nullable": true,
                      "type": "string",
                      "description": "Name of the policy section. Must be unique within the policy.\nUsed for organizing policy criteria into logical groups."
                    },
                    "policyGroups": {
                      "title": "The set of policy groups that make up this section. Each group can be considered an individual criterion.\nValidation Requirements:\n- Each group must have a valid fieldName and at least one value\n- Field names must be valid for the specified lifecycle stages\n- Values must match the expected format for each field type\n- Boolean operators must be compatible with field requirements\n- Negation must be allowed for the field type\n- Runtime criteria must be in separate sections\n- Audit log policies require both KubeResource and KubeAPIVerb criteria",
                      "type": "array",
                      "items": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "fieldName": {
                            "title": "Defines which field on a deployment or image this PolicyGroup evaluates.\nSee https://docs.openshift.com/acs/operating/manage-security-policies.html#policy-criteria_manage-security-policies for a complete list of possible values.\nValidation Requirements:\n- Must be a valid field name for the specified lifecycle stages\n- Field must support the specified boolean operator\n- Field must allow negation if negate=true\n- Field must support multiple values if more than one value is provided\n- Some fields have special restrictions (e.g., ImageSignatureVerifiedBy cannot use AND operator)",
                            "nullable": true,
                            "type": "string"
                          },
                          "booleanOperator": {
                            "nullable": true,
                            "type": "string",
                            "default": "OR",
                            "enum": [
                              "OR",
                              "AND"
                            ]
                          },
                          "negate": {
                            "title": "Determines if the evaluation of this PolicyGroup is negated. Default to false.\nValidation: Must be allowed for the field type\n- Some fields cannot be negated (negationForbidden=true)",
                            "type": "boolean"
                          },
                          "values": {
                            "title": "List of values for the specified field.\nValidation Requirements:\n- Must have at least one value\n- Values must match the expected regex pattern for the field type\n- Some fields only support single values\n- Values must be valid for the field's data type and constraints\n- Environment variable values have special format requirements\n- Dockerfile line values have special restrictions (e.g., no FROM with strict validation)",
                            "type": "array",
                            "items": {
                              "nullable": true,
                              "type": "object",
                              "properties": {
                                "value": {
                                  "title": "The actual value for the policy criterion.\nValidation: Must match the expected format for the field type\nExamples:\n- CVE: \"CVE-2021-1234\"\n- Image Tag: \"latest\"\n- Environment Variable: \"UNSET=key=value\" or \"SECRET_KEY=key=\"\n- Dockerfile Line: \"ADD=.\" or \"RUN=apt-get update\"\n- Process Name: \"nginx\"\n- Network Flow: \"tcp:80\"",
                                  "nullable": true,
                                  "type": "string"
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              },
              "mitreAttackVectors": {
                "type": "array",
                "description": "MITRE ATT&CK framework mappings for this policy.\nUsed for threat intelligence and compliance reporting.",
                "items": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "tactic": {
                      "nullable": true,
                      "type": "string"
                    },
                    "techniques": {
                      "type": "array",
                      "items": {
                        "nullable": true,
                        "type": "string"
                      }
                    }
                  }
                }
              },
              "criteriaLocked": {
                "type": "boolean",
                "description": "Read-only field. If true, the policy's criteria fields are rendered read-only."
              },
              "mitreVectorsLocked": {
                "type": "boolean",
                "description": "Read-only field. If true, the policy's MITRE ATT&CK fields are rendered read-only."
              },
              "isDefault": {
                "type": "boolean",
                "description": "Read-only field. Indicates the policy is a default policy if true and a custom policy if false."
              },
              "source": {
                "nullable": true,
                "type": "string",
                "default": "IMPERATIVE",
                "enum": [
                  "IMPERATIVE",
                  "DECLARATIVE"
                ]
              }
            }
          },
          "lifecycleStage": {
            "nullable": true,
            "type": "string",
            "default": "DEPLOY",
            "enum": [
              "DEPLOY",
              "BUILD",
              "RUNTIME"
            ]
          },
          "clusterId": {
            "nullable": true,
            "type": "string",
            "description": "Unique identifier for the cluster containing the alert."
          },
          "clusterName": {
            "nullable": true,
            "type": "string",
            "description": "Human-readable name of the cluster containing the alert."
          },
          "namespace": {
            "nullable": true,
            "type": "string",
            "description": "Kubernetes namespace containing the alert."
          },
          "namespaceId": {
            "nullable": true,
            "type": "string",
            "description": "Unique identifier for the namespace containing the alert."
          },
          "deployment": {
            "nullable": true,
            "type": "object",
            "properties": {
              "id": {
                "nullable": true,
                "type": "string",
                "description": "Unique identifier for the deployment."
              },
              "name": {
                "nullable": true,
                "type": "string",
                "description": "Human-readable name of the deployment."
              },
              "type": {
                "nullable": true,
                "type": "string",
                "description": "Type of deployment (e.g., \"Deployment\", \"DaemonSet\", \"StatefulSet\")."
              },
              "namespace": {
                "nullable": true,
                "type": "string",
                "description": "Kubernetes namespace containing the deployment.\nThis field has to be duplicated in Alert for scope management and search.\n\nThis field has to be duplicated in Alert for scope management and search."
              },
              "labels": {
                "nullable": true,
                "type": "object",
                "additionalProperties": {
                  "nullable": true,
                  "type": "string"
                },
                "description": "Kubernetes labels applied to the deployment."
              },
              "clusterId": {
                "nullable": true,
                "type": "string",
                "description": "Unique identifier for the cluster containing the deployment.\nThis field has to be duplicated in Alert for scope management and search.\n\nThis field has to be duplicated in Alert for scope management and search."
              },
              "clusterName": {
                "nullable": true,
                "type": "string",
                "description": "Human-readable name of the cluster containing the deployment.\nThis field has to be duplicated in Alert for scope management and search.\n\nThis field has to be duplicated in Alert for scope management and search."
              },
              "containers": {
                "type": "array",
                "description": "List of containers in the deployment.",
                "items": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "image": {
                      "title": "Next tag: 13",
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "id": {
                          "nullable": true,
                          "type": "string"
                        },
                        "name": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "registry": {
                              "nullable": true,
                              "type": "string"
                            },
                            "remote": {
                              "nullable": true,
                              "type": "string"
                            },
                            "tag": {
                              "nullable": true,
                              "type": "string"
                            },
                            "fullName": {
                              "nullable": true,
                              "type": "string"
                            }
                          }
                        },
                        "notPullable": {
                          "type": "boolean"
                        },
                        "isClusterLocal": {
                          "type": "boolean"
                        },
                        "idV2": {
                          "nullable": true,
                          "type": "string"
                        }
                      }
                    },
                    "name": {
                      "nullable": true,
                      "type": "string",
                      "description": "Name of the container within the deployment."
                    }
                  }
                }
              },
              "annotations": {
                "nullable": true,
                "type": "object",
                "additionalProperties": {
                  "nullable": true,
                  "type": "string"
                },
                "description": "Kubernetes annotations applied to the deployment."
              },
              "inactive": {
                "type": "boolean",
                "description": "Whether the deployment is currently inactive."
              }
            }
          },
          "image": {
            "title": "Next tag: 13",
            "nullable": true,
            "type": "object",
            "properties": {
              "id": {
                "nullable": true,
                "type": "string"
              },
              "name": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "registry": {
                    "nullable": true,
                    "type": "string"
                  },
                  "remote": {
                    "nullable": true,
                    "type": "string"
                  },
                  "tag": {
                    "nullable": true,
                    "type": "string"
                  },
                  "fullName": {
                    "nullable": true,
                    "type": "string"
                  }
                }
              },
              "notPullable": {
                "type": "boolean"
              },
              "isClusterLocal": {
                "type": "boolean"
              },
              "idV2": {
                "nullable": true,
                "type": "string"
              }
            }
          },
          "resource": {
            "title": "Represents an alert on a kubernetes resource other than a deployment (configmaps, secrets, etc.)",
            "nullable": true,
            "type": "object",
            "properties": {
              "resourceType": {
                "nullable": true,
                "type": "string",
                "default": "UNKNOWN",
                "enum": [
                  "UNKNOWN",
                  "SECRETS",
                  "CONFIGMAPS",
                  "CLUSTER_ROLES",
                  "CLUSTER_ROLE_BINDINGS",
                  "NETWORK_POLICIES",
                  "SECURITY_CONTEXT_CONSTRAINTS",
                  "EGRESS_FIREWALLS"
                ]
              },
              "name": {
                "nullable": true,
                "type": "string",
                "description": "Name of the resource that triggered the alert."
              },
              "clusterId": {
                "nullable": true,
                "type": "string",
                "description": "Unique identifier for the cluster containing the resource.\nThis field has to be duplicated in Alert for scope management and search.\n\nThis field has to be duplicated in Alert for scope management and search."
              },
              "clusterName": {
                "nullable": true,
                "type": "string",
                "description": "Human-readable name of the cluster containing the resource.\nThis field has to be duplicated in Alert for scope management and search.\n\nThis field has to be duplicated in Alert for scope management and search."
              },
              "namespace": {
                "nullable": true,
                "type": "string",
                "description": "Kubernetes namespace containing the resource.\nThis field has to be duplicated in Alert for scope management and search.\n\nThis field has to be duplicated in Alert for scope management and search."
              },
              "namespaceId": {
                "nullable": true,
                "type": "string",
                "description": "Unique identifier for the namespace containing the resource.\nThis field has to be duplicated in Alert for scope management and search.\n\nThis field has to be duplicated in Alert for scope management and search."
              }
            }
          },
          "violations": {
            "type": "array",
            "description": "For run-time phase alert, a maximum of 40 violations are retained.",
            "items": {
              "nullable": true,
              "type": "object",
              "properties": {
                "message": {
                  "nullable": true,
                  "type": "string",
                  "description": "Human-readable message describing the violation."
                },
                "keyValueAttrs": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "attrs": {
                      "type": "array",
                      "items": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "key": {
                            "nullable": true,
                            "type": "string"
                          },
                          "value": {
                            "nullable": true,
                            "type": "string"
                          }
                        }
                      }
                    }
                  }
                },
                "networkFlowInfo": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "protocol": {
                      "nullable": true,
                      "type": "string",
                      "default": "L4_PROTOCOL_UNKNOWN",
                      "enum": [
                        "L4_PROTOCOL_UNKNOWN",
                        "L4_PROTOCOL_TCP",
                        "L4_PROTOCOL_UDP",
                        "L4_PROTOCOL_ICMP",
                        "L4_PROTOCOL_RAW",
                        "L4_PROTOCOL_SCTP",
                        "L4_PROTOCOL_ANY"
                      ]
                    },
                    "source": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "name": {
                          "nullable": true,
                          "type": "string"
                        },
                        "entityType": {
                          "title": "- INTERNAL_ENTITIES: INTERNAL_ENTITIES is for grouping all internal entities under a single network graph node",
                          "nullable": true,
                          "type": "string",
                          "default": "UNKNOWN_TYPE",
                          "enum": [
                            "UNKNOWN_TYPE",
                            "DEPLOYMENT",
                            "INTERNET",
                            "LISTEN_ENDPOINT",
                            "EXTERNAL_SOURCE",
                            "INTERNAL_ENTITIES"
                          ]
                        },
                        "deploymentNamespace": {
                          "nullable": true,
                          "type": "string"
                        },
                        "deploymentType": {
                          "nullable": true,
                          "type": "string"
                        },
                        "port": {
                          "type": "integer",
                          "format": "int32"
                        }
                      }
                    },
                    "destination": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "name": {
                          "nullable": true,
                          "type": "string"
                        },
                        "entityType": {
                          "title": "- INTERNAL_ENTITIES: INTERNAL_ENTITIES is for grouping all internal entities under a single network graph node",
                          "nullable": true,
                          "type": "string",
                          "default": "UNKNOWN_TYPE",
                          "enum": [
                            "UNKNOWN_TYPE",
                            "DEPLOYMENT",
                            "INTERNET",
                            "LISTEN_ENDPOINT",
                            "EXTERNAL_SOURCE",
                            "INTERNAL_ENTITIES"
                          ]
                        },
                        "deploymentNamespace": {
                          "nullable": true,
                          "type": "string"
                        },
                        "deploymentType": {
                          "nullable": true,
                          "type": "string"
                        },
                        "port": {
                          "type": "integer",
                          "format": "int32"
                        }
                      }
                    }
                  }
                },
                "type": {
                  "title": "- GENERIC: Generic policy violation\n - K8S_EVENT: Kubernetes event violation\n - NETWORK_FLOW: Network flow violation\n - NETWORK_POLICY: Network policy violation",
                  "nullable": true,
                  "type": "string",
                  "default": "GENERIC",
                  "enum": [
                    "GENERIC",
                    "K8S_EVENT",
                    "NETWORK_FLOW",
                    "NETWORK_POLICY"
                  ]
                },
                "time": {
                  "nullable": true,
                  "type": "string",
                  "description": "Indicates violation time. This field differs from top-level field 'time' which represents last time the alert\noccurred in case of multiple occurrences of the policy alert. As of 55.0, this field is set only for kubernetes\nevent violations, but may not be limited to it in future.",
                  "format": "date-time"
                }
              }
            }
          },
          "processViolation": {
            "nullable": true,
            "type": "object",
            "properties": {
              "message": {
                "nullable": true,
                "type": "string",
                "description": "Human-readable message describing the process violation."
              },
              "processes": {
                "type": "array",
                "description": "List of processes that violated the policy.\nLimited to maximum 40 processes per runtime alert.",
                "items": {
                  "title": "Next available tag: 13",
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "id": {
                      "title": "A unique UUID for the Indicator message",
                      "nullable": true,
                      "type": "string"
                    },
                    "deploymentId": {
                      "nullable": true,
                      "type": "string"
                    },
                    "containerName": {
                      "nullable": true,
                      "type": "string"
                    },
                    "podId": {
                      "title": "Pod name",
                      "nullable": true,
                      "type": "string"
                    },
                    "podUid": {
                      "nullable": true,
                      "type": "string"
                    },
                    "signal": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "id": {
                          "nullable": true,
                          "type": "string",
                          "description": "A unique UUID for identifying the message\nWe have this here instead of at the top level\nbecause we want to have each message to be\nself contained."
                        },
                        "containerId": {
                          "title": "ID of container associated with this process",
                          "nullable": true,
                          "type": "string"
                        },
                        "time": {
                          "title": "Process creation time",
                          "nullable": true,
                          "type": "string",
                          "format": "date-time"
                        },
                        "name": {
                          "title": "Process name",
                          "nullable": true,
                          "type": "string"
                        },
                        "args": {
                          "title": "Process arguments",
                          "nullable": true,
                          "type": "string"
                        },
                        "execFilePath": {
                          "title": "Process executable file path",
                          "nullable": true,
                          "type": "string"
                        },
                        "pid": {
                          "title": "Host process ID",
                          "type": "integer",
                          "format": "int64"
                        },
                        "uid": {
                          "title": "Real user ID",
                          "type": "integer",
                          "format": "int64"
                        },
                        "gid": {
                          "title": "Real group ID",
                          "type": "integer",
                          "format": "int64"
                        },
                        "lineage": {
                          "title": "Process Lineage",
                          "type": "array",
                          "items": {
                            "nullable": true,
                            "type": "string"
                          }
                        },
                        "scraped": {
                          "title": "Signal origin",
                          "type": "boolean"
                        },
                        "lineageInfo": {
                          "title": "Process LineageInfo",
                          "type": "array",
                          "items": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "parentUid": {
                                "type": "integer",
                                "format": "int64"
                              },
                              "parentExecFilePath": {
                                "nullable": true,
                                "type": "string"
                              }
                            }
                          }
                        }
                      }
                    },
                    "clusterId": {
                      "nullable": true,
                      "type": "string"
                    },
                    "namespace": {
                      "nullable": true,
                      "type": "string"
                    },
                    "containerStartTime": {
                      "nullable": true,
                      "type": "string",
                      "format": "date-time"
                    },
                    "imageId": {
                      "nullable": true,
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "enforcement": {
            "nullable": true,
            "type": "object",
            "properties": {
              "action": {
                "nullable": true,
                "type": "string",
                "description": " - FAIL_KUBE_REQUEST_ENFORCEMENT: FAIL_KUBE_REQUEST_ENFORCEMENT takes effect only if admission control webhook is enabled to listen on exec and port-forward events.\n - FAIL_DEPLOYMENT_CREATE_ENFORCEMENT: FAIL_DEPLOYMENT_CREATE_ENFORCEMENT takes effect only if admission control webhook is configured to enforce on object creates.\n - FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT: FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT takes effect only if admission control webhook is configured to enforce on object updates.",
                "default": "UNSET_ENFORCEMENT",
                "enum": [
                  "UNSET_ENFORCEMENT",
                  "SCALE_TO_ZERO_ENFORCEMENT",
                  "UNSATISFIABLE_NODE_CONSTRAINT_ENFORCEMENT",
                  "KILL_POD_ENFORCEMENT",
                  "FAIL_BUILD_ENFORCEMENT",
                  "FAIL_KUBE_REQUEST_ENFORCEMENT",
                  "FAIL_DEPLOYMENT_CREATE_ENFORCEMENT",
                  "FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT"
                ]
              },
              "message": {
                "nullable": true,
                "type": "string",
                "description": "Human-readable message describing the enforcement result."
              }
            }
          },
          "time": {
            "nullable": true,
            "type": "string",
            "description": "Timestamp of the last occurrence of this alert.\nFor alerts with multiple violations, this represents the most recent occurrence.",
            "format": "date-time"
          },
          "firstOccurred": {
            "nullable": true,
            "type": "string",
            "description": "Timestamp of the first occurrence of this alert.",
            "format": "date-time"
          },
          "resolvedAt": {
            "nullable": true,
            "type": "string",
            "description": "The time at which the alert was resolved. Only set if ViolationState is RESOLVED.",
            "format": "date-time"
          },
          "state": {
            "nullable": true,
            "type": "string",
            "description": " - ACTIVE: Alert is currently active and requires attention.\nThis is the default state for new alerts.\nActive alerts can be resolved but cannot be deleted.\n - RESOLVED: Alert has been resolved (manually or automatically).\nResolved alerts can be deleted for maintenance purposes.\nOnly RESOLVED alerts can be deleted via DeleteAlerts API.\n - ATTEMPTED: Enforcement action was attempted but failed.\nThese alerts can be resolved to acknowledge the failed enforcement.\nCommon for alerts where enforcement actions are not fully configured.",
            "default": "ACTIVE",
            "enum": [
              "ACTIVE",
              "RESOLVED",
              "ATTEMPTED"
            ]
          },
          "platformComponent": {
            "type": "boolean",
            "description": "Whether this alert is related to a platform component."
          },
          "entityType": {
            "title": "- DEPLOYMENT: Alert on a deployment\n - CONTAINER_IMAGE: Alert on a container image\n - RESOURCE: Alert on a Kubernetes resource",
            "nullable": true,
            "type": "string",
            "default": "UNSET",
            "enum": [
              "UNSET",
              "DEPLOYMENT",
              "CONTAINER_IMAGE",
              "RESOURCE"
            ]
          }
        }
      },
      "storageClusterType": {
        "nullable": true,
        "type": "string",
        "default": "GENERIC_CLUSTER",
        "enum": [
          "GENERIC_CLUSTER",
          "KUBERNETES_CLUSTER",
          "OPENSHIFT_CLUSTER",
          "OPENSHIFT4_CLUSTER"
        ]
      },
      "storageCollectionMethod": {
        "nullable": true,
        "type": "string",
        "default": "UNSET_COLLECTION",
        "enum": [
          "UNSET_COLLECTION",
          "NO_COLLECTION",
          "KERNEL_MODULE",
          "EBPF",
          "CORE_BPF"
        ]
      },
      "storageGoogleProviderMetadata": {
        "nullable": true,
        "type": "object",
        "properties": {
          "project": {
            "nullable": true,
            "type": "string"
          },
          "clusterName": {
            "nullable": true,
            "type": "string",
            "description": "Deprecated in favor of providerMetadata.cluster.name."
          }
        }
      },
      "storageAWSProviderMetadata": {
        "nullable": true,
        "type": "object",
        "properties": {
          "accountId": {
            "nullable": true,
            "type": "string"
          }
        }
      },
      "storageAzureProviderMetadata": {
        "nullable": true,
        "type": "object",
        "properties": {
          "subscriptionId": {
            "nullable": true,
            "type": "string"
          }
        }
      },
      "storageClusterMetadataType": {
        "nullable": true,
        "type": "string",
        "default": "UNSPECIFIED",
        "enum": [
          "UNSPECIFIED",
          "AKS",
          "ARO",
          "EKS",
          "GKE",
          "OCP",
          "OSD",
          "ROSA"
        ]
      },
      "storageClusterMetadata": {
        "nullable": true,
        "type": "object",
        "properties": {
          "type": {
            "nullable": true,
            "type": "string",
            "default": "UNSPECIFIED",
            "enum": [
              "UNSPECIFIED",
              "AKS",
              "ARO",
              "EKS",
              "GKE",
              "OCP",
              "OSD",
              "ROSA"
            ]
          },
          "name": {
            "nullable": true,
            "type": "string",
            "description": "Name represents the name under which the cluster is registered with the\ncloud provider. In case of self managed OpenShift it is the name chosen\nby the OpenShift installer."
          },
          "id": {
            "nullable": true,
            "type": "string",
            "description": "Id represents a unique ID under which the cluster is registered with the\ncloud provider. Not all cluster types have an id. For all OpenShift\nclusters, this is the Red Hat `cluster_id` registered with OCM."
          }
        },
        "description": "ClusterMetadata contains metadata information about the cluster infrastructure."
      },
      "storageProviderMetadata": {
        "nullable": true,
        "type": "object",
        "properties": {
          "region": {
            "nullable": true,
            "type": "string"
          },
          "zone": {
            "nullable": true,
            "type": "string"
          },
          "google": {
            "nullable": true,
            "type": "object",
            "properties": {
              "project": {
                "nullable": true,
                "type": "string"
              },
              "clusterName": {
                "nullable": true,
                "type": "string",
                "description": "Deprecated in favor of providerMetadata.cluster.name."
              }
            }
          },
          "aws": {
            "nullable": true,
            "type": "object",
            "properties": {
              "accountId": {
                "nullable": true,
                "type": "string"
              }
            }
          },
          "azure": {
            "nullable": true,
            "type": "object",
            "properties": {
              "subscriptionId": {
                "nullable": true,
                "type": "string"
              }
            }
          },
          "verified": {
            "type": "boolean"
          },
          "cluster": {
            "nullable": true,
            "type": "object",
            "properties": {
              "type": {
                "nullable": true,
                "type": "string",
                "default": "UNSPECIFIED",
                "enum": [
                  "UNSPECIFIED",
                  "AKS",
                  "ARO",
                  "EKS",
                  "GKE",
                  "OCP",
                  "OSD",
                  "ROSA"
                ]
              },
              "name": {
                "nullable": true,
                "type": "string",
                "description": "Name represents the name under which the cluster is registered with the\ncloud provider. In case of self managed OpenShift it is the name chosen\nby the OpenShift installer."
              },
              "id": {
                "nullable": true,
                "type": "string",
                "description": "Id represents a unique ID under which the cluster is registered with the\ncloud provider. Not all cluster types have an id. For all OpenShift\nclusters, this is the Red Hat `cluster_id` registered with OCM."
              }
            },
            "description": "ClusterMetadata contains metadata information about the cluster infrastructure."
          }
        }
      },
      "storageOrchestratorMetadata": {
        "nullable": true,
        "type": "object",
        "properties": {
          "version": {
            "nullable": true,
            "type": "string"
          },
          "openshiftVersion": {
            "nullable": true,
            "type": "string"
          },
          "buildDate": {
            "nullable": true,
            "type": "string",
            "format": "date-time"
          },
          "apiVersions": {
            "type": "array",
            "items": {
              "nullable": true,
              "type": "string"
            }
          }
        }
      },
      "ClusterUpgradeStatusUpgradability": {
        "nullable": true,
        "type": "string",
        "description": " - SENSOR_VERSION_HIGHER: SENSOR_VERSION_HIGHER occurs when we detect that the sensor\nis running a newer version than this Central. This is unexpected,\nbut can occur depending on the patches a customer does.\nIn this case, we will NOT automatically \"upgrade\" the sensor,\nsince that would be a downgrade, even if the autoupgrade setting is\non. The user will be allowed to manually trigger the upgrade, but they are\nstrongly discouraged from doing so without upgrading Central first, since this\nis an unsupported configuration.",
        "default": "UNSET",
        "enum": [
          "UNSET",
          "UP_TO_DATE",
          "MANUAL_UPGRADE_REQUIRED",
          "AUTO_UPGRADE_POSSIBLE",
          "SENSOR_VERSION_HIGHER"
        ]
      },
      "UpgradeProgressUpgradeState": {
        "nullable": true,
        "type": "string",
        "description": " - UPGRADER_LAUNCHING: In-progress states.\n - UPGRADE_COMPLETE: The success state.\nPLEASE NUMBER ALL IN-PROGRESS STATES ABOVE THIS\nAND ALL ERROR STATES BELOW THIS.\n - UPGRADE_INITIALIZATION_ERROR: Error states.",
        "default": "UPGRADE_INITIALIZING",
        "enum": [
          "UPGRADE_INITIALIZING",
          "UPGRADER_LAUNCHING",
          "UPGRADER_LAUNCHED",
          "PRE_FLIGHT_CHECKS_COMPLETE",
          "UPGRADE_OPERATIONS_DONE",
          "UPGRADE_COMPLETE",
          "UPGRADE_INITIALIZATION_ERROR",
          "PRE_FLIGHT_CHECKS_FAILED",
          "UPGRADE_ERROR_ROLLING_BACK",
          "UPGRADE_ERROR_ROLLED_BACK",
          "UPGRADE_ERROR_ROLLBACK_FAILED",
          "UPGRADE_ERROR_UNKNOWN",
          "UPGRADE_TIMED_OUT"
        ]
      },
      "storageUpgradeProgress": {
        "nullable": true,
        "type": "object",
        "properties": {
          "upgradeState": {
            "nullable": true,
            "type": "string",
            "description": " - UPGRADER_LAUNCHING: In-progress states.\n - UPGRADE_COMPLETE: The success state.\nPLEASE NUMBER ALL IN-PROGRESS STATES ABOVE THIS\nAND ALL ERROR STATES BELOW THIS.\n - UPGRADE_INITIALIZATION_ERROR: Error states.",
            "default": "UPGRADE_INITIALIZING",
            "enum": [
              "UPGRADE_INITIALIZING",
              "UPGRADER_LAUNCHING",
              "UPGRADER_LAUNCHED",
              "PRE_FLIGHT_CHECKS_COMPLETE",
              "UPGRADE_OPERATIONS_DONE",
              "UPGRADE_COMPLETE",
              "UPGRADE_INITIALIZATION_ERROR",
              "PRE_FLIGHT_CHECKS_FAILED",
              "UPGRADE_ERROR_ROLLING_BACK",
              "UPGRADE_ERROR_ROLLED_BACK",
              "UPGRADE_ERROR_ROLLBACK_FAILED",
              "UPGRADE_ERROR_UNKNOWN",
              "UPGRADE_TIMED_OUT"
            ]
          },
          "upgradeStatusDetail": {
            "nullable": true,
            "type": "string"
          },
          "since": {
            "nullable": true,
            "type": "string",
            "format": "date-time"
          }
        }
      },
      "UpgradeProcessStatusUpgradeProcessType": {
        "nullable": true,
        "type": "string",
        "description": " - UPGRADE: UPGRADE represents a sensor version upgrade.\n - CERT_ROTATION: CERT_ROTATION represents an upgrade process that only rotates the TLS certs\nused by the cluster, without changing anything else.",
        "default": "UPGRADE",
        "enum": [
          "UPGRADE",
          "CERT_ROTATION"
        ]
      },
      "ClusterUpgradeStatusUpgradeProcessStatus": {
        "nullable": true,
        "type": "object",
        "properties": {
          "active": {
            "type": "boolean"
          },
          "id": {
            "nullable": true,
            "type": "string"
          },
          "targetVersion": {
            "title": "only relevant if type == Upgrade",
            "nullable": true,
            "type": "string"
          },
          "upgraderImage": {
            "nullable": true,
            "type": "string"
          },
          "initiatedAt": {
            "nullable": true,
            "type": "string",
            "format": "date-time"
          },
          "progress": {
            "nullable": true,
            "type": "object",
            "properties": {
              "upgradeState": {
                "nullable": true,
                "type": "string",
                "description": " - UPGRADER_LAUNCHING: In-progress states.\n - UPGRADE_COMPLETE: The success state.\nPLEASE NUMBER ALL IN-PROGRESS STATES ABOVE THIS\nAND ALL ERROR STATES BELOW THIS.\n - UPGRADE_INITIALIZATION_ERROR: Error states.",
                "default": "UPGRADE_INITIALIZING",
                "enum": [
                  "UPGRADE_INITIALIZING",
                  "UPGRADER_LAUNCHING",
                  "UPGRADER_LAUNCHED",
                  "PRE_FLIGHT_CHECKS_COMPLETE",
                  "UPGRADE_OPERATIONS_DONE",
                  "UPGRADE_COMPLETE",
                  "UPGRADE_INITIALIZATION_ERROR",
                  "PRE_FLIGHT_CHECKS_FAILED",
                  "UPGRADE_ERROR_ROLLING_BACK",
                  "UPGRADE_ERROR_ROLLED_BACK",
                  "UPGRADE_ERROR_ROLLBACK_FAILED",
                  "UPGRADE_ERROR_UNKNOWN",
                  "UPGRADE_TIMED_OUT"
                ]
              },
              "upgradeStatusDetail": {
                "nullable": true,
                "type": "string"
              },
              "since": {
                "nullable": true,
                "type": "string",
                "format": "date-time"
              }
            }
          },
          "type": {
            "nullable": true,
            "type": "string",
            "description": " - UPGRADE: UPGRADE represents a sensor version upgrade.\n - CERT_ROTATION: CERT_ROTATION represents an upgrade process that only rotates the TLS certs\nused by the cluster, without changing anything else.",
            "default": "UPGRADE",
            "enum": [
              "UPGRADE",
              "CERT_ROTATION"
            ]
          }
        }
      },
      "storageClusterUpgradeStatus": {
        "nullable": true,
        "type": "object",
        "properties": {
          "upgradability": {
            "nullable": true,
            "type": "string",
            "description": " - SENSOR_VERSION_HIGHER: SENSOR_VERSION_HIGHER occurs when we detect that the sensor\nis running a newer version than this Central. This is unexpected,\nbut can occur depending on the patches a customer does.\nIn this case, we will NOT automatically \"upgrade\" the sensor,\nsince that would be a downgrade, even if the autoupgrade setting is\non. The user will be allowed to manually trigger the upgrade, but they are\nstrongly discouraged from doing so without upgrading Central first, since this\nis an unsupported configuration.",
            "default": "UNSET",
            "enum": [
              "UNSET",
              "UP_TO_DATE",
              "MANUAL_UPGRADE_REQUIRED",
              "AUTO_UPGRADE_POSSIBLE",
              "SENSOR_VERSION_HIGHER"
            ]
          },
          "upgradabilityStatusReason": {
            "nullable": true,
            "type": "string"
          },
          "mostRecentProcess": {
            "nullable": true,
            "type": "object",
            "properties": {
              "active": {
                "type": "boolean"
              },
              "id": {
                "nullable": true,
                "type": "string"
              },
              "targetVersion": {
                "title": "only relevant if type == Upgrade",
                "nullable": true,
                "type": "string"
              },
              "upgraderImage": {
                "nullable": true,
                "type": "string"
              },
              "initiatedAt": {
                "nullable": true,
                "type": "string",
                "format": "date-time"
              },
              "progress": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "upgradeState": {
                    "nullable": true,
                    "type": "string",
                    "description": " - UPGRADER_LAUNCHING: In-progress states.\n - UPGRADE_COMPLETE: The success state.\nPLEASE NUMBER ALL IN-PROGRESS STATES ABOVE THIS\nAND ALL ERROR STATES BELOW THIS.\n - UPGRADE_INITIALIZATION_ERROR: Error states.",
                    "default": "UPGRADE_INITIALIZING",
                    "enum": [
                      "UPGRADE_INITIALIZING",
                      "UPGRADER_LAUNCHING",
                      "UPGRADER_LAUNCHED",
                      "PRE_FLIGHT_CHECKS_COMPLETE",
                      "UPGRADE_OPERATIONS_DONE",
                      "UPGRADE_COMPLETE",
                      "UPGRADE_INITIALIZATION_ERROR",
                      "PRE_FLIGHT_CHECKS_FAILED",
                      "UPGRADE_ERROR_ROLLING_BACK",
                      "UPGRADE_ERROR_ROLLED_BACK",
                      "UPGRADE_ERROR_ROLLBACK_FAILED",
                      "UPGRADE_ERROR_UNKNOWN",
                      "UPGRADE_TIMED_OUT"
                    ]
                  },
                  "upgradeStatusDetail": {
                    "nullable": true,
                    "type": "string"
                  },
                  "since": {
                    "nullable": true,
                    "type": "string",
                    "format": "date-time"
                  }
                }
              },
              "type": {
                "nullable": true,
                "type": "string",
                "description": " - UPGRADE: UPGRADE represents a sensor version upgrade.\n - CERT_ROTATION: CERT_ROTATION represents an upgrade process that only rotates the TLS certs\nused by the cluster, without changing anything else.",
                "default": "UPGRADE",
                "enum": [
                  "UPGRADE",
                  "CERT_ROTATION"
                ]
              }
            }
          }
        }
      },
      "storageClusterCertExpiryStatus": {
        "nullable": true,
        "type": "object",
        "properties": {
          "sensorCertExpiry": {
            "nullable": true,
            "type": "string",
            "format": "date-time"
          },
          "sensorCertNotBefore": {
            "nullable": true,
            "type": "string",
            "format": "date-time"
          }
        }
      },
      "storageClusterStatus": {
        "nullable": true,
        "type": "object",
        "properties": {
          "sensorVersion": {
            "nullable": true,
            "type": "string"
          },
          "DEPRECATEDLastContact": {
            "nullable": true,
            "type": "string",
            "description": "This field has been deprecated starting release 49.0. Use healthStatus.lastContact instead.",
            "format": "date-time"
          },
          "providerMetadata": {
            "nullable": true,
            "type": "object",
            "properties": {
              "region": {
                "nullable": true,
                "type": "string"
              },
              "zone": {
                "nullable": true,
                "type": "string"
              },
              "google": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "project": {
                    "nullable": true,
                    "type": "string"
                  },
                  "clusterName": {
                    "nullable": true,
                    "type": "string",
                    "description": "Deprecated in favor of providerMetadata.cluster.name."
                  }
                }
              },
              "aws": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "accountId": {
                    "nullable": true,
                    "type": "string"
                  }
                }
              },
              "azure": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "subscriptionId": {
                    "nullable": true,
                    "type": "string"
                  }
                }
              },
              "verified": {
                "type": "boolean"
              },
              "cluster": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "type": {
                    "nullable": true,
                    "type": "string",
                    "default": "UNSPECIFIED",
                    "enum": [
                      "UNSPECIFIED",
                      "AKS",
                      "ARO",
                      "EKS",
                      "GKE",
                      "OCP",
                      "OSD",
                      "ROSA"
                    ]
                  },
                  "name": {
                    "nullable": true,
                    "type": "string",
                    "description": "Name represents the name under which the cluster is registered with the\ncloud provider. In case of self managed OpenShift it is the name chosen\nby the OpenShift installer."
                  },
                  "id": {
                    "nullable": true,
                    "type": "string",
                    "description": "Id represents a unique ID under which the cluster is registered with the\ncloud provider. Not all cluster types have an id. For all OpenShift\nclusters, this is the Red Hat `cluster_id` registered with OCM."
                  }
                },
                "description": "ClusterMetadata contains metadata information about the cluster infrastructure."
              }
            }
          },
          "orchestratorMetadata": {
            "nullable": true,
            "type": "object",
            "properties": {
              "version": {
                "nullable": true,
                "type": "string"
              },
              "openshiftVersion": {
                "nullable": true,
                "type": "string"
              },
              "buildDate": {
                "nullable": true,
                "type": "string",
                "format": "date-time"
              },
              "apiVersions": {
                "type": "array",
                "items": {
                  "nullable": true,
                  "type": "string"
                }
              }
            }
          },
          "upgradeStatus": {
            "nullable": true,
            "type": "object",
            "properties": {
              "upgradability": {
                "nullable": true,
                "type": "string",
                "description": " - SENSOR_VERSION_HIGHER: SENSOR_VERSION_HIGHER occurs when we detect that the sensor\nis running a newer version than this Central. This is unexpected,\nbut can occur depending on the patches a customer does.\nIn this case, we will NOT automatically \"upgrade\" the sensor,\nsince that would be a downgrade, even if the autoupgrade setting is\non. The user will be allowed to manually trigger the upgrade, but they are\nstrongly discouraged from doing so without upgrading Central first, since this\nis an unsupported configuration.",
                "default": "UNSET",
                "enum": [
                  "UNSET",
                  "UP_TO_DATE",
                  "MANUAL_UPGRADE_REQUIRED",
                  "AUTO_UPGRADE_POSSIBLE",
                  "SENSOR_VERSION_HIGHER"
                ]
              },
              "upgradabilityStatusReason": {
                "nullable": true,
                "type": "string"
              },
              "mostRecentProcess": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "active": {
                    "type": "boolean"
                  },
                  "id": {
                    "nullable": true,
                    "type": "string"
                  },
                  "targetVersion": {
                    "title": "only relevant if type == Upgrade",
                    "nullable": true,
                    "type": "string"
                  },
                  "upgraderImage": {
                    "nullable": true,
                    "type": "string"
                  },
                  "initiatedAt": {
                    "nullable": true,
                    "type": "string",
                    "format": "date-time"
                  },
                  "progress": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "upgradeState": {
                        "nullable": true,
                        "type": "string",
                        "description": " - UPGRADER_LAUNCHING: In-progress states.\n - UPGRADE_COMPLETE: The success state.\nPLEASE NUMBER ALL IN-PROGRESS STATES ABOVE THIS\nAND ALL ERROR STATES BELOW THIS.\n - UPGRADE_INITIALIZATION_ERROR: Error states.",
                        "default": "UPGRADE_INITIALIZING",
                        "enum": [
                          "UPGRADE_INITIALIZING",
                          "UPGRADER_LAUNCHING",
                          "UPGRADER_LAUNCHED",
                          "PRE_FLIGHT_CHECKS_COMPLETE",
                          "UPGRADE_OPERATIONS_DONE",
                          "UPGRADE_COMPLETE",
                          "UPGRADE_INITIALIZATION_ERROR",
                          "PRE_FLIGHT_CHECKS_FAILED",
                          "UPGRADE_ERROR_ROLLING_BACK",
                          "UPGRADE_ERROR_ROLLED_BACK",
                          "UPGRADE_ERROR_ROLLBACK_FAILED",
                          "UPGRADE_ERROR_UNKNOWN",
                          "UPGRADE_TIMED_OUT"
                        ]
                      },
                      "upgradeStatusDetail": {
                        "nullable": true,
                        "type": "string"
                      },
                      "since": {
                        "nullable": true,
                        "type": "string",
                        "format": "date-time"
                      }
                    }
                  },
                  "type": {
                    "nullable": true,
                    "type": "string",
                    "description": " - UPGRADE: UPGRADE represents a sensor version upgrade.\n - CERT_ROTATION: CERT_ROTATION represents an upgrade process that only rotates the TLS certs\nused by the cluster, without changing anything else.",
                    "default": "UPGRADE",
                    "enum": [
                      "UPGRADE",
                      "CERT_ROTATION"
                    ]
                  }
                }
              }
            }
          },
          "certExpiryStatus": {
            "nullable": true,
            "type": "object",
            "properties": {
              "sensorCertExpiry": {
                "nullable": true,
                "type": "string",
                "format": "date-time"
              },
              "sensorCertNotBefore": {
                "nullable": true,
                "type": "string",
                "format": "date-time"
              }
            }
          }
        }
      },
      "storageAdmissionControllerConfig": {
        "nullable": true,
        "type": "object",
        "properties": {
          "enabled": {
            "type": "boolean"
          },
          "timeoutSeconds": {
            "type": "integer",
            "format": "int32"
          },
          "scanInline": {
            "type": "boolean"
          },
          "disableBypass": {
            "type": "boolean"
          },
          "enforceOnUpdates": {
            "type": "boolean"
          }
        }
      },
      "storageDynamicClusterConfig": {
        "nullable": true,
        "type": "object",
        "properties": {
          "admissionControllerConfig": {
            "nullable": true,
            "type": "object",
            "properties": {
              "enabled": {
                "type": "boolean"
              },
              "timeoutSeconds": {
                "type": "integer",
                "format": "int32"
              },
              "scanInline": {
                "type": "boolean"
              },
              "disableBypass": {
                "type": "boolean"
              },
              "enforceOnUpdates": {
                "type": "boolean"
              }
            }
          },
          "registryOverride": {
            "nullable": true,
            "type": "string"
          },
          "disableAuditLogs": {
            "type": "boolean"
          }
        },
        "description": "The difference between Static and Dynamic cluster config is that Dynamic values are sent over the Central to Sensor gRPC connection. This has the benefit of allowing for \"hot reloading\" of values without restarting Secured cluster components."
      },
      "storageTolerationsConfig": {
        "nullable": true,
        "type": "object",
        "properties": {
          "disabled": {
            "type": "boolean"
          }
        }
      },
      "storageCollectorHealthInfo": {
        "nullable": true,
        "type": "object",
        "properties": {
          "version": {
            "title": "This is the version of the collector deamonset as returned by k8s API",
            "nullable": true,
            "type": "string"
          },
          "totalDesiredPods": {
            "type": "integer",
            "format": "int32"
          },
          "totalReadyPods": {
            "type": "integer",
            "format": "int32"
          },
          "totalRegisteredNodes": {
            "type": "integer",
            "format": "int32"
          },
          "statusErrors": {
            "type": "array",
            "description": "Collection of errors that occurred while trying to obtain collector health info.",
            "items": {
              "nullable": true,
              "type": "string"
            }
          }
        },
        "description": "CollectorHealthInfo carries data about collector deployment but does not include collector health status derived from this data.\nAggregated collector health status is not included because it is derived in central and not in the component that\nfirst reports CollectorHealthInfo (sensor)."
      },
      "storageAdmissionControlHealthInfo": {
        "nullable": true,
        "type": "object",
        "properties": {
          "totalDesiredPods": {
            "type": "integer",
            "format": "int32"
          },
          "totalReadyPods": {
            "type": "integer",
            "format": "int32"
          },
          "statusErrors": {
            "type": "array",
            "description": "Collection of errors that occurred while trying to obtain admission control health info.",
            "items": {
              "nullable": true,
              "type": "string"
            }
          }
        },
        "description": "AdmissionControlHealthInfo carries data about admission control deployment but does not include admission control health status\nderived from this data.\nAggregated admission control health status is not included because it is derived in central and not in the component that\nfirst reports AdmissionControlHealthInfo (sensor).\n\nThe following fields are made optional/nullable because there can be errors when trying to obtain them and\n the default value of 0 might be confusing with the actual value 0. In case an error happens when trying to obtain\n a certain field, it will be absent (instead of having the default value)."
      },
      "storageScannerHealthInfo": {
        "nullable": true,
        "type": "object",
        "properties": {
          "totalDesiredAnalyzerPods": {
            "type": "integer",
            "format": "int32"
          },
          "totalReadyAnalyzerPods": {
            "type": "integer",
            "format": "int32"
          },
          "totalDesiredDbPods": {
            "type": "integer",
            "format": "int32"
          },
          "totalReadyDbPods": {
            "type": "integer",
            "format": "int32"
          },
          "statusErrors": {
            "type": "array",
            "description": "Collection of errors that occurred while trying to obtain scanner health info.",
            "items": {
              "nullable": true,
              "type": "string"
            }
          }
        },
        "description": "ScannerHealthInfo represents health info of a scanner instance that is deployed on a secured cluster (so called \"local scanner\").\nWhen the scanner is deployed on a central cluster, the following message is NOT used.\nScannerHealthInfo carries data about scanner deployment but does not include scanner health status\nderived from this data.\nAggregated scanner health status is not included because it is derived in central and not in the component that\nfirst reports ScannerHealthInfo (sensor).\n\nThe following fields are made optional/nullable because there can be errors when trying to obtain them and\n the default value of 0 might be confusing with the actual value 0. In case an error happens when trying to obtain\n a certain field, it will be absent (instead of having the default value)."
      },
      "ClusterHealthStatusHealthStatusLabel": {
        "title": "- UNAVAILABLE: Only collector can have unavailable status",
        "nullable": true,
        "type": "string",
        "default": "UNINITIALIZED",
        "enum": [
          "UNINITIALIZED",
          "UNAVAILABLE",
          "UNHEALTHY",
          "DEGRADED",
          "HEALTHY"
        ]
      },
      "storageClusterHealthStatus": {
        "nullable": true,
        "type": "object",
        "properties": {
          "id": {
            "nullable": true,
            "type": "string"
          },
          "collectorHealthInfo": {
            "nullable": true,
            "type": "object",
            "properties": {
              "version": {
                "title": "This is the version of the collector deamonset as returned by k8s API",
                "nullable": true,
                "type": "string"
              },
              "totalDesiredPods": {
                "type": "integer",
                "format": "int32"
              },
              "totalReadyPods": {
                "type": "integer",
                "format": "int32"
              },
              "totalRegisteredNodes": {
                "type": "integer",
                "format": "int32"
              },
              "statusErrors": {
                "type": "array",
                "description": "Collection of errors that occurred while trying to obtain collector health info.",
                "items": {
                  "nullable": true,
                  "type": "string"
                }
              }
            },
            "description": "CollectorHealthInfo carries data about collector deployment but does not include collector health status derived from this data.\nAggregated collector health status is not included because it is derived in central and not in the component that\nfirst reports CollectorHealthInfo (sensor)."
          },
          "admissionControlHealthInfo": {
            "nullable": true,
            "type": "object",
            "properties": {
              "totalDesiredPods": {
                "type": "integer",
                "format": "int32"
              },
              "totalReadyPods": {
                "type": "integer",
                "format": "int32"
              },
              "statusErrors": {
                "type": "array",
                "description": "Collection of errors that occurred while trying to obtain admission control health info.",
                "items": {
                  "nullable": true,
                  "type": "string"
                }
              }
            },
            "description": "AdmissionControlHealthInfo carries data about admission control deployment but does not include admission control health status\nderived from this data.\nAggregated admission control health status is not included because it is derived in central and not in the component that\nfirst reports AdmissionControlHealthInfo (sensor).\n\nThe following fields are made optional/nullable because there can be errors when trying to obtain them and\n the default value of 0 might be confusing with the actual value 0. In case an error happens when trying to obtain\n a certain field, it will be absent (instead of having the default value)."
          },
          "scannerHealthInfo": {
            "nullable": true,
            "type": "object",
            "properties": {
              "totalDesiredAnalyzerPods": {
                "type": "integer",
                "format": "int32"
              },
              "totalReadyAnalyzerPods": {
                "type": "integer",
                "format": "int32"
              },
              "totalDesiredDbPods": {
                "type": "integer",
                "format": "int32"
              },
              "totalReadyDbPods": {
                "type": "integer",
                "format": "int32"
              },
              "statusErrors": {
                "type": "array",
                "description": "Collection of errors that occurred while trying to obtain scanner health info.",
                "items": {
                  "nullable": true,
                  "type": "string"
                }
              }
            },
            "description": "ScannerHealthInfo represents health info of a scanner instance that is deployed on a secured cluster (so called \"local scanner\").\nWhen the scanner is deployed on a central cluster, the following message is NOT used.\nScannerHealthInfo carries data about scanner deployment but does not include scanner health status\nderived from this data.\nAggregated scanner health status is not included because it is derived in central and not in the component that\nfirst reports ScannerHealthInfo (sensor).\n\nThe following fields are made optional/nullable because there can be errors when trying to obtain them and\n the default value of 0 might be confusing with the actual value 0. In case an error happens when trying to obtain\n a certain field, it will be absent (instead of having the default value)."
          },
          "sensorHealthStatus": {
            "title": "- UNAVAILABLE: Only collector can have unavailable status",
            "nullable": true,
            "type": "string",
            "default": "UNINITIALIZED",
            "enum": [
              "UNINITIALIZED",
              "UNAVAILABLE",
              "UNHEALTHY",
              "DEGRADED",
              "HEALTHY"
            ]
          },
          "collectorHealthStatus": {
            "title": "- UNAVAILABLE: Only collector can have unavailable status",
            "nullable": true,
            "type": "string",
            "default": "UNINITIALIZED",
            "enum": [
              "UNINITIALIZED",
              "UNAVAILABLE",
              "UNHEALTHY",
              "DEGRADED",
              "HEALTHY"
            ]
          },
          "overallHealthStatus": {
            "title": "- UNAVAILABLE: Only collector can have unavailable status",
            "nullable": true,
            "type": "string",
            "default": "UNINITIALIZED",
            "enum": [
              "UNINITIALIZED",
              "UNAVAILABLE",
              "UNHEALTHY",
              "DEGRADED",
              "HEALTHY"
            ]
          },
          "admissionControlHealthStatus": {
            "title": "- UNAVAILABLE: Only collector can have unavailable status",
            "nullable": true,
            "type": "string",
            "default": "UNINITIALIZED",
            "enum": [
              "UNINITIALIZED",
              "UNAVAILABLE",
              "UNHEALTHY",
              "DEGRADED",
              "HEALTHY"
            ]
          },
          "scannerHealthStatus": {
            "title": "- UNAVAILABLE: Only collector can have unavailable status",
            "nullable": true,
            "type": "string",
            "default": "UNINITIALIZED",
            "enum": [
              "UNINITIALIZED",
              "UNAVAILABLE",
              "UNHEALTHY",
              "DEGRADED",
              "HEALTHY"
            ]
          },
          "lastContact": {
            "nullable": true,
            "type": "string",
            "description": "For sensors not having health capability, this will be filled with gRPC connection poll. Otherwise,\nthis timestamp will be updated by central pipeline when message is processed.\n\nNote: we use this setting to guard against a specific attack vector during CRS-based cluster registration.\nAssuming that a CRS was used to register a cluster A and the CRS is leaked, an attacker shall not be able\nto re-run the CRS-flow which would then equip the attacker with a certificate & key issued to the cluster A.\nAs countermeasure we only allow re-running the CRS-flow only as long as the last_contact field is empty,\nindicating that the legit cluster A's sensor has not yet connected with the CRS-issued service certificates.",
            "format": "date-time"
          },
          "healthInfoComplete": {
            "title": "To track cases such as when sensor is healthy, but collector status data is unavailable because the sensor is on an old version",
            "type": "boolean"
          }
        }
      },
      "storageStaticClusterConfig": {
        "nullable": true,
        "type": "object",
        "properties": {
          "type": {
            "nullable": true,
            "type": "string",
            "default": "GENERIC_CLUSTER",
            "enum": [
              "GENERIC_CLUSTER",
              "KUBERNETES_CLUSTER",
              "OPENSHIFT_CLUSTER",
              "OPENSHIFT4_CLUSTER"
            ]
          },
          "mainImage": {
            "nullable": true,
            "type": "string"
          },
          "centralApiEndpoint": {
            "nullable": true,
            "type": "string"
          },
          "collectionMethod": {
            "nullable": true,
            "type": "string",
            "default": "UNSET_COLLECTION",
            "enum": [
              "UNSET_COLLECTION",
              "NO_COLLECTION",
              "KERNEL_MODULE",
              "EBPF",
              "CORE_BPF"
            ]
          },
          "collectorImage": {
            "nullable": true,
            "type": "string"
          },
          "admissionController": {
            "type": "boolean"
          },
          "admissionControllerUpdates": {
            "type": "boolean"
          },
          "tolerationsConfig": {
            "nullable": true,
            "type": "object",
            "properties": {
              "disabled": {
                "type": "boolean"
              }
            }
          },
          "slimCollector": {
            "type": "boolean"
          },
          "admissionControllerEvents": {
            "type": "boolean"
          }
        },
        "description": "The difference between Static and Dynamic cluster config is that Static values are not sent over the Central to Sensor gRPC connection. They are used, for example, to generate manifests that can be used to set up the Secured Cluster's k8s components. They are *not* dynamically reloaded."
      },
      "storageCompleteClusterConfig": {
        "nullable": true,
        "type": "object",
        "properties": {
          "dynamicConfig": {
            "nullable": true,
            "type": "object",
            "properties": {
              "admissionControllerConfig": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "enabled": {
                    "type": "boolean"
                  },
                  "timeoutSeconds": {
                    "type": "integer",
                    "format": "int32"
                  },
                  "scanInline": {
                    "type": "boolean"
                  },
                  "disableBypass": {
                    "type": "boolean"
                  },
                  "enforceOnUpdates": {
                    "type": "boolean"
                  }
                }
              },
              "registryOverride": {
                "nullable": true,
                "type": "string"
              },
              "disableAuditLogs": {
                "type": "boolean"
              }
            },
            "description": "The difference between Static and Dynamic cluster config is that Dynamic values are sent over the Central to Sensor gRPC connection. This has the benefit of allowing for \"hot reloading\" of values without restarting Secured cluster components."
          },
          "staticConfig": {
            "nullable": true,
            "type": "object",
            "properties": {
              "type": {
                "nullable": true,
                "type": "string",
                "default": "GENERIC_CLUSTER",
                "enum": [
                  "GENERIC_CLUSTER",
                  "KUBERNETES_CLUSTER",
                  "OPENSHIFT_CLUSTER",
                  "OPENSHIFT4_CLUSTER"
                ]
              },
              "mainImage": {
                "nullable": true,
                "type": "string"
              },
              "centralApiEndpoint": {
                "nullable": true,
                "type": "string"
              },
              "collectionMethod": {
                "nullable": true,
                "type": "string",
                "default": "UNSET_COLLECTION",
                "enum": [
                  "UNSET_COLLECTION",
                  "NO_COLLECTION",
                  "KERNEL_MODULE",
                  "EBPF",
                  "CORE_BPF"
                ]
              },
              "collectorImage": {
                "nullable": true,
                "type": "string"
              },
              "admissionController": {
                "type": "boolean"
              },
              "admissionControllerUpdates": {
                "type": "boolean"
              },
              "tolerationsConfig": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "disabled": {
                    "type": "boolean"
                  }
                }
              },
              "slimCollector": {
                "type": "boolean"
              },
              "admissionControllerEvents": {
                "type": "boolean"
              }
            },
            "description": "The difference between Static and Dynamic cluster config is that Static values are not sent over the Central to Sensor gRPC connection. They are used, for example, to generate manifests that can be used to set up the Secured Cluster's k8s components. They are *not* dynamically reloaded."
          },
          "configFingerprint": {
            "nullable": true,
            "type": "string"
          },
          "clusterLabels": {
            "nullable": true,
            "type": "object",
            "additionalProperties": {
              "nullable": true,
              "type": "string"
            }
          }
        },
        "description": "Encodes a complete cluster configuration minus ID/Name identifiers\nincluding static and dynamic settings."
      },
      "storageSensorDeploymentIdentification": {
        "nullable": true,
        "type": "object",
        "properties": {
          "systemNamespaceId": {
            "nullable": true,
            "type": "string"
          },
          "defaultNamespaceId": {
            "nullable": true,
            "type": "string"
          },
          "appNamespace": {
            "nullable": true,
            "type": "string"
          },
          "appNamespaceId": {
            "nullable": true,
            "type": "string"
          },
          "appServiceaccountId": {
            "nullable": true,
            "type": "string"
          },
          "k8sNodeName": {
            "nullable": true,
            "type": "string"
          }
        },
        "description": "StackRoxDeploymentIdentification aims at uniquely identifying a StackRox Sensor deployment. It is used to determine\nwhether a sensor connection comes from a sensor pod that has restarted or was recreated (possibly after a network\npartition), or from a deployment in a different namespace or cluster."
      },
      "storageAuditLogFileState": {
        "title": "AuditLogFileState tracks the last audit log event timestamp and ID that was collected by Compliance\nFor internal use only",
        "nullable": true,
        "type": "object",
        "properties": {
          "collectLogsSince": {
            "nullable": true,
            "type": "string",
            "format": "date-time"
          },
          "lastAuditId": {
            "title": "Previously received audit id. May be empty",
            "nullable": true,
            "type": "string"
          }
        }
      },
      "storageManagerType": {
        "nullable": true,
        "type": "string",
        "default": "MANAGER_TYPE_UNKNOWN",
        "enum": [
          "MANAGER_TYPE_UNKNOWN",
          "MANAGER_TYPE_MANUAL",
          "MANAGER_TYPE_HELM_CHART",
          "MANAGER_TYPE_KUBERNETES_OPERATOR"
        ]
      },
      "storageCluster": {
        "nullable": true,
        "type": "object",
        "properties": {
          "id": {
            "nullable": true,
            "type": "string"
          },
          "name": {
            "nullable": true,
            "type": "string"
          },
          "type": {
            "nullable": true,
            "type": "string",
            "default": "GENERIC_CLUSTER",
            "enum": [
              "GENERIC_CLUSTER",
              "KUBERNETES_CLUSTER",
              "OPENSHIFT_CLUSTER",
              "OPENSHIFT4_CLUSTER"
            ]
          },
          "labels": {
            "nullable": true,
            "type": "object",
            "additionalProperties": {
              "nullable": true,
              "type": "string"
            }
          },
          "mainImage": {
            "nullable": true,
            "type": "string"
          },
          "collectorImage": {
            "nullable": true,
            "type": "string"
          },
          "centralApiEndpoint": {
            "nullable": true,
            "type": "string"
          },
          "runtimeSupport": {
            "type": "boolean"
          },
          "collectionMethod": {
            "nullable": true,
            "type": "string",
            "default": "UNSET_COLLECTION",
            "enum": [
              "UNSET_COLLECTION",
              "NO_COLLECTION",
              "KERNEL_MODULE",
              "EBPF",
              "CORE_BPF"
            ]
          },
          "admissionController": {
            "type": "boolean"
          },
          "admissionControllerUpdates": {
            "type": "boolean"
          },
          "admissionControllerEvents": {
            "type": "boolean"
          },
          "status": {
            "nullable": true,
            "type": "object",
            "properties": {
              "sensorVersion": {
                "nullable": true,
                "type": "string"
              },
              "DEPRECATEDLastContact": {
                "nullable": true,
                "type": "string",
                "description": "This field has been deprecated starting release 49.0. Use healthStatus.lastContact instead.",
                "format": "date-time"
              },
              "providerMetadata": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "region": {
                    "nullable": true,
                    "type": "string"
                  },
                  "zone": {
                    "nullable": true,
                    "type": "string"
                  },
                  "google": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "project": {
                        "nullable": true,
                        "type": "string"
                      },
                      "clusterName": {
                        "nullable": true,
                        "type": "string",
                        "description": "Deprecated in favor of providerMetadata.cluster.name."
                      }
                    }
                  },
                  "aws": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "accountId": {
                        "nullable": true,
                        "type": "string"
                      }
                    }
                  },
                  "azure": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "subscriptionId": {
                        "nullable": true,
                        "type": "string"
                      }
                    }
                  },
                  "verified": {
                    "type": "boolean"
                  },
                  "cluster": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "type": {
                        "nullable": true,
                        "type": "string",
                        "default": "UNSPECIFIED",
                        "enum": [
                          "UNSPECIFIED",
                          "AKS",
                          "ARO",
                          "EKS",
                          "GKE",
                          "OCP",
                          "OSD",
                          "ROSA"
                        ]
                      },
                      "name": {
                        "nullable": true,
                        "type": "string",
                        "description": "Name represents the name under which the cluster is registered with the\ncloud provider. In case of self managed OpenShift it is the name chosen\nby the OpenShift installer."
                      },
                      "id": {
                        "nullable": true,
                        "type": "string",
                        "description": "Id represents a unique ID under which the cluster is registered with the\ncloud provider. Not all cluster types have an id. For all OpenShift\nclusters, this is the Red Hat `cluster_id` registered with OCM."
                      }
                    },
                    "description": "ClusterMetadata contains metadata information about the cluster infrastructure."
                  }
                }
              },
              "orchestratorMetadata": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "version": {
                    "nullable": true,
                    "type": "string"
                  },
                  "openshiftVersion": {
                    "nullable": true,
                    "type": "string"
                  },
                  "buildDate": {
                    "nullable": true,
                    "type": "string",
                    "format": "date-time"
                  },
                  "apiVersions": {
                    "type": "array",
                    "items": {
                      "nullable": true,
                      "type": "string"
                    }
                  }
                }
              },
              "upgradeStatus": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "upgradability": {
                    "nullable": true,
                    "type": "string",
                    "description": " - SENSOR_VERSION_HIGHER: SENSOR_VERSION_HIGHER occurs when we detect that the sensor\nis running a newer version than this Central. This is unexpected,\nbut can occur depending on the patches a customer does.\nIn this case, we will NOT automatically \"upgrade\" the sensor,\nsince that would be a downgrade, even if the autoupgrade setting is\non. The user will be allowed to manually trigger the upgrade, but they are\nstrongly discouraged from doing so without upgrading Central first, since this\nis an unsupported configuration.",
                    "default": "UNSET",
                    "enum": [
                      "UNSET",
                      "UP_TO_DATE",
                      "MANUAL_UPGRADE_REQUIRED",
                      "AUTO_UPGRADE_POSSIBLE",
                      "SENSOR_VERSION_HIGHER"
                    ]
                  },
                  "upgradabilityStatusReason": {
                    "nullable": true,
                    "type": "string"
                  },
                  "mostRecentProcess": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "active": {
                        "type": "boolean"
                      },
                      "id": {
                        "nullable": true,
                        "type": "string"
                      },
                      "targetVersion": {
                        "title": "only relevant if type == Upgrade",
                        "nullable": true,
                        "type": "string"
                      },
                      "upgraderImage": {
                        "nullable": true,
                        "type": "string"
                      },
                      "initiatedAt": {
                        "nullable": true,
                        "type": "string",
                        "format": "date-time"
                      },
                      "progress": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "upgradeState": {
                            "nullable": true,
                            "type": "string",
                            "description": " - UPGRADER_LAUNCHING: In-progress states.\n - UPGRADE_COMPLETE: The success state.\nPLEASE NUMBER ALL IN-PROGRESS STATES ABOVE THIS\nAND ALL ERROR STATES BELOW THIS.\n - UPGRADE_INITIALIZATION_ERROR: Error states.",
                            "default": "UPGRADE_INITIALIZING",
                            "enum": [
                              "UPGRADE_INITIALIZING",
                              "UPGRADER_LAUNCHING",
                              "UPGRADER_LAUNCHED",
                              "PRE_FLIGHT_CHECKS_COMPLETE",
                              "UPGRADE_OPERATIONS_DONE",
                              "UPGRADE_COMPLETE",
                              "UPGRADE_INITIALIZATION_ERROR",
                              "PRE_FLIGHT_CHECKS_FAILED",
                              "UPGRADE_ERROR_ROLLING_BACK",
                              "UPGRADE_ERROR_ROLLED_BACK",
                              "UPGRADE_ERROR_ROLLBACK_FAILED",
                              "UPGRADE_ERROR_UNKNOWN",
                              "UPGRADE_TIMED_OUT"
                            ]
                          },
                          "upgradeStatusDetail": {
                            "nullable": true,
                            "type": "string"
                          },
                          "since": {
                            "nullable": true,
                            "type": "string",
                            "format": "date-time"
                          }
                        }
                      },
                      "type": {
                        "nullable": true,
                        "type": "string",
                        "description": " - UPGRADE: UPGRADE represents a sensor version upgrade.\n - CERT_ROTATION: CERT_ROTATION represents an upgrade process that only rotates the TLS certs\nused by the cluster, without changing anything else.",
                        "default": "UPGRADE",
                        "enum": [
                          "UPGRADE",
                          "CERT_ROTATION"
                        ]
                      }
                    }
                  }
                }
              },
              "certExpiryStatus": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "sensorCertExpiry": {
                    "nullable": true,
                    "type": "string",
                    "format": "date-time"
                  },
                  "sensorCertNotBefore": {
                    "nullable": true,
                    "type": "string",
                    "format": "date-time"
                  }
                }
              }
            }
          },
          "dynamicConfig": {
            "nullable": true,
            "type": "object",
            "properties": {
              "admissionControllerConfig": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "enabled": {
                    "type": "boolean"
                  },
                  "timeoutSeconds": {
                    "type": "integer",
                    "format": "int32"
                  },
                  "scanInline": {
                    "type": "boolean"
                  },
                  "disableBypass": {
                    "type": "boolean"
                  },
                  "enforceOnUpdates": {
                    "type": "boolean"
                  }
                }
              },
              "registryOverride": {
                "nullable": true,
                "type": "string"
              },
              "disableAuditLogs": {
                "type": "boolean"
              }
            },
            "description": "The difference between Static and Dynamic cluster config is that Dynamic values are sent over the Central to Sensor gRPC connection. This has the benefit of allowing for \"hot reloading\" of values without restarting Secured cluster components."
          },
          "tolerationsConfig": {
            "nullable": true,
            "type": "object",
            "properties": {
              "disabled": {
                "type": "boolean"
              }
            }
          },
          "priority": {
            "nullable": true,
            "type": "string",
            "format": "int64"
          },
          "healthStatus": {
            "nullable": true,
            "type": "object",
            "properties": {
              "id": {
                "nullable": true,
                "type": "string"
              },
              "collectorHealthInfo": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "version": {
                    "title": "This is the version of the collector deamonset as returned by k8s API",
                    "nullable": true,
                    "type": "string"
                  },
                  "totalDesiredPods": {
                    "type": "integer",
                    "format": "int32"
                  },
                  "totalReadyPods": {
                    "type": "integer",
                    "format": "int32"
                  },
                  "totalRegisteredNodes": {
                    "type": "integer",
                    "format": "int32"
                  },
                  "statusErrors": {
                    "type": "array",
                    "description": "Collection of errors that occurred while trying to obtain collector health info.",
                    "items": {
                      "nullable": true,
                      "type": "string"
                    }
                  }
                },
                "description": "CollectorHealthInfo carries data about collector deployment but does not include collector health status derived from this data.\nAggregated collector health status is not included because it is derived in central and not in the component that\nfirst reports CollectorHealthInfo (sensor)."
              },
              "admissionControlHealthInfo": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "totalDesiredPods": {
                    "type": "integer",
                    "format": "int32"
                  },
                  "totalReadyPods": {
                    "type": "integer",
                    "format": "int32"
                  },
                  "statusErrors": {
                    "type": "array",
                    "description": "Collection of errors that occurred while trying to obtain admission control health info.",
                    "items": {
                      "nullable": true,
                      "type": "string"
                    }
                  }
                },
                "description": "AdmissionControlHealthInfo carries data about admission control deployment but does not include admission control health status\nderived from this data.\nAggregated admission control health status is not included because it is derived in central and not in the component that\nfirst reports AdmissionControlHealthInfo (sensor).\n\nThe following fields are made optional/nullable because there can be errors when trying to obtain them and\n the default value of 0 might be confusing with the actual value 0. In case an error happens when trying to obtain\n a certain field, it will be absent (instead of having the default value)."
              },
              "scannerHealthInfo": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "totalDesiredAnalyzerPods": {
                    "type": "integer",
                    "format": "int32"
                  },
                  "totalReadyAnalyzerPods": {
                    "type": "integer",
                    "format": "int32"
                  },
                  "totalDesiredDbPods": {
                    "type": "integer",
                    "format": "int32"
                  },
                  "totalReadyDbPods": {
                    "type": "integer",
                    "format": "int32"
                  },
                  "statusErrors": {
                    "type": "array",
                    "description": "Collection of errors that occurred while trying to obtain scanner health info.",
                    "items": {
                      "nullable": true,
                      "type": "string"
                    }
                  }
                },
                "description": "ScannerHealthInfo represents health info of a scanner instance that is deployed on a secured cluster (so called \"local scanner\").\nWhen the scanner is deployed on a central cluster, the following message is NOT used.\nScannerHealthInfo carries data about scanner deployment but does not include scanner health status\nderived from this data.\nAggregated scanner health status is not included because it is derived in central and not in the component that\nfirst reports ScannerHealthInfo (sensor).\n\nThe following fields are made optional/nullable because there can be errors when trying to obtain them and\n the default value of 0 might be confusing with the actual value 0. In case an error happens when trying to obtain\n a certain field, it will be absent (instead of having the default value)."
              },
              "sensorHealthStatus": {
                "title": "- UNAVAILABLE: Only collector can have unavailable status",
                "nullable": true,
                "type": "string",
                "default": "UNINITIALIZED",
                "enum": [
                  "UNINITIALIZED",
                  "UNAVAILABLE",
                  "UNHEALTHY",
                  "DEGRADED",
                  "HEALTHY"
                ]
              },
              "collectorHealthStatus": {
                "title": "- UNAVAILABLE: Only collector can have unavailable status",
                "nullable": true,
                "type": "string",
                "default": "UNINITIALIZED",
                "enum": [
                  "UNINITIALIZED",
                  "UNAVAILABLE",
                  "UNHEALTHY",
                  "DEGRADED",
                  "HEALTHY"
                ]
              },
              "overallHealthStatus": {
                "title": "- UNAVAILABLE: Only collector can have unavailable status",
                "nullable": true,
                "type": "string",
                "default": "UNINITIALIZED",
                "enum": [
                  "UNINITIALIZED",
                  "UNAVAILABLE",
                  "UNHEALTHY",
                  "DEGRADED",
                  "HEALTHY"
                ]
              },
              "admissionControlHealthStatus": {
                "title": "- UNAVAILABLE: Only collector can have unavailable status",
                "nullable": true,
                "type": "string",
                "default": "UNINITIALIZED",
                "enum": [
                  "UNINITIALIZED",
                  "UNAVAILABLE",
                  "UNHEALTHY",
                  "DEGRADED",
                  "HEALTHY"
                ]
              },
              "scannerHealthStatus": {
                "title": "- UNAVAILABLE: Only collector can have unavailable status",
                "nullable": true,
                "type": "string",
                "default": "UNINITIALIZED",
                "enum": [
                  "UNINITIALIZED",
                  "UNAVAILABLE",
                  "UNHEALTHY",
                  "DEGRADED",
                  "HEALTHY"
                ]
              },
              "lastContact": {
                "nullable": true,
                "type": "string",
                "description": "For sensors not having health capability, this will be filled with gRPC connection poll. Otherwise,\nthis timestamp will be updated by central pipeline when message is processed.\n\nNote: we use this setting to guard against a specific attack vector during CRS-based cluster registration.\nAssuming that a CRS was used to register a cluster A and the CRS is leaked, an attacker shall not be able\nto re-run the CRS-flow which would then equip the attacker with a certificate & key issued to the cluster A.\nAs countermeasure we only allow re-running the CRS-flow only as long as the last_contact field is empty,\nindicating that the legit cluster A's sensor has not yet connected with the CRS-issued service certificates.",
                "format": "date-time"
              },
              "healthInfoComplete": {
                "title": "To track cases such as when sensor is healthy, but collector status data is unavailable because the sensor is on an old version",
                "type": "boolean"
              }
            }
          },
          "slimCollector": {
            "type": "boolean"
          },
          "helmConfig": {
            "nullable": true,
            "type": "object",
            "properties": {
              "dynamicConfig": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "admissionControllerConfig": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "enabled": {
                        "type": "boolean"
                      },
                      "timeoutSeconds": {
                        "type": "integer",
                        "format": "int32"
                      },
                      "scanInline": {
                        "type": "boolean"
                      },
                      "disableBypass": {
                        "type": "boolean"
                      },
                      "enforceOnUpdates": {
                        "type": "boolean"
                      }
                    }
                  },
                  "registryOverride": {
                    "nullable": true,
                    "type": "string"
                  },
                  "disableAuditLogs": {
                    "type": "boolean"
                  }
                },
                "description": "The difference between Static and Dynamic cluster config is that Dynamic values are sent over the Central to Sensor gRPC connection. This has the benefit of allowing for \"hot reloading\" of values without restarting Secured cluster components."
              },
              "staticConfig": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "type": {
                    "nullable": true,
                    "type": "string",
                    "default": "GENERIC_CLUSTER",
                    "enum": [
                      "GENERIC_CLUSTER",
                      "KUBERNETES_CLUSTER",
                      "OPENSHIFT_CLUSTER",
                      "OPENSHIFT4_CLUSTER"
                    ]
                  },
                  "mainImage": {
                    "nullable": true,
                    "type": "string"
                  },
                  "centralApiEndpoint": {
                    "nullable": true,
                    "type": "string"
                  },
                  "collectionMethod": {
                    "nullable": true,
                    "type": "string",
                    "default": "UNSET_COLLECTION",
                    "enum": [
                      "UNSET_COLLECTION",
                      "NO_COLLECTION",
                      "KERNEL_MODULE",
                      "EBPF",
                      "CORE_BPF"
                    ]
                  },
                  "collectorImage": {
                    "nullable": true,
                    "type": "string"
                  },
                  "admissionController": {
                    "type": "boolean"
                  },
                  "admissionControllerUpdates": {
                    "type": "boolean"
                  },
                  "tolerationsConfig": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "disabled": {
                        "type": "boolean"
                      }
                    }
                  },
                  "slimCollector": {
                    "type": "boolean"
                  },
                  "admissionControllerEvents": {
                    "type": "boolean"
                  }
                },
                "description": "The difference between Static and Dynamic cluster config is that Static values are not sent over the Central to Sensor gRPC connection. They are used, for example, to generate manifests that can be used to set up the Secured Cluster's k8s components. They are *not* dynamically reloaded."
              },
              "configFingerprint": {
                "nullable": true,
                "type": "string"
              },
              "clusterLabels": {
                "nullable": true,
                "type": "object",
                "additionalProperties": {
                  "nullable": true,
                  "type": "string"
                }
              }
            },
            "description": "Encodes a complete cluster configuration minus ID/Name identifiers\nincluding static and dynamic settings."
          },
          "mostRecentSensorId": {
            "nullable": true,
            "type": "object",
            "properties": {
              "systemNamespaceId": {
                "nullable": true,
                "type": "string"
              },
              "defaultNamespaceId": {
                "nullable": true,
                "type": "string"
              },
              "appNamespace": {
                "nullable": true,
                "type": "string"
              },
              "appNamespaceId": {
                "nullable": true,
                "type": "string"
              },
              "appServiceaccountId": {
                "nullable": true,
                "type": "string"
              },
              "k8sNodeName": {
                "nullable": true,
                "type": "string"
              }
            },
            "description": "StackRoxDeploymentIdentification aims at uniquely identifying a StackRox Sensor deployment. It is used to determine\nwhether a sensor connection comes from a sensor pod that has restarted or was recreated (possibly after a network\npartition), or from a deployment in a different namespace or cluster."
          },
          "auditLogState": {
            "nullable": true,
            "type": "object",
            "additionalProperties": {
              "title": "AuditLogFileState tracks the last audit log event timestamp and ID that was collected by Compliance\nFor internal use only",
              "nullable": true,
              "type": "object",
              "properties": {
                "collectLogsSince": {
                  "nullable": true,
                  "type": "string",
                  "format": "date-time"
                },
                "lastAuditId": {
                  "title": "Previously received audit id. May be empty",
                  "nullable": true,
                  "type": "string"
                }
              }
            },
            "description": "For internal use only."
          },
          "initBundleId": {
            "nullable": true,
            "type": "string"
          },
          "managedBy": {
            "nullable": true,
            "type": "string",
            "default": "MANAGER_TYPE_UNKNOWN",
            "enum": [
              "MANAGER_TYPE_UNKNOWN",
              "MANAGER_TYPE_MANUAL",
              "MANAGER_TYPE_HELM_CHART",
              "MANAGER_TYPE_KUBERNETES_OPERATOR"
            ]
          },
          "sensorCapabilities": {
            "type": "array",
            "items": {
              "nullable": true,
              "type": "string"
            }
          }
        }
      },
      "v1DecommissionedClusterRetentionInfo": {
        "title": "next available tag: 3",
        "nullable": true,
        "type": "object",
        "properties": {
          "isExcluded": {
            "title": "indicates whether a cluster is protected from deletion",
            "type": "boolean"
          },
          "daysUntilDeletion": {
            "title": "days after which cluster will be deleted if sensor health remains UNHEALTHY",
            "type": "integer",
            "format": "int32"
          }
        }
      },
      "v1ClustersList": {
        "nullable": true,
        "type": "object",
        "properties": {
          "clusters": {
            "type": "array",
            "items": {
              "nullable": true,
              "type": "object",
              "properties": {
                "id": {
                  "nullable": true,
                  "type": "string"
                },
                "name": {
                  "nullable": true,
                  "type": "string"
                },
                "type": {
                  "nullable": true,
                  "type": "string",
                  "default": "GENERIC_CLUSTER",
                  "enum": [
                    "GENERIC_CLUSTER",
                    "KUBERNETES_CLUSTER",
                    "OPENSHIFT_CLUSTER",
                    "OPENSHIFT4_CLUSTER"
                  ]
                },
                "labels": {
                  "nullable": true,
                  "type": "object",
                  "additionalProperties": {
                    "nullable": true,
                    "type": "string"
                  }
                },
                "mainImage": {
                  "nullable": true,
                  "type": "string"
                },
                "collectorImage": {
                  "nullable": true,
                  "type": "string"
                },
                "centralApiEndpoint": {
                  "nullable": true,
                  "type": "string"
                },
                "runtimeSupport": {
                  "type": "boolean"
                },
                "collectionMethod": {
                  "nullable": true,
                  "type": "string",
                  "default": "UNSET_COLLECTION",
                  "enum": [
                    "UNSET_COLLECTION",
                    "NO_COLLECTION",
                    "KERNEL_MODULE",
                    "EBPF",
                    "CORE_BPF"
                  ]
                },
                "admissionController": {
                  "type": "boolean"
                },
                "admissionControllerUpdates": {
                  "type": "boolean"
                },
                "admissionControllerEvents": {
                  "type": "boolean"
                },
                "status": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "sensorVersion": {
                      "nullable": true,
                      "type": "string"
                    },
                    "DEPRECATEDLastContact": {
                      "nullable": true,
                      "type": "string",
                      "description": "This field has been deprecated starting release 49.0. Use healthStatus.lastContact instead.",
                      "format": "date-time"
                    },
                    "providerMetadata": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "region": {
                          "nullable": true,
                          "type": "string"
                        },
                        "zone": {
                          "nullable": true,
                          "type": "string"
                        },
                        "google": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "project": {
                              "nullable": true,
                              "type": "string"
                            },
                            "clusterName": {
                              "nullable": true,
                              "type": "string",
                              "description": "Deprecated in favor of providerMetadata.cluster.name."
                            }
                          }
                        },
                        "aws": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "accountId": {
                              "nullable": true,
                              "type": "string"
                            }
                          }
                        },
                        "azure": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "subscriptionId": {
                              "nullable": true,
                              "type": "string"
                            }
                          }
                        },
                        "verified": {
                          "type": "boolean"
                        },
                        "cluster": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "type": {
                              "nullable": true,
                              "type": "string",
                              "default": "UNSPECIFIED",
                              "enum": [
                                "UNSPECIFIED",
                                "AKS",
                                "ARO",
                                "EKS",
                                "GKE",
                                "OCP",
                                "OSD",
                                "ROSA"
                              ]
                            },
                            "name": {
                              "nullable": true,
                              "type": "string",
                              "description": "Name represents the name under which the cluster is registered with the\ncloud provider. In case of self managed OpenShift it is the name chosen\nby the OpenShift installer."
                            },
                            "id": {
                              "nullable": true,
                              "type": "string",
                              "description": "Id represents a unique ID under which the cluster is registered with the\ncloud provider. Not all cluster types have an id. For all OpenShift\nclusters, this is the Red Hat `cluster_id` registered with OCM."
                            }
                          },
                          "description": "ClusterMetadata contains metadata information about the cluster infrastructure."
                        }
                      }
                    },
                    "orchestratorMetadata": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "version": {
                          "nullable": true,
                          "type": "string"
                        },
                        "openshiftVersion": {
                          "nullable": true,
                          "type": "string"
                        },
                        "buildDate": {
                          "nullable": true,
                          "type": "string",
                          "format": "date-time"
                        },
                        "apiVersions": {
                          "type": "array",
                          "items": {
                            "nullable": true,
                            "type": "string"
                          }
                        }
                      }
                    },
                    "upgradeStatus": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "upgradability": {
                          "nullable": true,
                          "type": "string",
                          "description": " - SENSOR_VERSION_HIGHER: SENSOR_VERSION_HIGHER occurs when we detect that the sensor\nis running a newer version than this Central. This is unexpected,\nbut can occur depending on the patches a customer does.\nIn this case, we will NOT automatically \"upgrade\" the sensor,\nsince that would be a downgrade, even if the autoupgrade setting is\non. The user will be allowed to manually trigger the upgrade, but they are\nstrongly discouraged from doing so without upgrading Central first, since this\nis an unsupported configuration.",
                          "default": "UNSET",
                          "enum": [
                            "UNSET",
                            "UP_TO_DATE",
                            "MANUAL_UPGRADE_REQUIRED",
                            "AUTO_UPGRADE_POSSIBLE",
                            "SENSOR_VERSION_HIGHER"
                          ]
                        },
                        "upgradabilityStatusReason": {
                          "nullable": true,
                          "type": "string"
                        },
                        "mostRecentProcess": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "active": {
                              "type": "boolean"
                            },
                            "id": {
                              "nullable": true,
                              "type": "string"
                            },
                            "targetVersion": {
                              "title": "only relevant if type == Upgrade",
                              "nullable": true,
                              "type": "string"
                            },
                            "upgraderImage": {
                              "nullable": true,
                              "type": "string"
                            },
                            "initiatedAt": {
                              "nullable": true,
                              "type": "string",
                              "format": "date-time"
                            },
                            "progress": {
                              "nullable": true,
                              "type": "object",
                              "properties": {
                                "upgradeState": {
                                  "nullable": true,
                                  "type": "string",
                                  "description": " - UPGRADER_LAUNCHING: In-progress states.\n - UPGRADE_COMPLETE: The success state.\nPLEASE NUMBER ALL IN-PROGRESS STATES ABOVE THIS\nAND ALL ERROR STATES BELOW THIS.\n - UPGRADE_INITIALIZATION_ERROR: Error states.",
                                  "default": "UPGRADE_INITIALIZING",
                                  "enum": [
                                    "UPGRADE_INITIALIZING",
                                    "UPGRADER_LAUNCHING",
                                    "UPGRADER_LAUNCHED",
                                    "PRE_FLIGHT_CHECKS_COMPLETE",
                                    "UPGRADE_OPERATIONS_DONE",
                                    "UPGRADE_COMPLETE",
                                    "UPGRADE_INITIALIZATION_ERROR",
                                    "PRE_FLIGHT_CHECKS_FAILED",
                                    "UPGRADE_ERROR_ROLLING_BACK",
                                    "UPGRADE_ERROR_ROLLED_BACK",
                                    "UPGRADE_ERROR_ROLLBACK_FAILED",
                                    "UPGRADE_ERROR_UNKNOWN",
                                    "UPGRADE_TIMED_OUT"
                                  ]
                                },
                                "upgradeStatusDetail": {
                                  "nullable": true,
                                  "type": "string"
                                },
                                "since": {
                                  "nullable": true,
                                  "type": "string",
                                  "format": "date-time"
                                }
                              }
                            },
                            "type": {
                              "nullable": true,
                              "type": "string",
                              "description": " - UPGRADE: UPGRADE represents a sensor version upgrade.\n - CERT_ROTATION: CERT_ROTATION represents an upgrade process that only rotates the TLS certs\nused by the cluster, without changing anything else.",
                              "default": "UPGRADE",
                              "enum": [
                                "UPGRADE",
                                "CERT_ROTATION"
                              ]
                            }
                          }
                        }
                      }
                    },
                    "certExpiryStatus": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "sensorCertExpiry": {
                          "nullable": true,
                          "type": "string",
                          "format": "date-time"
                        },
                        "sensorCertNotBefore": {
                          "nullable": true,
                          "type": "string",
                          "format": "date-time"
                        }
                      }
                    }
                  }
                },
                "dynamicConfig": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "admissionControllerConfig": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "enabled": {
                          "type": "boolean"
                        },
                        "timeoutSeconds": {
                          "type": "integer",
                          "format": "int32"
                        },
                        "scanInline": {
                          "type": "boolean"
                        },
                        "disableBypass": {
                          "type": "boolean"
                        },
                        "enforceOnUpdates": {
                          "type": "boolean"
                        }
                      }
                    },
                    "registryOverride": {
                      "nullable": true,
                      "type": "string"
                    },
                    "disableAuditLogs": {
                      "type": "boolean"
                    }
                  },
                  "description": "The difference between Static and Dynamic cluster config is that Dynamic values are sent over the Central to Sensor gRPC connection. This has the benefit of allowing for \"hot reloading\" of values without restarting Secured cluster components."
                },
                "tolerationsConfig": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "disabled": {
                      "type": "boolean"
                    }
                  }
                },
                "priority": {
                  "nullable": true,
                  "type": "string",
                  "format": "int64"
                },
                "healthStatus": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "id": {
                      "nullable": true,
                      "type": "string"
                    },
                    "collectorHealthInfo": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "version": {
                          "title": "This is the version of the collector deamonset as returned by k8s API",
                          "nullable": true,
                          "type": "string"
                        },
                        "totalDesiredPods": {
                          "type": "integer",
                          "format": "int32"
                        },
                        "totalReadyPods": {
                          "type": "integer",
                          "format": "int32"
                        },
                        "totalRegisteredNodes": {
                          "type": "integer",
                          "format": "int32"
                        },
                        "statusErrors": {
                          "type": "array",
                          "description": "Collection of errors that occurred while trying to obtain collector health info.",
                          "items": {
                            "nullable": true,
                            "type": "string"
                          }
                        }
                      },
                      "description": "CollectorHealthInfo carries data about collector deployment but does not include collector health status derived from this data.\nAggregated collector health status is not included because it is derived in central and not in the component that\nfirst reports CollectorHealthInfo (sensor)."
                    },
                    "admissionControlHealthInfo": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "totalDesiredPods": {
                          "type": "integer",
                          "format": "int32"
                        },
                        "totalReadyPods": {
                          "type": "integer",
                          "format": "int32"
                        },
                        "statusErrors": {
                          "type": "array",
                          "description": "Collection of errors that occurred while trying to obtain admission control health info.",
                          "items": {
                            "nullable": true,
                            "type": "string"
                          }
                        }
                      },
                      "description": "AdmissionControlHealthInfo carries data about admission control deployment but does not include admission control health status\nderived from this data.\nAggregated admission control health status is not included because it is derived in central and not in the component that\nfirst reports AdmissionControlHealthInfo (sensor).\n\nThe following fields are made optional/nullable because there can be errors when trying to obtain them and\n the default value of 0 might be confusing with the actual value 0. In case an error happens when trying to obtain\n a certain field, it will be absent (instead of having the default value)."
                    },
                    "scannerHealthInfo": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "totalDesiredAnalyzerPods": {
                          "type": "integer",
                          "format": "int32"
                        },
                        "totalReadyAnalyzerPods": {
                          "type": "integer",
                          "format": "int32"
                        },
                        "totalDesiredDbPods": {
                          "type": "integer",
                          "format": "int32"
                        },
                        "totalReadyDbPods": {
                          "type": "integer",
                          "format": "int32"
                        },
                        "statusErrors": {
                          "type": "array",
                          "description": "Collection of errors that occurred while trying to obtain scanner health info.",
                          "items": {
                            "nullable": true,
                            "type": "string"
                          }
                        }
                      },
                      "description": "ScannerHealthInfo represents health info of a scanner instance that is deployed on a secured cluster (so called \"local scanner\").\nWhen the scanner is deployed on a central cluster, the following message is NOT used.\nScannerHealthInfo carries data about scanner deployment but does not include scanner health status\nderived from this data.\nAggregated scanner health status is not included because it is derived in central and not in the component that\nfirst reports ScannerHealthInfo (sensor).\n\nThe following fields are made optional/nullable because there can be errors when trying to obtain them and\n the default value of 0 might be confusing with the actual value 0. In case an error happens when trying to obtain\n a certain field, it will be absent (instead of having the default value)."
                    },
                    "sensorHealthStatus": {
                      "title": "- UNAVAILABLE: Only collector can have unavailable status",
                      "nullable": true,
                      "type": "string",
                      "default": "UNINITIALIZED",
                      "enum": [
                        "UNINITIALIZED",
                        "UNAVAILABLE",
                        "UNHEALTHY",
                        "DEGRADED",
                        "HEALTHY"
                      ]
                    },
                    "collectorHealthStatus": {
                      "title": "- UNAVAILABLE: Only collector can have unavailable status",
                      "nullable": true,
                      "type": "string",
                      "default": "UNINITIALIZED",
                      "enum": [
                        "UNINITIALIZED",
                        "UNAVAILABLE",
                        "UNHEALTHY",
                        "DEGRADED",
                        "HEALTHY"
                      ]
                    },
                    "overallHealthStatus": {
                      "title": "- UNAVAILABLE: Only collector can have unavailable status",
                      "nullable": true,
                      "type": "string",
                      "default": "UNINITIALIZED",
                      "enum": [
                        "UNINITIALIZED",
                        "UNAVAILABLE",
                        "UNHEALTHY",
                        "DEGRADED",
                        "HEALTHY"
                      ]
                    },
                    "admissionControlHealthStatus": {
                      "title": "- UNAVAILABLE: Only collector can have unavailable status",
                      "nullable": true,
                      "type": "string",
                      "default": "UNINITIALIZED",
                      "enum": [
                        "UNINITIALIZED",
                        "UNAVAILABLE",
                        "UNHEALTHY",
                        "DEGRADED",
                        "HEALTHY"
                      ]
                    },
                    "scannerHealthStatus": {
                      "title": "- UNAVAILABLE: Only collector can have unavailable status",
                      "nullable": true,
                      "type": "string",
                      "default": "UNINITIALIZED",
                      "enum": [
                        "UNINITIALIZED",
                        "UNAVAILABLE",
                        "UNHEALTHY",
                        "DEGRADED",
                        "HEALTHY"
                      ]
                    },
                    "lastContact": {
                      "nullable": true,
                      "type": "string",
                      "description": "For sensors not having health capability, this will be filled with gRPC connection poll. Otherwise,\nthis timestamp will be updated by central pipeline when message is processed.\n\nNote: we use this setting to guard against a specific attack vector during CRS-based cluster registration.\nAssuming that a CRS was used to register a cluster A and the CRS is leaked, an attacker shall not be able\nto re-run the CRS-flow which would then equip the attacker with a certificate & key issued to the cluster A.\nAs countermeasure we only allow re-running the CRS-flow only as long as the last_contact field is empty,\nindicating that the legit cluster A's sensor has not yet connected with the CRS-issued service certificates.",
                      "format": "date-time"
                    },
                    "healthInfoComplete": {
                      "title": "To track cases such as when sensor is healthy, but collector status data is unavailable because the sensor is on an old version",
                      "type": "boolean"
                    }
                  }
                },
                "slimCollector": {
                  "type": "boolean"
                },
                "helmConfig": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "dynamicConfig": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "admissionControllerConfig": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "enabled": {
                              "type": "boolean"
                            },
                            "timeoutSeconds": {
                              "type": "integer",
                              "format": "int32"
                            },
                            "scanInline": {
                              "type": "boolean"
                            },
                            "disableBypass": {
                              "type": "boolean"
                            },
                            "enforceOnUpdates": {
                              "type": "boolean"
                            }
                          }
                        },
                        "registryOverride": {
                          "nullable": true,
                          "type": "string"
                        },
                        "disableAuditLogs": {
                          "type": "boolean"
                        }
                      },
                      "description": "The difference between Static and Dynamic cluster config is that Dynamic values are sent over the Central to Sensor gRPC connection. This has the benefit of allowing for \"hot reloading\" of values without restarting Secured cluster components."
                    },
                    "staticConfig": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "type": {
                          "nullable": true,
                          "type": "string",
                          "default": "GENERIC_CLUSTER",
                          "enum": [
                            "GENERIC_CLUSTER",
                            "KUBERNETES_CLUSTER",
                            "OPENSHIFT_CLUSTER",
                            "OPENSHIFT4_CLUSTER"
                          ]
                        },
                        "mainImage": {
                          "nullable": true,
                          "type": "string"
                        },
                        "centralApiEndpoint": {
                          "nullable": true,
                          "type": "string"
                        },
                        "collectionMethod": {
                          "nullable": true,
                          "type": "string",
                          "default": "UNSET_COLLECTION",
                          "enum": [
                            "UNSET_COLLECTION",
                            "NO_COLLECTION",
                            "KERNEL_MODULE",
                            "EBPF",
                            "CORE_BPF"
                          ]
                        },
                        "collectorImage": {
                          "nullable": true,
                          "type": "string"
                        },
                        "admissionController": {
                          "type": "boolean"
                        },
                        "admissionControllerUpdates": {
                          "type": "boolean"
                        },
                        "tolerationsConfig": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "disabled": {
                              "type": "boolean"
                            }
                          }
                        },
                        "slimCollector": {
                          "type": "boolean"
                        },
                        "admissionControllerEvents": {
                          "type": "boolean"
                        }
                      },
                      "description": "The difference between Static and Dynamic cluster config is that Static values are not sent over the Central to Sensor gRPC connection. They are used, for example, to generate manifests that can be used to set up the Secured Cluster's k8s components. They are *not* dynamically reloaded."
                    },
                    "configFingerprint": {
                      "nullable": true,
                      "type": "string"
                    },
                    "clusterLabels": {
                      "nullable": true,
                      "type": "object",
                      "additionalProperties": {
                        "nullable": true,
                        "type": "string"
                      }
                    }
                  },
                  "description": "Encodes a complete cluster configuration minus ID/Name identifiers\nincluding static and dynamic settings."
                },
                "mostRecentSensorId": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "systemNamespaceId": {
                      "nullable": true,
                      "type": "string"
                    },
                    "defaultNamespaceId": {
                      "nullable": true,
                      "type": "string"
                    },
                    "appNamespace": {
                      "nullable": true,
                      "type": "string"
                    },
                    "appNamespaceId": {
                      "nullable": true,
                      "type": "string"
                    },
                    "appServiceaccountId": {
                      "nullable": true,
                      "type": "string"
                    },
                    "k8sNodeName": {
                      "nullable": true,
                      "type": "string"
                    }
                  },
                  "description": "StackRoxDeploymentIdentification aims at uniquely identifying a StackRox Sensor deployment. It is used to determine\nwhether a sensor connection comes from a sensor pod that has restarted or was recreated (possibly after a network\npartition), or from a deployment in a different namespace or cluster."
                },
                "auditLogState": {
                  "nullable": true,
                  "type": "object",
                  "additionalProperties": {
                    "title": "AuditLogFileState tracks the last audit log event timestamp and ID that was collected by Compliance\nFor internal use only",
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "collectLogsSince": {
                        "nullable": true,
                        "type": "string",
                        "format": "date-time"
                      },
                      "lastAuditId": {
                        "title": "Previously received audit id. May be empty",
                        "nullable": true,
                        "type": "string"
                      }
                    }
                  },
                  "description": "For internal use only."
                },
                "initBundleId": {
                  "nullable": true,
                  "type": "string"
                },
                "managedBy": {
                  "nullable": true,
                  "type": "string",
                  "default": "MANAGER_TYPE_UNKNOWN",
                  "enum": [
                    "MANAGER_TYPE_UNKNOWN",
                    "MANAGER_TYPE_MANUAL",
                    "MANAGER_TYPE_HELM_CHART",
                    "MANAGER_TYPE_KUBERNETES_OPERATOR"
                  ]
                },
                "sensorCapabilities": {
                  "type": "array",
                  "items": {
                    "nullable": true,
                    "type": "string"
                  }
                }
              }
            }
          },
          "clusterIdToRetentionInfo": {
            "title": "Maps 'UNHEALTHY' clusters' IDs to their retention info",
            "nullable": true,
            "type": "object",
            "additionalProperties": {
              "title": "next available tag: 3",
              "nullable": true,
              "type": "object",
              "properties": {
                "isExcluded": {
                  "title": "indicates whether a cluster is protected from deletion",
                  "type": "boolean"
                },
                "daysUntilDeletion": {
                  "title": "days after which cluster will be deleted if sensor health remains UNHEALTHY",
                  "type": "integer",
                  "format": "int32"
                }
              }
            }
          }
        }
      },
      "v1ClusterResponse": {
        "nullable": true,
        "type": "object",
        "properties": {
          "cluster": {
            "nullable": true,
            "type": "object",
            "properties": {
              "id": {
                "nullable": true,
                "type": "string"
              },
              "name": {
                "nullable": true,
                "type": "string"
              },
              "type": {
                "nullable": true,
                "type": "string",
                "default": "GENERIC_CLUSTER",
                "enum": [
                  "GENERIC_CLUSTER",
                  "KUBERNETES_CLUSTER",
                  "OPENSHIFT_CLUSTER",
                  "OPENSHIFT4_CLUSTER"
                ]
              },
              "labels": {
                "nullable": true,
                "type": "object",
                "additionalProperties": {
                  "nullable": true,
                  "type": "string"
                }
              },
              "mainImage": {
                "nullable": true,
                "type": "string"
              },
              "collectorImage": {
                "nullable": true,
                "type": "string"
              },
              "centralApiEndpoint": {
                "nullable": true,
                "type": "string"
              },
              "runtimeSupport": {
                "type": "boolean"
              },
              "collectionMethod": {
                "nullable": true,
                "type": "string",
                "default": "UNSET_COLLECTION",
                "enum": [
                  "UNSET_COLLECTION",
                  "NO_COLLECTION",
                  "KERNEL_MODULE",
                  "EBPF",
                  "CORE_BPF"
                ]
              },
              "admissionController": {
                "type": "boolean"
              },
              "admissionControllerUpdates": {
                "type": "boolean"
              },
              "admissionControllerEvents": {
                "type": "boolean"
              },
              "status": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "sensorVersion": {
                    "nullable": true,
                    "type": "string"
                  },
                  "DEPRECATEDLastContact": {
                    "nullable": true,
                    "type": "string",
                    "description": "This field has been deprecated starting release 49.0. Use healthStatus.lastContact instead.",
                    "format": "date-time"
                  },
                  "providerMetadata": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "region": {
                        "nullable": true,
                        "type": "string"
                      },
                      "zone": {
                        "nullable": true,
                        "type": "string"
                      },
                      "google": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "project": {
                            "nullable": true,
                            "type": "string"
                          },
                          "clusterName": {
                            "nullable": true,
                            "type": "string",
                            "description": "Deprecated in favor of providerMetadata.cluster.name."
                          }
                        }
                      },
                      "aws": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "accountId": {
                            "nullable": true,
                            "type": "string"
                          }
                        }
                      },
                      "azure": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "subscriptionId": {
                            "nullable": true,
                            "type": "string"
                          }
                        }
                      },
                      "verified": {
                        "type": "boolean"
                      },
                      "cluster": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "type": {
                            "nullable": true,
                            "type": "string",
                            "default": "UNSPECIFIED",
                            "enum": [
                              "UNSPECIFIED",
                              "AKS",
                              "ARO",
                              "EKS",
                              "GKE",
                              "OCP",
                              "OSD",
                              "ROSA"
                            ]
                          },
                          "name": {
                            "nullable": true,
                            "type": "string",
                            "description": "Name represents the name under which the cluster is registered with the\ncloud provider. In case of self managed OpenShift it is the name chosen\nby the OpenShift installer."
                          },
                          "id": {
                            "nullable": true,
                            "type": "string",
                            "description": "Id represents a unique ID under which the cluster is registered with the\ncloud provider. Not all cluster types have an id. For all OpenShift\nclusters, this is the Red Hat `cluster_id` registered with OCM."
                          }
                        },
                        "description": "ClusterMetadata contains metadata information about the cluster infrastructure."
                      }
                    }
                  },
                  "orchestratorMetadata": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "version": {
                        "nullable": true,
                        "type": "string"
                      },
                      "openshiftVersion": {
                        "nullable": true,
                        "type": "string"
                      },
                      "buildDate": {
                        "nullable": true,
                        "type": "string",
                        "format": "date-time"
                      },
                      "apiVersions": {
                        "type": "array",
                        "items": {
                          "nullable": true,
                          "type": "string"
                        }
                      }
                    }
                  },
                  "upgradeStatus": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "upgradability": {
                        "nullable": true,
                        "type": "string",
                        "description": " - SENSOR_VERSION_HIGHER: SENSOR_VERSION_HIGHER occurs when we detect that the sensor\nis running a newer version than this Central. This is unexpected,\nbut can occur depending on the patches a customer does.\nIn this case, we will NOT automatically \"upgrade\" the sensor,\nsince that would be a downgrade, even if the autoupgrade setting is\non. The user will be allowed to manually trigger the upgrade, but they are\nstrongly discouraged from doing so without upgrading Central first, since this\nis an unsupported configuration.",
                        "default": "UNSET",
                        "enum": [
                          "UNSET",
                          "UP_TO_DATE",
                          "MANUAL_UPGRADE_REQUIRED",
                          "AUTO_UPGRADE_POSSIBLE",
                          "SENSOR_VERSION_HIGHER"
                        ]
                      },
                      "upgradabilityStatusReason": {
                        "nullable": true,
                        "type": "string"
                      },
                      "mostRecentProcess": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "active": {
                            "type": "boolean"
                          },
                          "id": {
                            "nullable": true,
                            "type": "string"
                          },
                          "targetVersion": {
                            "title": "only relevant if type == Upgrade",
                            "nullable": true,
                            "type": "string"
                          },
                          "upgraderImage": {
                            "nullable": true,
                            "type": "string"
                          },
                          "initiatedAt": {
                            "nullable": true,
                            "type": "string",
                            "format": "date-time"
                          },
                          "progress": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "upgradeState": {
                                "nullable": true,
                                "type": "string",
                                "description": " - UPGRADER_LAUNCHING: In-progress states.\n - UPGRADE_COMPLETE: The success state.\nPLEASE NUMBER ALL IN-PROGRESS STATES ABOVE THIS\nAND ALL ERROR STATES BELOW THIS.\n - UPGRADE_INITIALIZATION_ERROR: Error states.",
                                "default": "UPGRADE_INITIALIZING",
                                "enum": [
                                  "UPGRADE_INITIALIZING",
                                  "UPGRADER_LAUNCHING",
                                  "UPGRADER_LAUNCHED",
                                  "PRE_FLIGHT_CHECKS_COMPLETE",
                                  "UPGRADE_OPERATIONS_DONE",
                                  "UPGRADE_COMPLETE",
                                  "UPGRADE_INITIALIZATION_ERROR",
                                  "PRE_FLIGHT_CHECKS_FAILED",
                                  "UPGRADE_ERROR_ROLLING_BACK",
                                  "UPGRADE_ERROR_ROLLED_BACK",
                                  "UPGRADE_ERROR_ROLLBACK_FAILED",
                                  "UPGRADE_ERROR_UNKNOWN",
                                  "UPGRADE_TIMED_OUT"
                                ]
                              },
                              "upgradeStatusDetail": {
                                "nullable": true,
                                "type": "string"
                              },
                              "since": {
                                "nullable": true,
                                "type": "string",
                                "format": "date-time"
                              }
                            }
                          },
                          "type": {
                            "nullable": true,
                            "type": "string",
                            "description": " - UPGRADE: UPGRADE represents a sensor version upgrade.\n - CERT_ROTATION: CERT_ROTATION represents an upgrade process that only rotates the TLS certs\nused by the cluster, without changing anything else.",
                            "default": "UPGRADE",
                            "enum": [
                              "UPGRADE",
                              "CERT_ROTATION"
                            ]
                          }
                        }
                      }
                    }
                  },
                  "certExpiryStatus": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "sensorCertExpiry": {
                        "nullable": true,
                        "type": "string",
                        "format": "date-time"
                      },
                      "sensorCertNotBefore": {
                        "nullable": true,
                        "type": "string",
                        "format": "date-time"
                      }
                    }
                  }
                }
              },
              "dynamicConfig": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "admissionControllerConfig": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "enabled": {
                        "type": "boolean"
                      },
                      "timeoutSeconds": {
                        "type": "integer",
                        "format": "int32"
                      },
                      "scanInline": {
                        "type": "boolean"
                      },
                      "disableBypass": {
                        "type": "boolean"
                      },
                      "enforceOnUpdates": {
                        "type": "boolean"
                      }
                    }
                  },
                  "registryOverride": {
                    "nullable": true,
                    "type": "string"
                  },
                  "disableAuditLogs": {
                    "type": "boolean"
                  }
                },
                "description": "The difference between Static and Dynamic cluster config is that Dynamic values are sent over the Central to Sensor gRPC connection. This has the benefit of allowing for \"hot reloading\" of values without restarting Secured cluster components."
              },
              "tolerationsConfig": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "disabled": {
                    "type": "boolean"
                  }
                }
              },
              "priority": {
                "nullable": true,
                "type": "string",
                "format": "int64"
              },
              "healthStatus": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "id": {
                    "nullable": true,
                    "type": "string"
                  },
                  "collectorHealthInfo": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "version": {
                        "title": "This is the version of the collector deamonset as returned by k8s API",
                        "nullable": true,
                        "type": "string"
                      },
                      "totalDesiredPods": {
                        "type": "integer",
                        "format": "int32"
                      },
                      "totalReadyPods": {
                        "type": "integer",
                        "format": "int32"
                      },
                      "totalRegisteredNodes": {
                        "type": "integer",
                        "format": "int32"
                      },
                      "statusErrors": {
                        "type": "array",
                        "description": "Collection of errors that occurred while trying to obtain collector health info.",
                        "items": {
                          "nullable": true,
                          "type": "string"
                        }
                      }
                    },
                    "description": "CollectorHealthInfo carries data about collector deployment but does not include collector health status derived from this data.\nAggregated collector health status is not included because it is derived in central and not in the component that\nfirst reports CollectorHealthInfo (sensor)."
                  },
                  "admissionControlHealthInfo": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "totalDesiredPods": {
                        "type": "integer",
                        "format": "int32"
                      },
                      "totalReadyPods": {
                        "type": "integer",
                        "format": "int32"
                      },
                      "statusErrors": {
                        "type": "array",
                        "description": "Collection of errors that occurred while trying to obtain admission control health info.",
                        "items": {
                          "nullable": true,
                          "type": "string"
                        }
                      }
                    },
                    "description": "AdmissionControlHealthInfo carries data about admission control deployment but does not include admission control health status\nderived from this data.\nAggregated admission control health status is not included because it is derived in central and not in the component that\nfirst reports AdmissionControlHealthInfo (sensor).\n\nThe following fields are made optional/nullable because there can be errors when trying to obtain them and\n the default value of 0 might be confusing with the actual value 0. In case an error happens when trying to obtain\n a certain field, it will be absent (instead of having the default value)."
                  },
                  "scannerHealthInfo": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "totalDesiredAnalyzerPods": {
                        "type": "integer",
                        "format": "int32"
                      },
                      "totalReadyAnalyzerPods": {
                        "type": "integer",
                        "format": "int32"
                      },
                      "totalDesiredDbPods": {
                        "type": "integer",
                        "format": "int32"
                      },
                      "totalReadyDbPods": {
                        "type": "integer",
                        "format": "int32"
                      },
                      "statusErrors": {
                        "type": "array",
                        "description": "Collection of errors that occurred while trying to obtain scanner health info.",
                        "items": {
                          "nullable": true,
                          "type": "string"
                        }
                      }
                    },
                    "description": "ScannerHealthInfo represents health info of a scanner instance that is deployed on a secured cluster (so called \"local scanner\").\nWhen the scanner is deployed on a central cluster, the following message is NOT used.\nScannerHealthInfo carries data about scanner deployment but does not include scanner health status\nderived from this data.\nAggregated scanner health status is not included because it is derived in central and not in the component that\nfirst reports ScannerHealthInfo (sensor).\n\nThe following fields are made optional/nullable because there can be errors when trying to obtain them and\n the default value of 0 might be confusing with the actual value 0. In case an error happens when trying to obtain\n a certain field, it will be absent (instead of having the default value)."
                  },
                  "sensorHealthStatus": {
                    "title": "- UNAVAILABLE: Only collector can have unavailable status",
                    "nullable": true,
                    "type": "string",
                    "default": "UNINITIALIZED",
                    "enum": [
                      "UNINITIALIZED",
                      "UNAVAILABLE",
                      "UNHEALTHY",
                      "DEGRADED",
                      "HEALTHY"
                    ]
                  },
                  "collectorHealthStatus": {
                    "title": "- UNAVAILABLE: Only collector can have unavailable status",
                    "nullable": true,
                    "type": "string",
                    "default": "UNINITIALIZED",
                    "enum": [
                      "UNINITIALIZED",
                      "UNAVAILABLE",
                      "UNHEALTHY",
                      "DEGRADED",
                      "HEALTHY"
                    ]
                  },
                  "overallHealthStatus": {
                    "title": "- UNAVAILABLE: Only collector can have unavailable status",
                    "nullable": true,
                    "type": "string",
                    "default": "UNINITIALIZED",
                    "enum": [
                      "UNINITIALIZED",
                      "UNAVAILABLE",
                      "UNHEALTHY",
                      "DEGRADED",
                      "HEALTHY"
                    ]
                  },
                  "admissionControlHealthStatus": {
                    "title": "- UNAVAILABLE: Only collector can have unavailable status",
                    "nullable": true,
                    "type": "string",
                    "default": "UNINITIALIZED",
                    "enum": [
                      "UNINITIALIZED",
                      "UNAVAILABLE",
                      "UNHEALTHY",
                      "DEGRADED",
                      "HEALTHY"
                    ]
                  },
                  "scannerHealthStatus": {
                    "title": "- UNAVAILABLE: Only collector can have unavailable status",
                    "nullable": true,
                    "type": "string",
                    "default": "UNINITIALIZED",
                    "enum": [
                      "UNINITIALIZED",
                      "UNAVAILABLE",
                      "UNHEALTHY",
                      "DEGRADED",
                      "HEALTHY"
                    ]
                  },
                  "lastContact": {
                    "nullable": true,
                    "type": "string",
                    "description": "For sensors not having health capability, this will be filled with gRPC connection poll. Otherwise,\nthis timestamp will be updated by central pipeline when message is processed.\n\nNote: we use this setting to guard against a specific attack vector during CRS-based cluster registration.\nAssuming that a CRS was used to register a cluster A and the CRS is leaked, an attacker shall not be able\nto re-run the CRS-flow which would then equip the attacker with a certificate & key issued to the cluster A.\nAs countermeasure we only allow re-running the CRS-flow only as long as the last_contact field is empty,\nindicating that the legit cluster A's sensor has not yet connected with the CRS-issued service certificates.",
                    "format": "date-time"
                  },
                  "healthInfoComplete": {
                    "title": "To track cases such as when sensor is healthy, but collector status data is unavailable because the sensor is on an old version",
                    "type": "boolean"
                  }
                }
              },
              "slimCollector": {
                "type": "boolean"
              },
              "helmConfig": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "dynamicConfig": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "admissionControllerConfig": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "enabled": {
                            "type": "boolean"
                          },
                          "timeoutSeconds": {
                            "type": "integer",
                            "format": "int32"
                          },
                          "scanInline": {
                            "type": "boolean"
                          },
                          "disableBypass": {
                            "type": "boolean"
                          },
                          "enforceOnUpdates": {
                            "type": "boolean"
                          }
                        }
                      },
                      "registryOverride": {
                        "nullable": true,
                        "type": "string"
                      },
                      "disableAuditLogs": {
                        "type": "boolean"
                      }
                    },
                    "description": "The difference between Static and Dynamic cluster config is that Dynamic values are sent over the Central to Sensor gRPC connection. This has the benefit of allowing for \"hot reloading\" of values without restarting Secured cluster components."
                  },
                  "staticConfig": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "type": {
                        "nullable": true,
                        "type": "string",
                        "default": "GENERIC_CLUSTER",
                        "enum": [
                          "GENERIC_CLUSTER",
                          "KUBERNETES_CLUSTER",
                          "OPENSHIFT_CLUSTER",
                          "OPENSHIFT4_CLUSTER"
                        ]
                      },
                      "mainImage": {
                        "nullable": true,
                        "type": "string"
                      },
                      "centralApiEndpoint": {
                        "nullable": true,
                        "type": "string"
                      },
                      "collectionMethod": {
                        "nullable": true,
                        "type": "string",
                        "default": "UNSET_COLLECTION",
                        "enum": [
                          "UNSET_COLLECTION",
                          "NO_COLLECTION",
                          "KERNEL_MODULE",
                          "EBPF",
                          "CORE_BPF"
                        ]
                      },
                      "collectorImage": {
                        "nullable": true,
                        "type": "string"
                      },
                      "admissionController": {
                        "type": "boolean"
                      },
                      "admissionControllerUpdates": {
                        "type": "boolean"
                      },
                      "tolerationsConfig": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "disabled": {
                            "type": "boolean"
                          }
                        }
                      },
                      "slimCollector": {
                        "type": "boolean"
                      },
                      "admissionControllerEvents": {
                        "type": "boolean"
                      }
                    },
                    "description": "The difference between Static and Dynamic cluster config is that Static values are not sent over the Central to Sensor gRPC connection. They are used, for example, to generate manifests that can be used to set up the Secured Cluster's k8s components. They are *not* dynamically reloaded."
                  },
                  "configFingerprint": {
                    "nullable": true,
                    "type": "string"
                  },
                  "clusterLabels": {
                    "nullable": true,
                    "type": "object",
                    "additionalProperties": {
                      "nullable": true,
                      "type": "string"
                    }
                  }
                },
                "description": "Encodes a complete cluster configuration minus ID/Name identifiers\nincluding static and dynamic settings."
              },
              "mostRecentSensorId": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "systemNamespaceId": {
                    "nullable": true,
                    "type": "string"
                  },
                  "defaultNamespaceId": {
                    "nullable": true,
                    "type": "string"
                  },
                  "appNamespace": {
                    "nullable": true,
                    "type": "string"
                  },
                  "appNamespaceId": {
                    "nullable": true,
                    "type": "string"
                  },
                  "appServiceaccountId": {
                    "nullable": true,
                    "type": "string"
                  },
                  "k8sNodeName": {
                    "nullable": true,
                    "type": "string"
                  }
                },
                "description": "StackRoxDeploymentIdentification aims at uniquely identifying a StackRox Sensor deployment. It is used to determine\nwhether a sensor connection comes from a sensor pod that has restarted or was recreated (possibly after a network\npartition), or from a deployment in a different namespace or cluster."
              },
              "auditLogState": {
                "nullable": true,
                "type": "object",
                "additionalProperties": {
                  "title": "AuditLogFileState tracks the last audit log event timestamp and ID that was collected by Compliance\nFor internal use only",
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "collectLogsSince": {
                      "nullable": true,
                      "type": "string",
                      "format": "date-time"
                    },
                    "lastAuditId": {
                      "title": "Previously received audit id. May be empty",
                      "nullable": true,
                      "type": "string"
                    }
                  }
                },
                "description": "For internal use only."
              },
              "initBundleId": {
                "nullable": true,
                "type": "string"
              },
              "managedBy": {
                "nullable": true,
                "type": "string",
                "default": "MANAGER_TYPE_UNKNOWN",
                "enum": [
                  "MANAGER_TYPE_UNKNOWN",
                  "MANAGER_TYPE_MANUAL",
                  "MANAGER_TYPE_HELM_CHART",
                  "MANAGER_TYPE_KUBERNETES_OPERATOR"
                ]
              },
              "sensorCapabilities": {
                "type": "array",
                "items": {
                  "nullable": true,
                  "type": "string"
                }
              }
            }
          },
          "clusterRetentionInfo": {
            "title": "next available tag: 3",
            "nullable": true,
            "type": "object",
            "properties": {
              "isExcluded": {
                "title": "indicates whether a cluster is protected from deletion",
                "type": "boolean"
              },
              "daysUntilDeletion": {
                "title": "days after which cluster will be deleted if sensor health remains UNHEALTHY",
                "type": "integer",
                "format": "int32"
              }
            }
          }
        }
      },
      "storageVulnerabilityState": {
        "nullable": true,
        "type": "string",
        "description": "VulnerabilityState indicates if vulnerability is being observed or deferred(/suppressed). By default, it vulnerabilities are observed.\n\n - OBSERVED: [Default state]",
        "default": "OBSERVED",
        "enum": [
          "OBSERVED",
          "DEFERRED",
          "FALSE_POSITIVE"
        ]
      },
      "storageRequestStatus": {
        "nullable": true,
        "type": "string",
        "description": "RequestStatus indicates the status of a vulnerability request.\n\n**Status Lifecycle:**\n- PENDING: Default state for new requests awaiting approval/denial\n- APPROVED: Request approved and enforced\n- DENIED: Request denied and permanently closed\n- APPROVED_PENDING_UPDATE: Approved request with pending update\n\n**Status Rules:**\n- New requests must start in PENDING state\n- Only PENDING requests can be approved or denied\n- APPROVED requests can be updated (creates APPROVED_PENDING_UPDATE)\n- DENIED requests are permanently closed\n- Cancelled requests are not persisted (except in audit logs)\n\n - PENDING: Default request state. It indicates that the request has not been fulfilled and that an action (approve/deny) is required.\nOnly requests in this state can be approved, denied, or updated.\n - APPROVED: Indicates that the request has been approved by the approver.\nApproved requests are immediately enforced and suppress vulnerability detection.\nOnly PENDING requests can transition to this state.\n - DENIED: Indicates that the request has been denied by the approver.\nDenied requests are permanently closed and have no impact on vulnerability detection.\nOnly PENDING requests can transition to this state.\n - APPROVED_PENDING_UPDATE: Indicates that the original request was approved, but an update is still pending an approval or denial.\nThis state occurs when an approved request is updated.\nThe original approval remains in effect until the update is processed.",
        "default": "PENDING",
        "enum": [
          "PENDING",
          "APPROVED",
          "DENIED",
          "APPROVED_PENDING_UPDATE"
        ]
      },
      "storageSlimUser": {
        "nullable": true,
        "type": "object",
        "properties": {
          "id": {
            "nullable": true,
            "type": "string"
          },
          "name": {
            "nullable": true,
            "type": "string"
          }
        }
      },
      "storageRequestComment": {
        "nullable": true,
        "type": "object",
        "properties": {
          "id": {
            "nullable": true,
            "type": "string",
            "description": "Unique identifier for the comment."
          },
          "message": {
            "nullable": true,
            "type": "string",
            "description": "The comment message content.\nRequired for all request actions."
          },
          "user": {
            "nullable": true,
            "type": "object",
            "properties": {
              "id": {
                "nullable": true,
                "type": "string"
              },
              "name": {
                "nullable": true,
                "type": "string"
              }
            }
          },
          "createdAt": {
            "nullable": true,
            "type": "string",
            "description": "Timestamp when the comment was created.",
            "format": "date-time"
          }
        },
        "description": "RequestComment represents a comment on a vulnerability request.\n\n**Comment Rules:**\n- Comments are required for all request actions (create, approve, deny, update)\n- Each comment is associated with a user and timestamp\n- Comments provide audit trail for request lifecycle"
      },
      "VulnerabilityRequestScopeImage": {
        "nullable": true,
        "type": "object",
        "properties": {
          "registry": {
            "nullable": true,
            "type": "string",
            "description": "Container registry (e.g., \"docker.io\", \"gcr.io\").\nRequired for image scope."
          },
          "remote": {
            "nullable": true,
            "type": "string",
            "description": "Image repository name (e.g., \"stackrox/main\").\nRequired for image scope."
          },
          "tag": {
            "nullable": true,
            "type": "string",
            "description": "Image tag (e.g., \"latest\", \"v1.0.0\").\nRequired for image scope."
          }
        },
        "description": "Image scope applies the request to specific container images."
      },
      "ScopeGlobal": {
        "nullable": true,
        "type": "object",
        "description": "Global scope applies the request system-wide (deprecated)."
      },
      "storageVulnerabilityRequestScope": {
        "nullable": true,
        "type": "object",
        "properties": {
          "imageScope": {
            "nullable": true,
            "type": "object",
            "properties": {
              "registry": {
                "nullable": true,
                "type": "string",
                "description": "Container registry (e.g., \"docker.io\", \"gcr.io\").\nRequired for image scope."
              },
              "remote": {
                "nullable": true,
                "type": "string",
                "description": "Image repository name (e.g., \"stackrox/main\").\nRequired for image scope."
              },
              "tag": {
                "nullable": true,
                "type": "string",
                "description": "Image tag (e.g., \"latest\", \"v1.0.0\").\nRequired for image scope."
              }
            },
            "description": "Image scope applies the request to specific container images."
          },
          "globalScope": {
            "nullable": true,
            "type": "object",
            "description": "Global scope applies the request system-wide (deprecated)."
          }
        },
        "description": "Scope defines the scope where the vulnerability request applies."
      },
      "storageRequester": {
        "nullable": true,
        "type": "object",
        "properties": {
          "id": {
            "nullable": true,
            "type": "string",
            "description": "Unique identifier for the requester."
          },
          "name": {
            "nullable": true,
            "type": "string",
            "description": "Display name of the requester."
          }
        },
        "description": "Requester represents the user who created the vulnerability request.\n\n**Requester Rules:**\n- Must be specified for all new requests\n- Cannot be changed after request creation\n- Used for audit trail and permission checks"
      },
      "storageApprover": {
        "nullable": true,
        "type": "object",
        "properties": {
          "id": {
            "nullable": true,
            "type": "string",
            "description": "Unique identifier for the approver."
          },
          "name": {
            "nullable": true,
            "type": "string",
            "description": "Display name of the approver."
          }
        },
        "description": "Approver represents a user who can approve or deny vulnerability requests.\n\n**Approver Rules:**\n- Multiple approvers can be assigned to a request\n- Any approver can approve or deny the request\n- Used for audit trail and permission checks"
      },
      "RequestExpiryExpiryType": {
        "nullable": true,
        "type": "string",
        "description": "ExpiryType indicates the type of expiry for the request.\nThis field is under development, DO NOT USE FOR NON-DEVELOPMENT PURPOSES.\n\n - TIME: Request has a fixed expiry time. If used, expires_on must be set.\n - ALL_CVE_FIXABLE: Request expires if all CVEs in the request are fixable.\n - ANY_CVE_FIXABLE: Request expires if any CVE in the request is fixable.",
        "default": "TIME",
        "enum": [
          "TIME",
          "ALL_CVE_FIXABLE",
          "ANY_CVE_FIXABLE"
        ]
      },
      "storageRequestExpiry": {
        "nullable": true,
        "type": "object",
        "properties": {
          "expiresWhenFixed": {
            "type": "boolean",
            "description": "Indicates that this request expires when the associated vulnerability is fixed.\nCannot be used with expires_on.\nOnly applicable to deferral requests."
          },
          "expiresOn": {
            "nullable": true,
            "type": "string",
            "description": "Indicates the timestamp when this request expires.\nCannot be used with expires_when_fixed.\nMust be a future timestamp.",
            "format": "date-time"
          },
          "expiryType": {
            "nullable": true,
            "type": "string",
            "description": "ExpiryType indicates the type of expiry for the request.\nThis field is under development, DO NOT USE FOR NON-DEVELOPMENT PURPOSES.\n\n - TIME: Request has a fixed expiry time. If used, expires_on must be set.\n - ALL_CVE_FIXABLE: Request expires if all CVEs in the request are fixable.\n - ANY_CVE_FIXABLE: Request expires if any CVE in the request is fixable.",
            "default": "TIME",
            "enum": [
              "TIME",
              "ALL_CVE_FIXABLE",
              "ANY_CVE_FIXABLE"
            ]
          }
        },
        "description": "RequestExpiry defines the expiration configuration for deferral requests.\n\n**Expiry Rules:**\n- Deferral requests must specify expiry (either expires_when_fixed or expires_on)\n- False-positive requests do not have expiry (permanent)\n- Cannot specify both expiry options\n- Expiry type is under development (do not use for non-development purposes)"
      },
      "storageDeferralRequest": {
        "nullable": true,
        "type": "object",
        "properties": {
          "expiry": {
            "nullable": true,
            "type": "object",
            "properties": {
              "expiresWhenFixed": {
                "type": "boolean",
                "description": "Indicates that this request expires when the associated vulnerability is fixed.\nCannot be used with expires_on.\nOnly applicable to deferral requests."
              },
              "expiresOn": {
                "nullable": true,
                "type": "string",
                "description": "Indicates the timestamp when this request expires.\nCannot be used with expires_when_fixed.\nMust be a future timestamp.",
                "format": "date-time"
              },
              "expiryType": {
                "nullable": true,
                "type": "string",
                "description": "ExpiryType indicates the type of expiry for the request.\nThis field is under development, DO NOT USE FOR NON-DEVELOPMENT PURPOSES.\n\n - TIME: Request has a fixed expiry time. If used, expires_on must be set.\n - ALL_CVE_FIXABLE: Request expires if all CVEs in the request are fixable.\n - ANY_CVE_FIXABLE: Request expires if any CVE in the request is fixable.",
                "default": "TIME",
                "enum": [
                  "TIME",
                  "ALL_CVE_FIXABLE",
                  "ANY_CVE_FIXABLE"
                ]
              }
            },
            "description": "RequestExpiry defines the expiration configuration for deferral requests.\n\n**Expiry Rules:**\n- Deferral requests must specify expiry (either expires_when_fixed or expires_on)\n- False-positive requests do not have expiry (permanent)\n- Cannot specify both expiry options\n- Expiry type is under development (do not use for non-development purposes)"
          }
        },
        "description": "DeferralRequest represents a request to temporarily defer vulnerability detection.\n\n**Deferral Rules:**\n- Must specify expiry configuration\n- Expiry can be time-based or fix-based\n- Deferrals are temporary and expire automatically"
      },
      "storageFalsePositiveRequest": {
        "nullable": true,
        "type": "object",
        "description": "FalsePositiveRequest represents a request to permanently mark vulnerabilities as false-positive.\n\n**False-Positive Rules:**\n- No expiry configuration (permanent)\n- False-positives are permanently suppressed\n- Cannot be undone except through request management"
      },
      "VulnerabilityRequestCVEs": {
        "nullable": true,
        "type": "object",
        "properties": {
          "cves": {
            "type": "array",
            "description": "These are (NVD) vulnerability identifiers, `cve` field of `storage.CVE`, and *not* the `id` field.\nFor example, CVE-2021-44832.\nMust be in valid CVE format and not already covered by approved requests.",
            "items": {
              "nullable": true,
              "type": "string"
            }
          }
        },
        "description": "CVEs represents the list of CVE identifiers in the request."
      },
      "storageDeferralUpdate": {
        "nullable": true,
        "type": "object",
        "properties": {
          "CVEs": {
            "type": "array",
            "description": "CVEs to be updated in the deferral request.\nCannot be empty (at least one CVE must remain).",
            "items": {
              "nullable": true,
              "type": "string"
            }
          },
          "expiry": {
            "nullable": true,
            "type": "object",
            "properties": {
              "expiresWhenFixed": {
                "type": "boolean",
                "description": "Indicates that this request expires when the associated vulnerability is fixed.\nCannot be used with expires_on.\nOnly applicable to deferral requests."
              },
              "expiresOn": {
                "nullable": true,
                "type": "string",
                "description": "Indicates the timestamp when this request expires.\nCannot be used with expires_when_fixed.\nMust be a future timestamp.",
                "format": "date-time"
              },
              "expiryType": {
                "nullable": true,
                "type": "string",
                "description": "ExpiryType indicates the type of expiry for the request.\nThis field is under development, DO NOT USE FOR NON-DEVELOPMENT PURPOSES.\n\n - TIME: Request has a fixed expiry time. If used, expires_on must be set.\n - ALL_CVE_FIXABLE: Request expires if all CVEs in the request are fixable.\n - ANY_CVE_FIXABLE: Request expires if any CVE in the request is fixable.",
                "default": "TIME",
                "enum": [
                  "TIME",
                  "ALL_CVE_FIXABLE",
                  "ANY_CVE_FIXABLE"
                ]
              }
            },
            "description": "RequestExpiry defines the expiration configuration for deferral requests.\n\n**Expiry Rules:**\n- Deferral requests must specify expiry (either expires_when_fixed or expires_on)\n- False-positive requests do not have expiry (permanent)\n- Cannot specify both expiry options\n- Expiry type is under development (do not use for non-development purposes)"
          }
        },
        "description": "DeferralUpdate represents an update to an existing deferral request.\n\n**Update Rules:**\n- Can add or remove CVEs from the request\n- Cannot remove all CVEs (at least one CVE must remain)\n- Can update expiry configuration\n- Creates a new pending update request"
      },
      "storageFalsePositiveUpdate": {
        "nullable": true,
        "type": "object",
        "properties": {
          "CVEs": {
            "type": "array",
            "description": "CVEs to be updated in the false-positive request.\nCannot be empty (at least one CVE must remain).",
            "items": {
              "nullable": true,
              "type": "string"
            }
          }
        },
        "description": "FalsePositiveUpdate represents an update to an existing false-positive request.\n\n**Update Rules:**\n- Can add or remove CVEs from the request\n- Cannot remove all CVEs (at least one CVE must remain)\n- False-positive requests remain permanent (no expiry)"
      },
      "storageVulnerabilityRequest": {
        "nullable": true,
        "type": "object",
        "properties": {
          "id": {
            "nullable": true,
            "type": "string",
            "description": "Unique identifier for the vulnerability request (auto-generated).\nNew requests must not specify this field."
          },
          "name": {
            "nullable": true,
            "type": "string",
            "description": "Human-readable name for the request (auto-generated).\nMust be unique across all requests."
          },
          "targetState": {
            "nullable": true,
            "type": "string",
            "description": "VulnerabilityState indicates if vulnerability is being observed or deferred(/suppressed). By default, it vulnerabilities are observed.\n\n - OBSERVED: [Default state]",
            "default": "OBSERVED",
            "enum": [
              "OBSERVED",
              "DEFERRED",
              "FALSE_POSITIVE"
            ]
          },
          "status": {
            "nullable": true,
            "type": "string",
            "description": "RequestStatus indicates the status of a vulnerability request.\n\n**Status Lifecycle:**\n- PENDING: Default state for new requests awaiting approval/denial\n- APPROVED: Request approved and enforced\n- DENIED: Request denied and permanently closed\n- APPROVED_PENDING_UPDATE: Approved request with pending update\n\n**Status Rules:**\n- New requests must start in PENDING state\n- Only PENDING requests can be approved or denied\n- APPROVED requests can be updated (creates APPROVED_PENDING_UPDATE)\n- DENIED requests are permanently closed\n- Cancelled requests are not persisted (except in audit logs)\n\n - PENDING: Default request state. It indicates that the request has not been fulfilled and that an action (approve/deny) is required.\nOnly requests in this state can be approved, denied, or updated.\n - APPROVED: Indicates that the request has been approved by the approver.\nApproved requests are immediately enforced and suppress vulnerability detection.\nOnly PENDING requests can transition to this state.\n - DENIED: Indicates that the request has been denied by the approver.\nDenied requests are permanently closed and have no impact on vulnerability detection.\nOnly PENDING requests can transition to this state.\n - APPROVED_PENDING_UPDATE: Indicates that the original request was approved, but an update is still pending an approval or denial.\nThis state occurs when an approved request is updated.\nThe original approval remains in effect until the update is processed.",
            "default": "PENDING",
            "enum": [
              "PENDING",
              "APPROVED",
              "DENIED",
              "APPROVED_PENDING_UPDATE"
            ]
          },
          "expired": {
            "type": "boolean",
            "description": "Indicates if this request is a historical request that is no longer in effect\ndue to deferral expiry, cancellation, or restarting cve observation.\nExpired requests are retained for audit purposes."
          },
          "requestor": {
            "nullable": true,
            "type": "object",
            "properties": {
              "id": {
                "nullable": true,
                "type": "string"
              },
              "name": {
                "nullable": true,
                "type": "string"
              }
            }
          },
          "approvers": {
            "type": "array",
            "description": "DEPRECATED: Use approvers_v2 instead.\nUsers who can approve or deny the request.",
            "items": {
              "nullable": true,
              "type": "object",
              "properties": {
                "id": {
                  "nullable": true,
                  "type": "string"
                },
                "name": {
                  "nullable": true,
                  "type": "string"
                }
              }
            }
          },
          "createdAt": {
            "nullable": true,
            "type": "string",
            "description": "Timestamp when the request was created.",
            "format": "date-time"
          },
          "lastUpdated": {
            "nullable": true,
            "type": "string",
            "description": "Timestamp when the request was last updated.",
            "format": "date-time"
          },
          "comments": {
            "type": "array",
            "description": "Comments on the request providing audit trail.\nMust have at least one comment for new requests.",
            "items": {
              "nullable": true,
              "type": "object",
              "properties": {
                "id": {
                  "nullable": true,
                  "type": "string",
                  "description": "Unique identifier for the comment."
                },
                "message": {
                  "nullable": true,
                  "type": "string",
                  "description": "The comment message content.\nRequired for all request actions."
                },
                "user": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "id": {
                      "nullable": true,
                      "type": "string"
                    },
                    "name": {
                      "nullable": true,
                      "type": "string"
                    }
                  }
                },
                "createdAt": {
                  "nullable": true,
                  "type": "string",
                  "description": "Timestamp when the comment was created.",
                  "format": "date-time"
                }
              },
              "description": "RequestComment represents a comment on a vulnerability request.\n\n**Comment Rules:**\n- Comments are required for all request actions (create, approve, deny, update)\n- Each comment is associated with a user and timestamp\n- Comments provide audit trail for request lifecycle"
            }
          },
          "scope": {
            "nullable": true,
            "type": "object",
            "properties": {
              "imageScope": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "registry": {
                    "nullable": true,
                    "type": "string",
                    "description": "Container registry (e.g., \"docker.io\", \"gcr.io\").\nRequired for image scope."
                  },
                  "remote": {
                    "nullable": true,
                    "type": "string",
                    "description": "Image repository name (e.g., \"stackrox/main\").\nRequired for image scope."
                  },
                  "tag": {
                    "nullable": true,
                    "type": "string",
                    "description": "Image tag (e.g., \"latest\", \"v1.0.0\").\nRequired for image scope."
                  }
                },
                "description": "Image scope applies the request to specific container images."
              },
              "globalScope": {
                "nullable": true,
                "type": "object",
                "description": "Global scope applies the request system-wide (deprecated)."
              }
            },
            "description": "Scope defines the scope where the vulnerability request applies."
          },
          "requesterV2": {
            "nullable": true,
            "type": "object",
            "properties": {
              "id": {
                "nullable": true,
                "type": "string",
                "description": "Unique identifier for the requester."
              },
              "name": {
                "nullable": true,
                "type": "string",
                "description": "Display name of the requester."
              }
            },
            "description": "Requester represents the user who created the vulnerability request.\n\n**Requester Rules:**\n- Must be specified for all new requests\n- Cannot be changed after request creation\n- Used for audit trail and permission checks"
          },
          "approversV2": {
            "type": "array",
            "description": "Users who can approve or deny the request (v2).\nMultiple approvers can be assigned.",
            "items": {
              "nullable": true,
              "type": "object",
              "properties": {
                "id": {
                  "nullable": true,
                  "type": "string",
                  "description": "Unique identifier for the approver."
                },
                "name": {
                  "nullable": true,
                  "type": "string",
                  "description": "Display name of the approver."
                }
              },
              "description": "Approver represents a user who can approve or deny vulnerability requests.\n\n**Approver Rules:**\n- Multiple approvers can be assigned to a request\n- Any approver can approve or deny the request\n- Used for audit trail and permission checks"
            }
          },
          "deferralReq": {
            "nullable": true,
            "type": "object",
            "properties": {
              "expiry": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "expiresWhenFixed": {
                    "type": "boolean",
                    "description": "Indicates that this request expires when the associated vulnerability is fixed.\nCannot be used with expires_on.\nOnly applicable to deferral requests."
                  },
                  "expiresOn": {
                    "nullable": true,
                    "type": "string",
                    "description": "Indicates the timestamp when this request expires.\nCannot be used with expires_when_fixed.\nMust be a future timestamp.",
                    "format": "date-time"
                  },
                  "expiryType": {
                    "nullable": true,
                    "type": "string",
                    "description": "ExpiryType indicates the type of expiry for the request.\nThis field is under development, DO NOT USE FOR NON-DEVELOPMENT PURPOSES.\n\n - TIME: Request has a fixed expiry time. If used, expires_on must be set.\n - ALL_CVE_FIXABLE: Request expires if all CVEs in the request are fixable.\n - ANY_CVE_FIXABLE: Request expires if any CVE in the request is fixable.",
                    "default": "TIME",
                    "enum": [
                      "TIME",
                      "ALL_CVE_FIXABLE",
                      "ANY_CVE_FIXABLE"
                    ]
                  }
                },
                "description": "RequestExpiry defines the expiration configuration for deferral requests.\n\n**Expiry Rules:**\n- Deferral requests must specify expiry (either expires_when_fixed or expires_on)\n- False-positive requests do not have expiry (permanent)\n- Cannot specify both expiry options\n- Expiry type is under development (do not use for non-development purposes)"
              }
            },
            "description": "DeferralRequest represents a request to temporarily defer vulnerability detection.\n\n**Deferral Rules:**\n- Must specify expiry configuration\n- Expiry can be time-based or fix-based\n- Deferrals are temporary and expire automatically"
          },
          "fpRequest": {
            "nullable": true,
            "type": "object",
            "description": "FalsePositiveRequest represents a request to permanently mark vulnerabilities as false-positive.\n\n**False-Positive Rules:**\n- No expiry configuration (permanent)\n- False-positives are permanently suppressed\n- Cannot be undone except through request management"
          },
          "cves": {
            "nullable": true,
            "type": "object",
            "properties": {
              "cves": {
                "type": "array",
                "description": "These are (NVD) vulnerability identifiers, `cve` field of `storage.CVE`, and *not* the `id` field.\nFor example, CVE-2021-44832.\nMust be in valid CVE format and not already covered by approved requests.",
                "items": {
                  "nullable": true,
                  "type": "string"
                }
              }
            },
            "description": "CVEs represents the list of CVE identifiers in the request."
          },
          "updatedDeferralReq": {
            "nullable": true,
            "type": "object",
            "properties": {
              "expiry": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "expiresWhenFixed": {
                    "type": "boolean",
                    "description": "Indicates that this request expires when the associated vulnerability is fixed.\nCannot be used with expires_on.\nOnly applicable to deferral requests."
                  },
                  "expiresOn": {
                    "nullable": true,
                    "type": "string",
                    "description": "Indicates the timestamp when this request expires.\nCannot be used with expires_when_fixed.\nMust be a future timestamp.",
                    "format": "date-time"
                  },
                  "expiryType": {
                    "nullable": true,
                    "type": "string",
                    "description": "ExpiryType indicates the type of expiry for the request.\nThis field is under development, DO NOT USE FOR NON-DEVELOPMENT PURPOSES.\n\n - TIME: Request has a fixed expiry time. If used, expires_on must be set.\n - ALL_CVE_FIXABLE: Request expires if all CVEs in the request are fixable.\n - ANY_CVE_FIXABLE: Request expires if any CVE in the request is fixable.",
                    "default": "TIME",
                    "enum": [
                      "TIME",
                      "ALL_CVE_FIXABLE",
                      "ANY_CVE_FIXABLE"
                    ]
                  }
                },
                "description": "RequestExpiry defines the expiration configuration for deferral requests.\n\n**Expiry Rules:**\n- Deferral requests must specify expiry (either expires_when_fixed or expires_on)\n- False-positive requests do not have expiry (permanent)\n- Cannot specify both expiry options\n- Expiry type is under development (do not use for non-development purposes)"
              }
            },
            "description": "DeferralRequest represents a request to temporarily defer vulnerability detection.\n\n**Deferral Rules:**\n- Must specify expiry configuration\n- Expiry can be time-based or fix-based\n- Deferrals are temporary and expire automatically"
          },
          "deferralUpdate": {
            "nullable": true,
            "type": "object",
            "properties": {
              "CVEs": {
                "type": "array",
                "description": "CVEs to be updated in the deferral request.\nCannot be empty (at least one CVE must remain).",
                "items": {
                  "nullable": true,
                  "type": "string"
                }
              },
              "expiry": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "expiresWhenFixed": {
                    "type": "boolean",
                    "description": "Indicates that this request expires when the associated vulnerability is fixed.\nCannot be used with expires_on.\nOnly applicable to deferral requests."
                  },
                  "expiresOn": {
                    "nullable": true,
                    "type": "string",
                    "description": "Indicates the timestamp when this request expires.\nCannot be used with expires_when_fixed.\nMust be a future timestamp.",
                    "format": "date-time"
                  },
                  "expiryType": {
                    "nullable": true,
                    "type": "string",
                    "description": "ExpiryType indicates the type of expiry for the request.\nThis field is under development, DO NOT USE FOR NON-DEVELOPMENT PURPOSES.\n\n - TIME: Request has a fixed expiry time. If used, expires_on must be set.\n - ALL_CVE_FIXABLE: Request expires if all CVEs in the request are fixable.\n - ANY_CVE_FIXABLE: Request expires if any CVE in the request is fixable.",
                    "default": "TIME",
                    "enum": [
                      "TIME",
                      "ALL_CVE_FIXABLE",
                      "ANY_CVE_FIXABLE"
                    ]
                  }
                },
                "description": "RequestExpiry defines the expiration configuration for deferral requests.\n\n**Expiry Rules:**\n- Deferral requests must specify expiry (either expires_when_fixed or expires_on)\n- False-positive requests do not have expiry (permanent)\n- Cannot specify both expiry options\n- Expiry type is under development (do not use for non-development purposes)"
              }
            },
            "description": "DeferralUpdate represents an update to an existing deferral request.\n\n**Update Rules:**\n- Can add or remove CVEs from the request\n- Cannot remove all CVEs (at least one CVE must remain)\n- Can update expiry configuration\n- Creates a new pending update request"
          },
          "falsePositiveUpdate": {
            "nullable": true,
            "type": "object",
            "properties": {
              "CVEs": {
                "type": "array",
                "description": "CVEs to be updated in the false-positive request.\nCannot be empty (at least one CVE must remain).",
                "items": {
                  "nullable": true,
                  "type": "string"
                }
              }
            },
            "description": "FalsePositiveUpdate represents an update to an existing false-positive request.\n\n**Update Rules:**\n- Can add or remove CVEs from the request\n- Cannot remove all CVEs (at least one CVE must remain)\n- False-positive requests remain permanent (no expiry)"
          }
        },
        "description": "VulnerabilityRequest encapsulates a request such as deferral request and false-positive request.\n\n**Request Lifecycle:**\n- Creation: New request in PENDING state\n- Approval: Request approved and enforced\n- Denial: Request denied and closed\n- Update: Approved request with pending update\n- Expiry: Request expires automatically or manually\n- Undo: Approved request undone and vulnerabilities re-enabled\n\n**Validation Rules:**\n- New requests must not have ID (auto-generated)\n- Must have at least one comment\n- Must have valid CVE format (e.g., \"CVE-2021-1234\")\n- Must have valid scope (image scope or global scope)\n- Cannot create duplicate requests for same CVE-scope combination\n- Deferral requests must specify expiry\n- False-positive requests are permanent (no expiry)\n- New requests cannot start in APPROVED or DENIED state\n\n**Performance Considerations:**\n- Maximum 1000 requests returned per list operation\n- Requests are processed sequentially to prevent race conditions\n- Duplicate prevention checks are performed during creation"
      },
      "v1ListVulnerabilityRequestsResponse": {
        "nullable": true,
        "type": "object",
        "properties": {
          "requestInfos": {
            "type": "array",
            "description": "List of vulnerability requests matching the search criteria.\nLimited to maximum 1000 requests per response.",
            "items": {
              "nullable": true,
              "type": "object",
              "properties": {
                "id": {
                  "nullable": true,
                  "type": "string",
                  "description": "Unique identifier for the vulnerability request (auto-generated).\nNew requests must not specify this field."
                },
                "name": {
                  "nullable": true,
                  "type": "string",
                  "description": "Human-readable name for the request (auto-generated).\nMust be unique across all requests."
                },
                "targetState": {
                  "nullable": true,
                  "type": "string",
                  "description": "VulnerabilityState indicates if vulnerability is being observed or deferred(/suppressed). By default, it vulnerabilities are observed.\n\n - OBSERVED: [Default state]",
                  "default": "OBSERVED",
                  "enum": [
                    "OBSERVED",
                    "DEFERRED",
                    "FALSE_POSITIVE"
                  ]
                },
                "status": {
                  "nullable": true,
                  "type": "string",
                  "description": "RequestStatus indicates the status of a vulnerability request.\n\n**Status Lifecycle:**\n- PENDING: Default state for new requests awaiting approval/denial\n- APPROVED: Request approved and enforced\n- DENIED: Request denied and permanently closed\n- APPROVED_PENDING_UPDATE: Approved request with pending update\n\n**Status Rules:**\n- New requests must start in PENDING state\n- Only PENDING requests can be approved or denied\n- APPROVED requests can be updated (creates APPROVED_PENDING_UPDATE)\n- DENIED requests are permanently closed\n- Cancelled requests are not persisted (except in audit logs)\n\n - PENDING: Default request state. It indicates that the request has not been fulfilled and that an action (approve/deny) is required.\nOnly requests in this state can be approved, denied, or updated.\n - APPROVED: Indicates that the request has been approved by the approver.\nApproved requests are immediately enforced and suppress vulnerability detection.\nOnly PENDING requests can transition to this state.\n - DENIED: Indicates that the request has been denied by the approver.\nDenied requests are permanently closed and have no impact on vulnerability detection.\nOnly PENDING requests can transition to this state.\n - APPROVED_PENDING_UPDATE: Indicates that the original request was approved, but an update is still pending an approval or denial.\nThis state occurs when an approved request is updated.\nThe original approval remains in effect until the update is processed.",
                  "default": "PENDING",
                  "enum": [
                    "PENDING",
                    "APPROVED",
                    "DENIED",
                    "APPROVED_PENDING_UPDATE"
                  ]
                },
                "expired": {
                  "type": "boolean",
                  "description": "Indicates if this request is a historical request that is no longer in effect\ndue to deferral expiry, cancellation, or restarting cve observation.\nExpired requests are retained for audit purposes."
                },
                "requestor": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "id": {
                      "nullable": true,
                      "type": "string"
                    },
                    "name": {
                      "nullable": true,
                      "type": "string"
                    }
                  }
                },
                "approvers": {
                  "type": "array",
                  "description": "DEPRECATED: Use approvers_v2 instead.\nUsers who can approve or deny the request.",
                  "items": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "id": {
                        "nullable": true,
                        "type": "string"
                      },
                      "name": {
                        "nullable": true,
                        "type": "string"
                      }
                    }
                  }
                },
                "createdAt": {
                  "nullable": true,
                  "type": "string",
                  "description": "Timestamp when the request was created.",
                  "format": "date-time"
                },
                "lastUpdated": {
                  "nullable": true,
                  "type": "string",
                  "description": "Timestamp when the request was last updated.",
                  "format": "date-time"
                },
                "comments": {
                  "type": "array",
                  "description": "Comments on the request providing audit trail.\nMust have at least one comment for new requests.",
                  "items": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "id": {
                        "nullable": true,
                        "type": "string",
                        "description": "Unique identifier for the comment."
                      },
                      "message": {
                        "nullable": true,
                        "type": "string",
                        "description": "The comment message content.\nRequired for all request actions."
                      },
                      "user": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "id": {
                            "nullable": true,
                            "type": "string"
                          },
                          "name": {
                            "nullable": true,
                            "type": "string"
                          }
                        }
                      },
                      "createdAt": {
                        "nullable": true,
                        "type": "string",
                        "description": "Timestamp when the comment was created.",
                        "format": "date-time"
                      }
                    },
                    "description": "RequestComment represents a comment on a vulnerability request.\n\n**Comment Rules:**\n- Comments are required for all request actions (create, approve, deny, update)\n- Each comment is associated with a user and timestamp\n- Comments provide audit trail for request lifecycle"
                  }
                },
                "scope": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "imageScope": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "registry": {
                          "nullable": true,
                          "type": "string",
                          "description": "Container registry (e.g., \"docker.io\", \"gcr.io\").\nRequired for image scope."
                        },
                        "remote": {
                          "nullable": true,
                          "type": "string",
                          "description": "Image repository name (e.g., \"stackrox/main\").\nRequired for image scope."
                        },
                        "tag": {
                          "nullable": true,
                          "type": "string",
                          "description": "Image tag (e.g., \"latest\", \"v1.0.0\").\nRequired for image scope."
                        }
                      },
                      "description": "Image scope applies the request to specific container images."
                    },
                    "globalScope": {
                      "nullable": true,
                      "type": "object",
                      "description": "Global scope applies the request system-wide (deprecated)."
                    }
                  },
                  "description": "Scope defines the scope where the vulnerability request applies."
                },
                "requesterV2": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "id": {
                      "nullable": true,
                      "type": "string",
                      "description": "Unique identifier for the requester."
                    },
                    "name": {
                      "nullable": true,
                      "type": "string",
                      "description": "Display name of the requester."
                    }
                  },
                  "description": "Requester represents the user who created the vulnerability request.\n\n**Requester Rules:**\n- Must be specified for all new requests\n- Cannot be changed after request creation\n- Used for audit trail and permission checks"
                },
                "approversV2": {
                  "type": "array",
                  "description": "Users who can approve or deny the request (v2).\nMultiple approvers can be assigned.",
                  "items": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "id": {
                        "nullable": true,
                        "type": "string",
                        "description": "Unique identifier for the approver."
                      },
                      "name": {
                        "nullable": true,
                        "type": "string",
                        "description": "Display name of the approver."
                      }
                    },
                    "description": "Approver represents a user who can approve or deny vulnerability requests.\n\n**Approver Rules:**\n- Multiple approvers can be assigned to a request\n- Any approver can approve or deny the request\n- Used for audit trail and permission checks"
                  }
                },
                "deferralReq": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "expiry": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "expiresWhenFixed": {
                          "type": "boolean",
                          "description": "Indicates that this request expires when the associated vulnerability is fixed.\nCannot be used with expires_on.\nOnly applicable to deferral requests."
                        },
                        "expiresOn": {
                          "nullable": true,
                          "type": "string",
                          "description": "Indicates the timestamp when this request expires.\nCannot be used with expires_when_fixed.\nMust be a future timestamp.",
                          "format": "date-time"
                        },
                        "expiryType": {
                          "nullable": true,
                          "type": "string",
                          "description": "ExpiryType indicates the type of expiry for the request.\nThis field is under development, DO NOT USE FOR NON-DEVELOPMENT PURPOSES.\n\n - TIME: Request has a fixed expiry time. If used, expires_on must be set.\n - ALL_CVE_FIXABLE: Request expires if all CVEs in the request are fixable.\n - ANY_CVE_FIXABLE: Request expires if any CVE in the request is fixable.",
                          "default": "TIME",
                          "enum": [
                            "TIME",
                            "ALL_CVE_FIXABLE",
                            "ANY_CVE_FIXABLE"
                          ]
                        }
                      },
                      "description": "RequestExpiry defines the expiration configuration for deferral requests.\n\n**Expiry Rules:**\n- Deferral requests must specify expiry (either expires_when_fixed or expires_on)\n- False-positive requests do not have expiry (permanent)\n- Cannot specify both expiry options\n- Expiry type is under development (do not use for non-development purposes)"
                    }
                  },
                  "description": "DeferralRequest represents a request to temporarily defer vulnerability detection.\n\n**Deferral Rules:**\n- Must specify expiry configuration\n- Expiry can be time-based or fix-based\n- Deferrals are temporary and expire automatically"
                },
                "fpRequest": {
                  "nullable": true,
                  "type": "object",
                  "description": "FalsePositiveRequest represents a request to permanently mark vulnerabilities as false-positive.\n\n**False-Positive Rules:**\n- No expiry configuration (permanent)\n- False-positives are permanently suppressed\n- Cannot be undone except through request management"
                },
                "cves": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "cves": {
                      "type": "array",
                      "description": "These are (NVD) vulnerability identifiers, `cve` field of `storage.CVE`, and *not* the `id` field.\nFor example, CVE-2021-44832.\nMust be in valid CVE format and not already covered by approved requests.",
                      "items": {
                        "nullable": true,
                        "type": "string"
                      }
                    }
                  },
                  "description": "CVEs represents the list of CVE identifiers in the request."
                },
                "updatedDeferralReq": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "expiry": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "expiresWhenFixed": {
                          "type": "boolean",
                          "description": "Indicates that this request expires when the associated vulnerability is fixed.\nCannot be used with expires_on.\nOnly applicable to deferral requests."
                        },
                        "expiresOn": {
                          "nullable": true,
                          "type": "string",
                          "description": "Indicates the timestamp when this request expires.\nCannot be used with expires_when_fixed.\nMust be a future timestamp.",
                          "format": "date-time"
                        },
                        "expiryType": {
                          "nullable": true,
                          "type": "string",
                          "description": "ExpiryType indicates the type of expiry for the request.\nThis field is under development, DO NOT USE FOR NON-DEVELOPMENT PURPOSES.\n\n - TIME: Request has a fixed expiry time. If used, expires_on must be set.\n - ALL_CVE_FIXABLE: Request expires if all CVEs in the request are fixable.\n - ANY_CVE_FIXABLE: Request expires if any CVE in the request is fixable.",
                          "default": "TIME",
                          "enum": [
                            "TIME",
                            "ALL_CVE_FIXABLE",
                            "ANY_CVE_FIXABLE"
                          ]
                        }
                      },
                      "description": "RequestExpiry defines the expiration configuration for deferral requests.\n\n**Expiry Rules:**\n- Deferral requests must specify expiry (either expires_when_fixed or expires_on)\n- False-positive requests do not have expiry (permanent)\n- Cannot specify both expiry options\n- Expiry type is under development (do not use for non-development purposes)"
                    }
                  },
                  "description": "DeferralRequest represents a request to temporarily defer vulnerability detection.\n\n**Deferral Rules:**\n- Must specify expiry configuration\n- Expiry can be time-based or fix-based\n- Deferrals are temporary and expire automatically"
                },
                "deferralUpdate": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "CVEs": {
                      "type": "array",
                      "description": "CVEs to be updated in the deferral request.\nCannot be empty (at least one CVE must remain).",
                      "items": {
                        "nullable": true,
                        "type": "string"
                      }
                    },
                    "expiry": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "expiresWhenFixed": {
                          "type": "boolean",
                          "description": "Indicates that this request expires when the associated vulnerability is fixed.\nCannot be used with expires_on.\nOnly applicable to deferral requests."
                        },
                        "expiresOn": {
                          "nullable": true,
                          "type": "string",
                          "description": "Indicates the timestamp when this request expires.\nCannot be used with expires_when_fixed.\nMust be a future timestamp.",
                          "format": "date-time"
                        },
                        "expiryType": {
                          "nullable": true,
                          "type": "string",
                          "description": "ExpiryType indicates the type of expiry for the request.\nThis field is under development, DO NOT USE FOR NON-DEVELOPMENT PURPOSES.\n\n - TIME: Request has a fixed expiry time. If used, expires_on must be set.\n - ALL_CVE_FIXABLE: Request expires if all CVEs in the request are fixable.\n - ANY_CVE_FIXABLE: Request expires if any CVE in the request is fixable.",
                          "default": "TIME",
                          "enum": [
                            "TIME",
                            "ALL_CVE_FIXABLE",
                            "ANY_CVE_FIXABLE"
                          ]
                        }
                      },
                      "description": "RequestExpiry defines the expiration configuration for deferral requests.\n\n**Expiry Rules:**\n- Deferral requests must specify expiry (either expires_when_fixed or expires_on)\n- False-positive requests do not have expiry (permanent)\n- Cannot specify both expiry options\n- Expiry type is under development (do not use for non-development purposes)"
                    }
                  },
                  "description": "DeferralUpdate represents an update to an existing deferral request.\n\n**Update Rules:**\n- Can add or remove CVEs from the request\n- Cannot remove all CVEs (at least one CVE must remain)\n- Can update expiry configuration\n- Creates a new pending update request"
                },
                "falsePositiveUpdate": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "CVEs": {
                      "type": "array",
                      "description": "CVEs to be updated in the false-positive request.\nCannot be empty (at least one CVE must remain).",
                      "items": {
                        "nullable": true,
                        "type": "string"
                      }
                    }
                  },
                  "description": "FalsePositiveUpdate represents an update to an existing false-positive request.\n\n**Update Rules:**\n- Can add or remove CVEs from the request\n- Cannot remove all CVEs (at least one CVE must remain)\n- False-positive requests remain permanent (no expiry)"
                }
              },
              "description": "VulnerabilityRequest encapsulates a request such as deferral request and false-positive request.\n\n**Request Lifecycle:**\n- Creation: New request in PENDING state\n- Approval: Request approved and enforced\n- Denial: Request denied and closed\n- Update: Approved request with pending update\n- Expiry: Request expires automatically or manually\n- Undo: Approved request undone and vulnerabilities re-enabled\n\n**Validation Rules:**\n- New requests must not have ID (auto-generated)\n- Must have at least one comment\n- Must have valid CVE format (e.g., \"CVE-2021-1234\")\n- Must have valid scope (image scope or global scope)\n- Cannot create duplicate requests for same CVE-scope combination\n- Deferral requests must specify expiry\n- False-positive requests are permanent (no expiry)\n- New requests cannot start in APPROVED or DENIED state\n\n**Performance Considerations:**\n- Maximum 1000 requests returned per list operation\n- Requests are processed sequentially to prevent race conditions\n- Duplicate prevention checks are performed during creation"
            }
          }
        },
        "description": "ListVulnerabilityRequestsResponse contains the list of vulnerability requests."
      },
      "v1DeferVulnRequest": {
        "nullable": true,
        "type": "object",
        "properties": {
          "cve": {
            "nullable": true,
            "type": "string",
            "description": "CVE identifier to be deferred (e.g., \"CVE-2021-1234\").\nMust be in valid CVE format and not already covered by approved requests."
          },
          "comment": {
            "nullable": true,
            "type": "string",
            "description": "Comment explaining the reason for the deferral request.\nRequired for request creation."
          },
          "scope": {
            "nullable": true,
            "type": "object",
            "properties": {
              "imageScope": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "registry": {
                    "nullable": true,
                    "type": "string",
                    "description": "Container registry (e.g., \"docker.io\", \"gcr.io\").\nRequired for image scope."
                  },
                  "remote": {
                    "nullable": true,
                    "type": "string",
                    "description": "Image repository name (e.g., \"stackrox/main\").\nRequired for image scope."
                  },
                  "tag": {
                    "nullable": true,
                    "type": "string",
                    "description": "Image tag (e.g., \"latest\", \"v1.0.0\").\nRequired for image scope."
                  }
                },
                "description": "Image scope applies the request to specific container images."
              },
              "globalScope": {
                "nullable": true,
                "type": "object",
                "description": "Global scope applies the request system-wide (deprecated)."
              }
            },
            "description": "Scope defines the scope where the vulnerability request applies."
          },
          "expiresWhenFixed": {
            "type": "boolean",
            "description": "When true, the deferral expires when the CVE is fixed.\nCannot be used with expires_on."
          },
          "expiresOn": {
            "nullable": true,
            "type": "string",
            "description": "Timestamp when the deferral expires.\nCannot be used with expires_when_fixed.",
            "format": "date-time"
          }
        },
        "description": "DeferVulnRequest contains parameters for creating a vulnerability deferral request.\n\n**Deferral Request Rules:**\n- CVE must be in valid format (e.g., \"CVE-2021-1234\")\n- Scope must be valid (image scope or global scope)\n- Expiry must be specified (either expires_when_fixed or expires_on)\n- Comment is required for request creation\n- Cannot create request for CVEs already covered by approved requests\n- Only one request can exist per CVE-scope combination\n\n**Expiry Options:**\n- expires_when_fixed: Request expires when CVE is fixed\n- expires_on: Request expires at specific timestamp\n- Cannot specify both expiry options\n\n**Scope Validation:**\n- Image scope: Must specify valid registry, remote, and tag\n- Global scope: Applies to all images (deprecated)"
      },
      "v1DeferVulnResponse": {
        "nullable": true,
        "type": "object",
        "properties": {
          "requestInfo": {
            "nullable": true,
            "type": "object",
            "properties": {
              "id": {
                "nullable": true,
                "type": "string",
                "description": "Unique identifier for the vulnerability request (auto-generated).\nNew requests must not specify this field."
              },
              "name": {
                "nullable": true,
                "type": "string",
                "description": "Human-readable name for the request (auto-generated).\nMust be unique across all requests."
              },
              "targetState": {
                "nullable": true,
                "type": "string",
                "description": "VulnerabilityState indicates if vulnerability is being observed or deferred(/suppressed). By default, it vulnerabilities are observed.\n\n - OBSERVED: [Default state]",
                "default": "OBSERVED",
                "enum": [
                  "OBSERVED",
                  "DEFERRED",
                  "FALSE_POSITIVE"
                ]
              },
              "status": {
                "nullable": true,
                "type": "string",
                "description": "RequestStatus indicates the status of a vulnerability request.\n\n**Status Lifecycle:**\n- PENDING: Default state for new requests awaiting approval/denial\n- APPROVED: Request approved and enforced\n- DENIED: Request denied and permanently closed\n- APPROVED_PENDING_UPDATE: Approved request with pending update\n\n**Status Rules:**\n- New requests must start in PENDING state\n- Only PENDING requests can be approved or denied\n- APPROVED requests can be updated (creates APPROVED_PENDING_UPDATE)\n- DENIED requests are permanently closed\n- Cancelled requests are not persisted (except in audit logs)\n\n - PENDING: Default request state. It indicates that the request has not been fulfilled and that an action (approve/deny) is required.\nOnly requests in this state can be approved, denied, or updated.\n - APPROVED: Indicates that the request has been approved by the approver.\nApproved requests are immediately enforced and suppress vulnerability detection.\nOnly PENDING requests can transition to this state.\n - DENIED: Indicates that the request has been denied by the approver.\nDenied requests are permanently closed and have no impact on vulnerability detection.\nOnly PENDING requests can transition to this state.\n - APPROVED_PENDING_UPDATE: Indicates that the original request was approved, but an update is still pending an approval or denial.\nThis state occurs when an approved request is updated.\nThe original approval remains in effect until the update is processed.",
                "default": "PENDING",
                "enum": [
                  "PENDING",
                  "APPROVED",
                  "DENIED",
                  "APPROVED_PENDING_UPDATE"
                ]
              },
              "expired": {
                "type": "boolean",
                "description": "Indicates if this request is a historical request that is no longer in effect\ndue to deferral expiry, cancellation, or restarting cve observation.\nExpired requests are retained for audit purposes."
              },
              "requestor": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "id": {
                    "nullable": true,
                    "type": "string"
                  },
                  "name": {
                    "nullable": true,
                    "type": "string"
                  }
                }
              },
              "approvers": {
                "type": "array",
                "description": "DEPRECATED: Use approvers_v2 instead.\nUsers who can approve or deny the request.",
                "items": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "id": {
                      "nullable": true,
                      "type": "string"
                    },
                    "name": {
                      "nullable": true,
                      "type": "string"
                    }
                  }
                }
              },
              "createdAt": {
                "nullable": true,
                "type": "string",
                "description": "Timestamp when the request was created.",
                "format": "date-time"
              },
              "lastUpdated": {
                "nullable": true,
                "type": "string",
                "description": "Timestamp when the request was last updated.",
                "format": "date-time"
              },
              "comments": {
                "type": "array",
                "description": "Comments on the request providing audit trail.\nMust have at least one comment for new requests.",
                "items": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "id": {
                      "nullable": true,
                      "type": "string",
                      "description": "Unique identifier for the comment."
                    },
                    "message": {
                      "nullable": true,
                      "type": "string",
                      "description": "The comment message content.\nRequired for all request actions."
                    },
                    "user": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "id": {
                          "nullable": true,
                          "type": "string"
                        },
                        "name": {
                          "nullable": true,
                          "type": "string"
                        }
                      }
                    },
                    "createdAt": {
                      "nullable": true,
                      "type": "string",
                      "description": "Timestamp when the comment was created.",
                      "format": "date-time"
                    }
                  },
                  "description": "RequestComment represents a comment on a vulnerability request.\n\n**Comment Rules:**\n- Comments are required for all request actions (create, approve, deny, update)\n- Each comment is associated with a user and timestamp\n- Comments provide audit trail for request lifecycle"
                }
              },
              "scope": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "imageScope": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "registry": {
                        "nullable": true,
                        "type": "string",
                        "description": "Container registry (e.g., \"docker.io\", \"gcr.io\").\nRequired for image scope."
                      },
                      "remote": {
                        "nullable": true,
                        "type": "string",
                        "description": "Image repository name (e.g., \"stackrox/main\").\nRequired for image scope."
                      },
                      "tag": {
                        "nullable": true,
                        "type": "string",
                        "description": "Image tag (e.g., \"latest\", \"v1.0.0\").\nRequired for image scope."
                      }
                    },
                    "description": "Image scope applies the request to specific container images."
                  },
                  "globalScope": {
                    "nullable": true,
                    "type": "object",
                    "description": "Global scope applies the request system-wide (deprecated)."
                  }
                },
                "description": "Scope defines the scope where the vulnerability request applies."
              },
              "requesterV2": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "id": {
                    "nullable": true,
                    "type": "string",
                    "description": "Unique identifier for the requester."
                  },
                  "name": {
                    "nullable": true,
                    "type": "string",
                    "description": "Display name of the requester."
                  }
                },
                "description": "Requester represents the user who created the vulnerability request.\n\n**Requester Rules:**\n- Must be specified for all new requests\n- Cannot be changed after request creation\n- Used for audit trail and permission checks"
              },
              "approversV2": {
                "type": "array",
                "description": "Users who can approve or deny the request (v2).\nMultiple approvers can be assigned.",
                "items": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "id": {
                      "nullable": true,
                      "type": "string",
                      "description": "Unique identifier for the approver."
                    },
                    "name": {
                      "nullable": true,
                      "type": "string",
                      "description": "Display name of the approver."
                    }
                  },
                  "description": "Approver represents a user who can approve or deny vulnerability requests.\n\n**Approver Rules:**\n- Multiple approvers can be assigned to a request\n- Any approver can approve or deny the request\n- Used for audit trail and permission checks"
                }
              },
              "deferralReq": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "expiry": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "expiresWhenFixed": {
                        "type": "boolean",
                        "description": "Indicates that this request expires when the associated vulnerability is fixed.\nCannot be used with expires_on.\nOnly applicable to deferral requests."
                      },
                      "expiresOn": {
                        "nullable": true,
                        "type": "string",
                        "description": "Indicates the timestamp when this request expires.\nCannot be used with expires_when_fixed.\nMust be a future timestamp.",
                        "format": "date-time"
                      },
                      "expiryType": {
                        "nullable": true,
                        "type": "string",
                        "description": "ExpiryType indicates the type of expiry for the request.\nThis field is under development, DO NOT USE FOR NON-DEVELOPMENT PURPOSES.\n\n - TIME: Request has a fixed expiry time. If used, expires_on must be set.\n - ALL_CVE_FIXABLE: Request expires if all CVEs in the request are fixable.\n - ANY_CVE_FIXABLE: Request expires if any CVE in the request is fixable.",
                        "default": "TIME",
                        "enum": [
                          "TIME",
                          "ALL_CVE_FIXABLE",
                          "ANY_CVE_FIXABLE"
                        ]
                      }
                    },
                    "description": "RequestExpiry defines the expiration configuration for deferral requests.\n\n**Expiry Rules:**\n- Deferral requests must specify expiry (either expires_when_fixed or expires_on)\n- False-positive requests do not have expiry (permanent)\n- Cannot specify both expiry options\n- Expiry type is under development (do not use for non-development purposes)"
                  }
                },
                "description": "DeferralRequest represents a request to temporarily defer vulnerability detection.\n\n**Deferral Rules:**\n- Must specify expiry configuration\n- Expiry can be time-based or fix-based\n- Deferrals are temporary and expire automatically"
              },
              "fpRequest": {
                "nullable": true,
                "type": "object",
                "description": "FalsePositiveRequest represents a request to permanently mark vulnerabilities as false-positive.\n\n**False-Positive Rules:**\n- No expiry configuration (permanent)\n- False-positives are permanently suppressed\n- Cannot be undone except through request management"
              },
              "cves": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "cves": {
                    "type": "array",
                    "description": "These are (NVD) vulnerability identifiers, `cve` field of `storage.CVE`, and *not* the `id` field.\nFor example, CVE-2021-44832.\nMust be in valid CVE format and not already covered by approved requests.",
                    "items": {
                      "nullable": true,
                      "type": "string"
                    }
                  }
                },
                "description": "CVEs represents the list of CVE identifiers in the request."
              },
              "updatedDeferralReq": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "expiry": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "expiresWhenFixed": {
                        "type": "boolean",
                        "description": "Indicates that this request expires when the associated vulnerability is fixed.\nCannot be used with expires_on.\nOnly applicable to deferral requests."
                      },
                      "expiresOn": {
                        "nullable": true,
                        "type": "string",
                        "description": "Indicates the timestamp when this request expires.\nCannot be used with expires_when_fixed.\nMust be a future timestamp.",
                        "format": "date-time"
                      },
                      "expiryType": {
                        "nullable": true,
                        "type": "string",
                        "description": "ExpiryType indicates the type of expiry for the request.\nThis field is under development, DO NOT USE FOR NON-DEVELOPMENT PURPOSES.\n\n - TIME: Request has a fixed expiry time. If used, expires_on must be set.\n - ALL_CVE_FIXABLE: Request expires if all CVEs in the request are fixable.\n - ANY_CVE_FIXABLE: Request expires if any CVE in the request is fixable.",
                        "default": "TIME",
                        "enum": [
                          "TIME",
                          "ALL_CVE_FIXABLE",
                          "ANY_CVE_FIXABLE"
                        ]
                      }
                    },
                    "description": "RequestExpiry defines the expiration configuration for deferral requests.\n\n**Expiry Rules:**\n- Deferral requests must specify expiry (either expires_when_fixed or expires_on)\n- False-positive requests do not have expiry (permanent)\n- Cannot specify both expiry options\n- Expiry type is under development (do not use for non-development purposes)"
                  }
                },
                "description": "DeferralRequest represents a request to temporarily defer vulnerability detection.\n\n**Deferral Rules:**\n- Must specify expiry configuration\n- Expiry can be time-based or fix-based\n- Deferrals are temporary and expire automatically"
              },
              "deferralUpdate": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "CVEs": {
                    "type": "array",
                    "description": "CVEs to be updated in the deferral request.\nCannot be empty (at least one CVE must remain).",
                    "items": {
                      "nullable": true,
                      "type": "string"
                    }
                  },
                  "expiry": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "expiresWhenFixed": {
                        "type": "boolean",
                        "description": "Indicates that this request expires when the associated vulnerability is fixed.\nCannot be used with expires_on.\nOnly applicable to deferral requests."
                      },
                      "expiresOn": {
                        "nullable": true,
                        "type": "string",
                        "description": "Indicates the timestamp when this request expires.\nCannot be used with expires_when_fixed.\nMust be a future timestamp.",
                        "format": "date-time"
                      },
                      "expiryType": {
                        "nullable": true,
                        "type": "string",
                        "description": "ExpiryType indicates the type of expiry for the request.\nThis field is under development, DO NOT USE FOR NON-DEVELOPMENT PURPOSES.\n\n - TIME: Request has a fixed expiry time. If used, expires_on must be set.\n - ALL_CVE_FIXABLE: Request expires if all CVEs in the request are fixable.\n - ANY_CVE_FIXABLE: Request expires if any CVE in the request is fixable.",
                        "default": "TIME",
                        "enum": [
                          "TIME",
                          "ALL_CVE_FIXABLE",
                          "ANY_CVE_FIXABLE"
                        ]
                      }
                    },
                    "description": "RequestExpiry defines the expiration configuration for deferral requests.\n\n**Expiry Rules:**\n- Deferral requests must specify expiry (either expires_when_fixed or expires_on)\n- False-positive requests do not have expiry (permanent)\n- Cannot specify both expiry options\n- Expiry type is under development (do not use for non-development purposes)"
                  }
                },
                "description": "DeferralUpdate represents an update to an existing deferral request.\n\n**Update Rules:**\n- Can add or remove CVEs from the request\n- Cannot remove all CVEs (at least one CVE must remain)\n- Can update expiry configuration\n- Creates a new pending update request"
              },
              "falsePositiveUpdate": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "CVEs": {
                    "type": "array",
                    "description": "CVEs to be updated in the false-positive request.\nCannot be empty (at least one CVE must remain).",
                    "items": {
                      "nullable": true,
                      "type": "string"
                    }
                  }
                },
                "description": "FalsePositiveUpdate represents an update to an existing false-positive request.\n\n**Update Rules:**\n- Can add or remove CVEs from the request\n- Cannot remove all CVEs (at least one CVE must remain)\n- False-positive requests remain permanent (no expiry)"
              }
            },
            "description": "VulnerabilityRequest encapsulates a request such as deferral request and false-positive request.\n\n**Request Lifecycle:**\n- Creation: New request in PENDING state\n- Approval: Request approved and enforced\n- Denial: Request denied and closed\n- Update: Approved request with pending update\n- Expiry: Request expires automatically or manually\n- Undo: Approved request undone and vulnerabilities re-enabled\n\n**Validation Rules:**\n- New requests must not have ID (auto-generated)\n- Must have at least one comment\n- Must have valid CVE format (e.g., \"CVE-2021-1234\")\n- Must have valid scope (image scope or global scope)\n- Cannot create duplicate requests for same CVE-scope combination\n- Deferral requests must specify expiry\n- False-positive requests are permanent (no expiry)\n- New requests cannot start in APPROVED or DENIED state\n\n**Performance Considerations:**\n- Maximum 1000 requests returned per list operation\n- Requests are processed sequentially to prevent race conditions\n- Duplicate prevention checks are performed during creation"
          }
        },
        "description": "DeferVulnResponse contains the created deferral request information."
      },
      "v1FalsePositiveVulnRequest": {
        "nullable": true,
        "type": "object",
        "properties": {
          "cve": {
            "nullable": true,
            "type": "string",
            "description": "CVE identifier to be marked as false-positive (e.g., \"CVE-2021-1234\").\nMust be in valid CVE format and not already covered by approved requests."
          },
          "scope": {
            "nullable": true,
            "type": "object",
            "properties": {
              "imageScope": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "registry": {
                    "nullable": true,
                    "type": "string",
                    "description": "Container registry (e.g., \"docker.io\", \"gcr.io\").\nRequired for image scope."
                  },
                  "remote": {
                    "nullable": true,
                    "type": "string",
                    "description": "Image repository name (e.g., \"stackrox/main\").\nRequired for image scope."
                  },
                  "tag": {
                    "nullable": true,
                    "type": "string",
                    "description": "Image tag (e.g., \"latest\", \"v1.0.0\").\nRequired for image scope."
                  }
                },
                "description": "Image scope applies the request to specific container images."
              },
              "globalScope": {
                "nullable": true,
                "type": "object",
                "description": "Global scope applies the request system-wide (deprecated)."
              }
            },
            "description": "Scope defines the scope where the vulnerability request applies."
          },
          "comment": {
            "nullable": true,
            "type": "string",
            "description": "Comment explaining why the CVE is considered false-positive.\nRequired for request creation."
          }
        },
        "description": "FalsePositiveVulnRequest contains parameters for creating a false-positive request.\n\n**False-Positive Request Rules:**\n- CVE must be in valid format (e.g., \"CVE-2021-1234\")\n- Scope must be valid (image scope or global scope)\n- Comment is required for request creation\n- Cannot create request for CVEs already covered by approved requests\n- Only one request can exist per CVE-scope combination\n- False-positive requests do not have expiry (permanent)"
      },
      "v1FalsePositiveVulnResponse": {
        "nullable": true,
        "type": "object",
        "properties": {
          "requestInfo": {
            "nullable": true,
            "type": "object",
            "properties": {
              "id": {
                "nullable": true,
                "type": "string",
                "description": "Unique identifier for the vulnerability request (auto-generated).\nNew requests must not specify this field."
              },
              "name": {
                "nullable": true,
                "type": "string",
                "description": "Human-readable name for the request (auto-generated).\nMust be unique across all requests."
              },
              "targetState": {
                "nullable": true,
                "type": "string",
                "description": "VulnerabilityState indicates if vulnerability is being observed or deferred(/suppressed). By default, it vulnerabilities are observed.\n\n - OBSERVED: [Default state]",
                "default": "OBSERVED",
                "enum": [
                  "OBSERVED",
                  "DEFERRED",
                  "FALSE_POSITIVE"
                ]
              },
              "status": {
                "nullable": true,
                "type": "string",
                "description": "RequestStatus indicates the status of a vulnerability request.\n\n**Status Lifecycle:**\n- PENDING: Default state for new requests awaiting approval/denial\n- APPROVED: Request approved and enforced\n- DENIED: Request denied and permanently closed\n- APPROVED_PENDING_UPDATE: Approved request with pending update\n\n**Status Rules:**\n- New requests must start in PENDING state\n- Only PENDING requests can be approved or denied\n- APPROVED requests can be updated (creates APPROVED_PENDING_UPDATE)\n- DENIED requests are permanently closed\n- Cancelled requests are not persisted (except in audit logs)\n\n - PENDING: Default request state. It indicates that the request has not been fulfilled and that an action (approve/deny) is required.\nOnly requests in this state can be approved, denied, or updated.\n - APPROVED: Indicates that the request has been approved by the approver.\nApproved requests are immediately enforced and suppress vulnerability detection.\nOnly PENDING requests can transition to this state.\n - DENIED: Indicates that the request has been denied by the approver.\nDenied requests are permanently closed and have no impact on vulnerability detection.\nOnly PENDING requests can transition to this state.\n - APPROVED_PENDING_UPDATE: Indicates that the original request was approved, but an update is still pending an approval or denial.\nThis state occurs when an approved request is updated.\nThe original approval remains in effect until the update is processed.",
                "default": "PENDING",
                "enum": [
                  "PENDING",
                  "APPROVED",
                  "DENIED",
                  "APPROVED_PENDING_UPDATE"
                ]
              },
              "expired": {
                "type": "boolean",
                "description": "Indicates if this request is a historical request that is no longer in effect\ndue to deferral expiry, cancellation, or restarting cve observation.\nExpired requests are retained for audit purposes."
              },
              "requestor": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "id": {
                    "nullable": true,
                    "type": "string"
                  },
                  "name": {
                    "nullable": true,
                    "type": "string"
                  }
                }
              },
              "approvers": {
                "type": "array",
                "description": "DEPRECATED: Use approvers_v2 instead.\nUsers who can approve or deny the request.",
                "items": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "id": {
                      "nullable": true,
                      "type": "string"
                    },
                    "name": {
                      "nullable": true,
                      "type": "string"
                    }
                  }
                }
              },
              "createdAt": {
                "nullable": true,
                "type": "string",
                "description": "Timestamp when the request was created.",
                "format": "date-time"
              },
              "lastUpdated": {
                "nullable": true,
                "type": "string",
                "description": "Timestamp when the request was last updated.",
                "format": "date-time"
              },
              "comments": {
                "type": "array",
                "description": "Comments on the request providing audit trail.\nMust have at least one comment for new requests.",
                "items": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "id": {
                      "nullable": true,
                      "type": "string",
                      "description": "Unique identifier for the comment."
                    },
                    "message": {
                      "nullable": true,
                      "type": "string",
                      "description": "The comment message content.\nRequired for all request actions."
                    },
                    "user": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "id": {
                          "nullable": true,
                          "type": "string"
                        },
                        "name": {
                          "nullable": true,
                          "type": "string"
                        }
                      }
                    },
                    "createdAt": {
                      "nullable": true,
                      "type": "string",
                      "description": "Timestamp when the comment was created.",
                      "format": "date-time"
                    }
                  },
                  "description": "RequestComment represents a comment on a vulnerability request.\n\n**Comment Rules:**\n- Comments are required for all request actions (create, approve, deny, update)\n- Each comment is associated with a user and timestamp\n- Comments provide audit trail for request lifecycle"
                }
              },
              "scope": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "imageScope": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "registry": {
                        "nullable": true,
                        "type": "string",
                        "description": "Container registry (e.g., \"docker.io\", \"gcr.io\").\nRequired for image scope."
                      },
                      "remote": {
                        "nullable": true,
                        "type": "string",
                        "description": "Image repository name (e.g., \"stackrox/main\").\nRequired for image scope."
                      },
                      "tag": {
                        "nullable": true,
                        "type": "string",
                        "description": "Image tag (e.g., \"latest\", \"v1.0.0\").\nRequired for image scope."
                      }
                    },
                    "description": "Image scope applies the request to specific container images."
                  },
                  "globalScope": {
                    "nullable": true,
                    "type": "object",
                    "description": "Global scope applies the request system-wide (deprecated)."
                  }
                },
                "description": "Scope defines the scope where the vulnerability request applies."
              },
              "requesterV2": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "id": {
                    "nullable": true,
                    "type": "string",
                    "description": "Unique identifier for the requester."
                  },
                  "name": {
                    "nullable": true,
                    "type": "string",
                    "description": "Display name of the requester."
                  }
                },
                "description": "Requester represents the user who created the vulnerability request.\n\n**Requester Rules:**\n- Must be specified for all new requests\n- Cannot be changed after request creation\n- Used for audit trail and permission checks"
              },
              "approversV2": {
                "type": "array",
                "description": "Users who can approve or deny the request (v2).\nMultiple approvers can be assigned.",
                "items": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "id": {
                      "nullable": true,
                      "type": "string",
                      "description": "Unique identifier for the approver."
                    },
                    "name": {
                      "nullable": true,
                      "type": "string",
                      "description": "Display name of the approver."
                    }
                  },
                  "description": "Approver represents a user who can approve or deny vulnerability requests.\n\n**Approver Rules:**\n- Multiple approvers can be assigned to a request\n- Any approver can approve or deny the request\n- Used for audit trail and permission checks"
                }
              },
              "deferralReq": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "expiry": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "expiresWhenFixed": {
                        "type": "boolean",
                        "description": "Indicates that this request expires when the associated vulnerability is fixed.\nCannot be used with expires_on.\nOnly applicable to deferral requests."
                      },
                      "expiresOn": {
                        "nullable": true,
                        "type": "string",
                        "description": "Indicates the timestamp when this request expires.\nCannot be used with expires_when_fixed.\nMust be a future timestamp.",
                        "format": "date-time"
                      },
                      "expiryType": {
                        "nullable": true,
                        "type": "string",
                        "description": "ExpiryType indicates the type of expiry for the request.\nThis field is under development, DO NOT USE FOR NON-DEVELOPMENT PURPOSES.\n\n - TIME: Request has a fixed expiry time. If used, expires_on must be set.\n - ALL_CVE_FIXABLE: Request expires if all CVEs in the request are fixable.\n - ANY_CVE_FIXABLE: Request expires if any CVE in the request is fixable.",
                        "default": "TIME",
                        "enum": [
                          "TIME",
                          "ALL_CVE_FIXABLE",
                          "ANY_CVE_FIXABLE"
                        ]
                      }
                    },
                    "description": "RequestExpiry defines the expiration configuration for deferral requests.\n\n**Expiry Rules:**\n- Deferral requests must specify expiry (either expires_when_fixed or expires_on)\n- False-positive requests do not have expiry (permanent)\n- Cannot specify both expiry options\n- Expiry type is under development (do not use for non-development purposes)"
                  }
                },
                "description": "DeferralRequest represents a request to temporarily defer vulnerability detection.\n\n**Deferral Rules:**\n- Must specify expiry configuration\n- Expiry can be time-based or fix-based\n- Deferrals are temporary and expire automatically"
              },
              "fpRequest": {
                "nullable": true,
                "type": "object",
                "description": "FalsePositiveRequest represents a request to permanently mark vulnerabilities as false-positive.\n\n**False-Positive Rules:**\n- No expiry configuration (permanent)\n- False-positives are permanently suppressed\n- Cannot be undone except through request management"
              },
              "cves": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "cves": {
                    "type": "array",
                    "description": "These are (NVD) vulnerability identifiers, `cve` field of `storage.CVE`, and *not* the `id` field.\nFor example, CVE-2021-44832.\nMust be in valid CVE format and not already covered by approved requests.",
                    "items": {
                      "nullable": true,
                      "type": "string"
                    }
                  }
                },
                "description": "CVEs represents the list of CVE identifiers in the request."
              },
              "updatedDeferralReq": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "expiry": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "expiresWhenFixed": {
                        "type": "boolean",
                        "description": "Indicates that this request expires when the associated vulnerability is fixed.\nCannot be used with expires_on.\nOnly applicable to deferral requests."
                      },
                      "expiresOn": {
                        "nullable": true,
                        "type": "string",
                        "description": "Indicates the timestamp when this request expires.\nCannot be used with expires_when_fixed.\nMust be a future timestamp.",
                        "format": "date-time"
                      },
                      "expiryType": {
                        "nullable": true,
                        "type": "string",
                        "description": "ExpiryType indicates the type of expiry for the request.\nThis field is under development, DO NOT USE FOR NON-DEVELOPMENT PURPOSES.\n\n - TIME: Request has a fixed expiry time. If used, expires_on must be set.\n - ALL_CVE_FIXABLE: Request expires if all CVEs in the request are fixable.\n - ANY_CVE_FIXABLE: Request expires if any CVE in the request is fixable.",
                        "default": "TIME",
                        "enum": [
                          "TIME",
                          "ALL_CVE_FIXABLE",
                          "ANY_CVE_FIXABLE"
                        ]
                      }
                    },
                    "description": "RequestExpiry defines the expiration configuration for deferral requests.\n\n**Expiry Rules:**\n- Deferral requests must specify expiry (either expires_when_fixed or expires_on)\n- False-positive requests do not have expiry (permanent)\n- Cannot specify both expiry options\n- Expiry type is under development (do not use for non-development purposes)"
                  }
                },
                "description": "DeferralRequest represents a request to temporarily defer vulnerability detection.\n\n**Deferral Rules:**\n- Must specify expiry configuration\n- Expiry can be time-based or fix-based\n- Deferrals are temporary and expire automatically"
              },
              "deferralUpdate": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "CVEs": {
                    "type": "array",
                    "description": "CVEs to be updated in the deferral request.\nCannot be empty (at least one CVE must remain).",
                    "items": {
                      "nullable": true,
                      "type": "string"
                    }
                  },
                  "expiry": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "expiresWhenFixed": {
                        "type": "boolean",
                        "description": "Indicates that this request expires when the associated vulnerability is fixed.\nCannot be used with expires_on.\nOnly applicable to deferral requests."
                      },
                      "expiresOn": {
                        "nullable": true,
                        "type": "string",
                        "description": "Indicates the timestamp when this request expires.\nCannot be used with expires_when_fixed.\nMust be a future timestamp.",
                        "format": "date-time"
                      },
                      "expiryType": {
                        "nullable": true,
                        "type": "string",
                        "description": "ExpiryType indicates the type of expiry for the request.\nThis field is under development, DO NOT USE FOR NON-DEVELOPMENT PURPOSES.\n\n - TIME: Request has a fixed expiry time. If used, expires_on must be set.\n - ALL_CVE_FIXABLE: Request expires if all CVEs in the request are fixable.\n - ANY_CVE_FIXABLE: Request expires if any CVE in the request is fixable.",
                        "default": "TIME",
                        "enum": [
                          "TIME",
                          "ALL_CVE_FIXABLE",
                          "ANY_CVE_FIXABLE"
                        ]
                      }
                    },
                    "description": "RequestExpiry defines the expiration configuration for deferral requests.\n\n**Expiry Rules:**\n- Deferral requests must specify expiry (either expires_when_fixed or expires_on)\n- False-positive requests do not have expiry (permanent)\n- Cannot specify both expiry options\n- Expiry type is under development (do not use for non-development purposes)"
                  }
                },
                "description": "DeferralUpdate represents an update to an existing deferral request.\n\n**Update Rules:**\n- Can add or remove CVEs from the request\n- Cannot remove all CVEs (at least one CVE must remain)\n- Can update expiry configuration\n- Creates a new pending update request"
              },
              "falsePositiveUpdate": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "CVEs": {
                    "type": "array",
                    "description": "CVEs to be updated in the false-positive request.\nCannot be empty (at least one CVE must remain).",
                    "items": {
                      "nullable": true,
                      "type": "string"
                    }
                  }
                },
                "description": "FalsePositiveUpdate represents an update to an existing false-positive request.\n\n**Update Rules:**\n- Can add or remove CVEs from the request\n- Cannot remove all CVEs (at least one CVE must remain)\n- False-positive requests remain permanent (no expiry)"
              }
            },
            "description": "VulnerabilityRequest encapsulates a request such as deferral request and false-positive request.\n\n**Request Lifecycle:**\n- Creation: New request in PENDING state\n- Approval: Request approved and enforced\n- Denial: Request denied and closed\n- Update: Approved request with pending update\n- Expiry: Request expires automatically or manually\n- Undo: Approved request undone and vulnerabilities re-enabled\n\n**Validation Rules:**\n- New requests must not have ID (auto-generated)\n- Must have at least one comment\n- Must have valid CVE format (e.g., \"CVE-2021-1234\")\n- Must have valid scope (image scope or global scope)\n- Cannot create duplicate requests for same CVE-scope combination\n- Deferral requests must specify expiry\n- False-positive requests are permanent (no expiry)\n- New requests cannot start in APPROVED or DENIED state\n\n**Performance Considerations:**\n- Maximum 1000 requests returned per list operation\n- Requests are processed sequentially to prevent race conditions\n- Duplicate prevention checks are performed during creation"
          }
        },
        "description": "FalsePositiveVulnResponse contains the created false-positive request information."
      },
      "v1GetVulnerabilityRequestResponse": {
        "nullable": true,
        "type": "object",
        "properties": {
          "requestInfo": {
            "nullable": true,
            "type": "object",
            "properties": {
              "id": {
                "nullable": true,
                "type": "string",
                "description": "Unique identifier for the vulnerability request (auto-generated).\nNew requests must not specify this field."
              },
              "name": {
                "nullable": true,
                "type": "string",
                "description": "Human-readable name for the request (auto-generated).\nMust be unique across all requests."
              },
              "targetState": {
                "nullable": true,
                "type": "string",
                "description": "VulnerabilityState indicates if vulnerability is being observed or deferred(/suppressed). By default, it vulnerabilities are observed.\n\n - OBSERVED: [Default state]",
                "default": "OBSERVED",
                "enum": [
                  "OBSERVED",
                  "DEFERRED",
                  "FALSE_POSITIVE"
                ]
              },
              "status": {
                "nullable": true,
                "type": "string",
                "description": "RequestStatus indicates the status of a vulnerability request.\n\n**Status Lifecycle:**\n- PENDING: Default state for new requests awaiting approval/denial\n- APPROVED: Request approved and enforced\n- DENIED: Request denied and permanently closed\n- APPROVED_PENDING_UPDATE: Approved request with pending update\n\n**Status Rules:**\n- New requests must start in PENDING state\n- Only PENDING requests can be approved or denied\n- APPROVED requests can be updated (creates APPROVED_PENDING_UPDATE)\n- DENIED requests are permanently closed\n- Cancelled requests are not persisted (except in audit logs)\n\n - PENDING: Default request state. It indicates that the request has not been fulfilled and that an action (approve/deny) is required.\nOnly requests in this state can be approved, denied, or updated.\n - APPROVED: Indicates that the request has been approved by the approver.\nApproved requests are immediately enforced and suppress vulnerability detection.\nOnly PENDING requests can transition to this state.\n - DENIED: Indicates that the request has been denied by the approver.\nDenied requests are permanently closed and have no impact on vulnerability detection.\nOnly PENDING requests can transition to this state.\n - APPROVED_PENDING_UPDATE: Indicates that the original request was approved, but an update is still pending an approval or denial.\nThis state occurs when an approved request is updated.\nThe original approval remains in effect until the update is processed.",
                "default": "PENDING",
                "enum": [
                  "PENDING",
                  "APPROVED",
                  "DENIED",
                  "APPROVED_PENDING_UPDATE"
                ]
              },
              "expired": {
                "type": "boolean",
                "description": "Indicates if this request is a historical request that is no longer in effect\ndue to deferral expiry, cancellation, or restarting cve observation.\nExpired requests are retained for audit purposes."
              },
              "requestor": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "id": {
                    "nullable": true,
                    "type": "string"
                  },
                  "name": {
                    "nullable": true,
                    "type": "string"
                  }
                }
              },
              "approvers": {
                "type": "array",
                "description": "DEPRECATED: Use approvers_v2 instead.\nUsers who can approve or deny the request.",
                "items": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "id": {
                      "nullable": true,
                      "type": "string"
                    },
                    "name": {
                      "nullable": true,
                      "type": "string"
                    }
                  }
                }
              },
              "createdAt": {
                "nullable": true,
                "type": "string",
                "description": "Timestamp when the request was created.",
                "format": "date-time"
              },
              "lastUpdated": {
                "nullable": true,
                "type": "string",
                "description": "Timestamp when the request was last updated.",
                "format": "date-time"
              },
              "comments": {
                "type": "array",
                "description": "Comments on the request providing audit trail.\nMust have at least one comment for new requests.",
                "items": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "id": {
                      "nullable": true,
                      "type": "string",
                      "description": "Unique identifier for the comment."
                    },
                    "message": {
                      "nullable": true,
                      "type": "string",
                      "description": "The comment message content.\nRequired for all request actions."
                    },
                    "user": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "id": {
                          "nullable": true,
                          "type": "string"
                        },
                        "name": {
                          "nullable": true,
                          "type": "string"
                        }
                      }
                    },
                    "createdAt": {
                      "nullable": true,
                      "type": "string",
                      "description": "Timestamp when the comment was created.",
                      "format": "date-time"
                    }
                  },
                  "description": "RequestComment represents a comment on a vulnerability request.\n\n**Comment Rules:**\n- Comments are required for all request actions (create, approve, deny, update)\n- Each comment is associated with a user and timestamp\n- Comments provide audit trail for request lifecycle"
                }
              },
              "scope": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "imageScope": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "registry": {
                        "nullable": true,
                        "type": "string",
                        "description": "Container registry (e.g., \"docker.io\", \"gcr.io\").\nRequired for image scope."
                      },
                      "remote": {
                        "nullable": true,
                        "type": "string",
                        "description": "Image repository name (e.g., \"stackrox/main\").\nRequired for image scope."
                      },
                      "tag": {
                        "nullable": true,
                        "type": "string",
                        "description": "Image tag (e.g., \"latest\", \"v1.0.0\").\nRequired for image scope."
                      }
                    },
                    "description": "Image scope applies the request to specific container images."
                  },
                  "globalScope": {
                    "nullable": true,
                    "type": "object",
                    "description": "Global scope applies the request system-wide (deprecated)."
                  }
                },
                "description": "Scope defines the scope where the vulnerability request applies."
              },
              "requesterV2": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "id": {
                    "nullable": true,
                    "type": "string",
                    "description": "Unique identifier for the requester."
                  },
                  "name": {
                    "nullable": true,
                    "type": "string",
                    "description": "Display name of the requester."
                  }
                },
                "description": "Requester represents the user who created the vulnerability request.\n\n**Requester Rules:**\n- Must be specified for all new requests\n- Cannot be changed after request creation\n- Used for audit trail and permission checks"
              },
              "approversV2": {
                "type": "array",
                "description": "Users who can approve or deny the request (v2).\nMultiple approvers can be assigned.",
                "items": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "id": {
                      "nullable": true,
                      "type": "string",
                      "description": "Unique identifier for the approver."
                    },
                    "name": {
                      "nullable": true,
                      "type": "string",
                      "description": "Display name of the approver."
                    }
                  },
                  "description": "Approver represents a user who can approve or deny vulnerability requests.\n\n**Approver Rules:**\n- Multiple approvers can be assigned to a request\n- Any approver can approve or deny the request\n- Used for audit trail and permission checks"
                }
              },
              "deferralReq": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "expiry": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "expiresWhenFixed": {
                        "type": "boolean",
                        "description": "Indicates that this request expires when the associated vulnerability is fixed.\nCannot be used with expires_on.\nOnly applicable to deferral requests."
                      },
                      "expiresOn": {
                        "nullable": true,
                        "type": "string",
                        "description": "Indicates the timestamp when this request expires.\nCannot be used with expires_when_fixed.\nMust be a future timestamp.",
                        "format": "date-time"
                      },
                      "expiryType": {
                        "nullable": true,
                        "type": "string",
                        "description": "ExpiryType indicates the type of expiry for the request.\nThis field is under development, DO NOT USE FOR NON-DEVELOPMENT PURPOSES.\n\n - TIME: Request has a fixed expiry time. If used, expires_on must be set.\n - ALL_CVE_FIXABLE: Request expires if all CVEs in the request are fixable.\n - ANY_CVE_FIXABLE: Request expires if any CVE in the request is fixable.",
                        "default": "TIME",
                        "enum": [
                          "TIME",
                          "ALL_CVE_FIXABLE",
                          "ANY_CVE_FIXABLE"
                        ]
                      }
                    },
                    "description": "RequestExpiry defines the expiration configuration for deferral requests.\n\n**Expiry Rules:**\n- Deferral requests must specify expiry (either expires_when_fixed or expires_on)\n- False-positive requests do not have expiry (permanent)\n- Cannot specify both expiry options\n- Expiry type is under development (do not use for non-development purposes)"
                  }
                },
                "description": "DeferralRequest represents a request to temporarily defer vulnerability detection.\n\n**Deferral Rules:**\n- Must specify expiry configuration\n- Expiry can be time-based or fix-based\n- Deferrals are temporary and expire automatically"
              },
              "fpRequest": {
                "nullable": true,
                "type": "object",
                "description": "FalsePositiveRequest represents a request to permanently mark vulnerabilities as false-positive.\n\n**False-Positive Rules:**\n- No expiry configuration (permanent)\n- False-positives are permanently suppressed\n- Cannot be undone except through request management"
              },
              "cves": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "cves": {
                    "type": "array",
                    "description": "These are (NVD) vulnerability identifiers, `cve` field of `storage.CVE`, and *not* the `id` field.\nFor example, CVE-2021-44832.\nMust be in valid CVE format and not already covered by approved requests.",
                    "items": {
                      "nullable": true,
                      "type": "string"
                    }
                  }
                },
                "description": "CVEs represents the list of CVE identifiers in the request."
              },
              "updatedDeferralReq": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "expiry": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "expiresWhenFixed": {
                        "type": "boolean",
                        "description": "Indicates that this request expires when the associated vulnerability is fixed.\nCannot be used with expires_on.\nOnly applicable to deferral requests."
                      },
                      "expiresOn": {
                        "nullable": true,
                        "type": "string",
                        "description": "Indicates the timestamp when this request expires.\nCannot be used with expires_when_fixed.\nMust be a future timestamp.",
                        "format": "date-time"
                      },
                      "expiryType": {
                        "nullable": true,
                        "type": "string",
                        "description": "ExpiryType indicates the type of expiry for the request.\nThis field is under development, DO NOT USE FOR NON-DEVELOPMENT PURPOSES.\n\n - TIME: Request has a fixed expiry time. If used, expires_on must be set.\n - ALL_CVE_FIXABLE: Request expires if all CVEs in the request are fixable.\n - ANY_CVE_FIXABLE: Request expires if any CVE in the request is fixable.",
                        "default": "TIME",
                        "enum": [
                          "TIME",
                          "ALL_CVE_FIXABLE",
                          "ANY_CVE_FIXABLE"
                        ]
                      }
                    },
                    "description": "RequestExpiry defines the expiration configuration for deferral requests.\n\n**Expiry Rules:**\n- Deferral requests must specify expiry (either expires_when_fixed or expires_on)\n- False-positive requests do not have expiry (permanent)\n- Cannot specify both expiry options\n- Expiry type is under development (do not use for non-development purposes)"
                  }
                },
                "description": "DeferralRequest represents a request to temporarily defer vulnerability detection.\n\n**Deferral Rules:**\n- Must specify expiry configuration\n- Expiry can be time-based or fix-based\n- Deferrals are temporary and expire automatically"
              },
              "deferralUpdate": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "CVEs": {
                    "type": "array",
                    "description": "CVEs to be updated in the deferral request.\nCannot be empty (at least one CVE must remain).",
                    "items": {
                      "nullable": true,
                      "type": "string"
                    }
                  },
                  "expiry": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "expiresWhenFixed": {
                        "type": "boolean",
                        "description": "Indicates that this request expires when the associated vulnerability is fixed.\nCannot be used with expires_on.\nOnly applicable to deferral requests."
                      },
                      "expiresOn": {
                        "nullable": true,
                        "type": "string",
                        "description": "Indicates the timestamp when this request expires.\nCannot be used with expires_when_fixed.\nMust be a future timestamp.",
                        "format": "date-time"
                      },
                      "expiryType": {
                        "nullable": true,
                        "type": "string",
                        "description": "ExpiryType indicates the type of expiry for the request.\nThis field is under development, DO NOT USE FOR NON-DEVELOPMENT PURPOSES.\n\n - TIME: Request has a fixed expiry time. If used, expires_on must be set.\n - ALL_CVE_FIXABLE: Request expires if all CVEs in the request are fixable.\n - ANY_CVE_FIXABLE: Request expires if any CVE in the request is fixable.",
                        "default": "TIME",
                        "enum": [
                          "TIME",
                          "ALL_CVE_FIXABLE",
                          "ANY_CVE_FIXABLE"
                        ]
                      }
                    },
                    "description": "RequestExpiry defines the expiration configuration for deferral requests.\n\n**Expiry Rules:**\n- Deferral requests must specify expiry (either expires_when_fixed or expires_on)\n- False-positive requests do not have expiry (permanent)\n- Cannot specify both expiry options\n- Expiry type is under development (do not use for non-development purposes)"
                  }
                },
                "description": "DeferralUpdate represents an update to an existing deferral request.\n\n**Update Rules:**\n- Can add or remove CVEs from the request\n- Cannot remove all CVEs (at least one CVE must remain)\n- Can update expiry configuration\n- Creates a new pending update request"
              },
              "falsePositiveUpdate": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "CVEs": {
                    "type": "array",
                    "description": "CVEs to be updated in the false-positive request.\nCannot be empty (at least one CVE must remain).",
                    "items": {
                      "nullable": true,
                      "type": "string"
                    }
                  }
                },
                "description": "FalsePositiveUpdate represents an update to an existing false-positive request.\n\n**Update Rules:**\n- Can add or remove CVEs from the request\n- Cannot remove all CVEs (at least one CVE must remain)\n- False-positive requests remain permanent (no expiry)"
              }
            },
            "description": "VulnerabilityRequest encapsulates a request such as deferral request and false-positive request.\n\n**Request Lifecycle:**\n- Creation: New request in PENDING state\n- Approval: Request approved and enforced\n- Denial: Request denied and closed\n- Update: Approved request with pending update\n- Expiry: Request expires automatically or manually\n- Undo: Approved request undone and vulnerabilities re-enabled\n\n**Validation Rules:**\n- New requests must not have ID (auto-generated)\n- Must have at least one comment\n- Must have valid CVE format (e.g., \"CVE-2021-1234\")\n- Must have valid scope (image scope or global scope)\n- Cannot create duplicate requests for same CVE-scope combination\n- Deferral requests must specify expiry\n- False-positive requests are permanent (no expiry)\n- New requests cannot start in APPROVED or DENIED state\n\n**Performance Considerations:**\n- Maximum 1000 requests returned per list operation\n- Requests are processed sequentially to prevent race conditions\n- Duplicate prevention checks are performed during creation"
          }
        },
        "description": "GetVulnerabilityRequestResponse contains the vulnerability request details."
      },
      "v1Empty": {
        "nullable": true,
        "type": "object"
      },
      "VulnerabilityRequestServiceApproveVulnerabilityRequestBody": {
        "nullable": true,
        "type": "object",
        "properties": {
          "comment": {
            "nullable": true,
            "type": "string",
            "description": "Comment explaining the approval decision.\nRequired for approval action."
          }
        },
        "description": "ApproveVulnRequest contains parameters for approving a vulnerability request.\n\n**Approval Rules:**\n- Comment is required for approval\n- Only pending requests can be approved\n- Approval automatically denies conflicting pending requests\n- Approved requests are enforced immediately"
      },
      "v1ApproveVulnRequestResponse": {
        "nullable": true,
        "type": "object",
        "properties": {
          "requestInfo": {
            "nullable": true,
            "type": "object",
            "properties": {
              "id": {
                "nullable": true,
                "type": "string",
                "description": "Unique identifier for the vulnerability request (auto-generated).\nNew requests must not specify this field."
              },
              "name": {
                "nullable": true,
                "type": "string",
                "description": "Human-readable name for the request (auto-generated).\nMust be unique across all requests."
              },
              "targetState": {
                "nullable": true,
                "type": "string",
                "description": "VulnerabilityState indicates if vulnerability is being observed or deferred(/suppressed). By default, it vulnerabilities are observed.\n\n - OBSERVED: [Default state]",
                "default": "OBSERVED",
                "enum": [
                  "OBSERVED",
                  "DEFERRED",
                  "FALSE_POSITIVE"
                ]
              },
              "status": {
                "nullable": true,
                "type": "string",
                "description": "RequestStatus indicates the status of a vulnerability request.\n\n**Status Lifecycle:**\n- PENDING: Default state for new requests awaiting approval/denial\n- APPROVED: Request approved and enforced\n- DENIED: Request denied and permanently closed\n- APPROVED_PENDING_UPDATE: Approved request with pending update\n\n**Status Rules:**\n- New requests must start in PENDING state\n- Only PENDING requests can be approved or denied\n- APPROVED requests can be updated (creates APPROVED_PENDING_UPDATE)\n- DENIED requests are permanently closed\n- Cancelled requests are not persisted (except in audit logs)\n\n - PENDING: Default request state. It indicates that the request has not been fulfilled and that an action (approve/deny) is required.\nOnly requests in this state can be approved, denied, or updated.\n - APPROVED: Indicates that the request has been approved by the approver.\nApproved requests are immediately enforced and suppress vulnerability detection.\nOnly PENDING requests can transition to this state.\n - DENIED: Indicates that the request has been denied by the approver.\nDenied requests are permanently closed and have no impact on vulnerability detection.\nOnly PENDING requests can transition to this state.\n - APPROVED_PENDING_UPDATE: Indicates that the original request was approved, but an update is still pending an approval or denial.\nThis state occurs when an approved request is updated.\nThe original approval remains in effect until the update is processed.",
                "default": "PENDING",
                "enum": [
                  "PENDING",
                  "APPROVED",
                  "DENIED",
                  "APPROVED_PENDING_UPDATE"
                ]
              },
              "expired": {
                "type": "boolean",
                "description": "Indicates if this request is a historical request that is no longer in effect\ndue to deferral expiry, cancellation, or restarting cve observation.\nExpired requests are retained for audit purposes."
              },
              "requestor": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "id": {
                    "nullable": true,
                    "type": "string"
                  },
                  "name": {
                    "nullable": true,
                    "type": "string"
                  }
                }
              },
              "approvers": {
                "type": "array",
                "description": "DEPRECATED: Use approvers_v2 instead.\nUsers who can approve or deny the request.",
                "items": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "id": {
                      "nullable": true,
                      "type": "string"
                    },
                    "name": {
                      "nullable": true,
                      "type": "string"
                    }
                  }
                }
              },
              "createdAt": {
                "nullable": true,
                "type": "string",
                "description": "Timestamp when the request was created.",
                "format": "date-time"
              },
              "lastUpdated": {
                "nullable": true,
                "type": "string",
                "description": "Timestamp when the request was last updated.",
                "format": "date-time"
              },
              "comments": {
                "type": "array",
                "description": "Comments on the request providing audit trail.\nMust have at least one comment for new requests.",
                "items": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "id": {
                      "nullable": true,
                      "type": "string",
                      "description": "Unique identifier for the comment."
                    },
                    "message": {
                      "nullable": true,
                      "type": "string",
                      "description": "The comment message content.\nRequired for all request actions."
                    },
                    "user": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "id": {
                          "nullable": true,
                          "type": "string"
                        },
                        "name": {
                          "nullable": true,
                          "type": "string"
                        }
                      }
                    },
                    "createdAt": {
                      "nullable": true,
                      "type": "string",
                      "description": "Timestamp when the comment was created.",
                      "format": "date-time"
                    }
                  },
                  "description": "RequestComment represents a comment on a vulnerability request.\n\n**Comment Rules:**\n- Comments are required for all request actions (create, approve, deny, update)\n- Each comment is associated with a user and timestamp\n- Comments provide audit trail for request lifecycle"
                }
              },
              "scope": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "imageScope": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "registry": {
                        "nullable": true,
                        "type": "string",
                        "description": "Container registry (e.g., \"docker.io\", \"gcr.io\").\nRequired for image scope."
                      },
                      "remote": {
                        "nullable": true,
                        "type": "string",
                        "description": "Image repository name (e.g., \"stackrox/main\").\nRequired for image scope."
                      },
                      "tag": {
                        "nullable": true,
                        "type": "string",
                        "description": "Image tag (e.g., \"latest\", \"v1.0.0\").\nRequired for image scope."
                      }
                    },
                    "description": "Image scope applies the request to specific container images."
                  },
                  "globalScope": {
                    "nullable": true,
                    "type": "object",
                    "description": "Global scope applies the request system-wide (deprecated)."
                  }
                },
                "description": "Scope defines the scope where the vulnerability request applies."
              },
              "requesterV2": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "id": {
                    "nullable": true,
                    "type": "string",
                    "description": "Unique identifier for the requester."
                  },
                  "name": {
                    "nullable": true,
                    "type": "string",
                    "description": "Display name of the requester."
                  }
                },
                "description": "Requester represents the user who created the vulnerability request.\n\n**Requester Rules:**\n- Must be specified for all new requests\n- Cannot be changed after request creation\n- Used for audit trail and permission checks"
              },
              "approversV2": {
                "type": "array",
                "description": "Users who can approve or deny the request (v2).\nMultiple approvers can be assigned.",
                "items": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "id": {
                      "nullable": true,
                      "type": "string",
                      "description": "Unique identifier for the approver."
                    },
                    "name": {
                      "nullable": true,
                      "type": "string",
                      "description": "Display name of the approver."
                    }
                  },
                  "description": "Approver represents a user who can approve or deny vulnerability requests.\n\n**Approver Rules:**\n- Multiple approvers can be assigned to a request\n- Any approver can approve or deny the request\n- Used for audit trail and permission checks"
                }
              },
              "deferralReq": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "expiry": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "expiresWhenFixed": {
                        "type": "boolean",
                        "description": "Indicates that this request expires when the associated vulnerability is fixed.\nCannot be used with expires_on.\nOnly applicable to deferral requests."
                      },
                      "expiresOn": {
                        "nullable": true,
                        "type": "string",
                        "description": "Indicates the timestamp when this request expires.\nCannot be used with expires_when_fixed.\nMust be a future timestamp.",
                        "format": "date-time"
                      },
                      "expiryType": {
                        "nullable": true,
                        "type": "string",
                        "description": "ExpiryType indicates the type of expiry for the request.\nThis field is under development, DO NOT USE FOR NON-DEVELOPMENT PURPOSES.\n\n - TIME: Request has a fixed expiry time. If used, expires_on must be set.\n - ALL_CVE_FIXABLE: Request expires if all CVEs in the request are fixable.\n - ANY_CVE_FIXABLE: Request expires if any CVE in the request is fixable.",
                        "default": "TIME",
                        "enum": [
                          "TIME",
                          "ALL_CVE_FIXABLE",
                          "ANY_CVE_FIXABLE"
                        ]
                      }
                    },
                    "description": "RequestExpiry defines the expiration configuration for deferral requests.\n\n**Expiry Rules:**\n- Deferral requests must specify expiry (either expires_when_fixed or expires_on)\n- False-positive requests do not have expiry (permanent)\n- Cannot specify both expiry options\n- Expiry type is under development (do not use for non-development purposes)"
                  }
                },
                "description": "DeferralRequest represents a request to temporarily defer vulnerability detection.\n\n**Deferral Rules:**\n- Must specify expiry configuration\n- Expiry can be time-based or fix-based\n- Deferrals are temporary and expire automatically"
              },
              "fpRequest": {
                "nullable": true,
                "type": "object",
                "description": "FalsePositiveRequest represents a request to permanently mark vulnerabilities as false-positive.\n\n**False-Positive Rules:**\n- No expiry configuration (permanent)\n- False-positives are permanently suppressed\n- Cannot be undone except through request management"
              },
              "cves": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "cves": {
                    "type": "array",
                    "description": "These are (NVD) vulnerability identifiers, `cve` field of `storage.CVE`, and *not* the `id` field.\nFor example, CVE-2021-44832.\nMust be in valid CVE format and not already covered by approved requests.",
                    "items": {
                      "nullable": true,
                      "type": "string"
                    }
                  }
                },
                "description": "CVEs represents the list of CVE identifiers in the request."
              },
              "updatedDeferralReq": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "expiry": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "expiresWhenFixed": {
                        "type": "boolean",
                        "description": "Indicates that this request expires when the associated vulnerability is fixed.\nCannot be used with expires_on.\nOnly applicable to deferral requests."
                      },
                      "expiresOn": {
                        "nullable": true,
                        "type": "string",
                        "description": "Indicates the timestamp when this request expires.\nCannot be used with expires_when_fixed.\nMust be a future timestamp.",
                        "format": "date-time"
                      },
                      "expiryType": {
                        "nullable": true,
                        "type": "string",
                        "description": "ExpiryType indicates the type of expiry for the request.\nThis field is under development, DO NOT USE FOR NON-DEVELOPMENT PURPOSES.\n\n - TIME: Request has a fixed expiry time. If used, expires_on must be set.\n - ALL_CVE_FIXABLE: Request expires if all CVEs in the request are fixable.\n - ANY_CVE_FIXABLE: Request expires if any CVE in the request is fixable.",
                        "default": "TIME",
                        "enum": [
                          "TIME",
                          "ALL_CVE_FIXABLE",
                          "ANY_CVE_FIXABLE"
                        ]
                      }
                    },
                    "description": "RequestExpiry defines the expiration configuration for deferral requests.\n\n**Expiry Rules:**\n- Deferral requests must specify expiry (either expires_when_fixed or expires_on)\n- False-positive requests do not have expiry (permanent)\n- Cannot specify both expiry options\n- Expiry type is under development (do not use for non-development purposes)"
                  }
                },
                "description": "DeferralRequest represents a request to temporarily defer vulnerability detection.\n\n**Deferral Rules:**\n- Must specify expiry configuration\n- Expiry can be time-based or fix-based\n- Deferrals are temporary and expire automatically"
              },
              "deferralUpdate": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "CVEs": {
                    "type": "array",
                    "description": "CVEs to be updated in the deferral request.\nCannot be empty (at least one CVE must remain).",
                    "items": {
                      "nullable": true,
                      "type": "string"
                    }
                  },
                  "expiry": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "expiresWhenFixed": {
                        "type": "boolean",
                        "description": "Indicates that this request expires when the associated vulnerability is fixed.\nCannot be used with expires_on.\nOnly applicable to deferral requests."
                      },
                      "expiresOn": {
                        "nullable": true,
                        "type": "string",
                        "description": "Indicates the timestamp when this request expires.\nCannot be used with expires_when_fixed.\nMust be a future timestamp.",
                        "format": "date-time"
                      },
                      "expiryType": {
                        "nullable": true,
                        "type": "string",
                        "description": "ExpiryType indicates the type of expiry for the request.\nThis field is under development, DO NOT USE FOR NON-DEVELOPMENT PURPOSES.\n\n - TIME: Request has a fixed expiry time. If used, expires_on must be set.\n - ALL_CVE_FIXABLE: Request expires if all CVEs in the request are fixable.\n - ANY_CVE_FIXABLE: Request expires if any CVE in the request is fixable.",
                        "default": "TIME",
                        "enum": [
                          "TIME",
                          "ALL_CVE_FIXABLE",
                          "ANY_CVE_FIXABLE"
                        ]
                      }
                    },
                    "description": "RequestExpiry defines the expiration configuration for deferral requests.\n\n**Expiry Rules:**\n- Deferral requests must specify expiry (either expires_when_fixed or expires_on)\n- False-positive requests do not have expiry (permanent)\n- Cannot specify both expiry options\n- Expiry type is under development (do not use for non-development purposes)"
                  }
                },
                "description": "DeferralUpdate represents an update to an existing deferral request.\n\n**Update Rules:**\n- Can add or remove CVEs from the request\n- Cannot remove all CVEs (at least one CVE must remain)\n- Can update expiry configuration\n- Creates a new pending update request"
              },
              "falsePositiveUpdate": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "CVEs": {
                    "type": "array",
                    "description": "CVEs to be updated in the false-positive request.\nCannot be empty (at least one CVE must remain).",
                    "items": {
                      "nullable": true,
                      "type": "string"
                    }
                  }
                },
                "description": "FalsePositiveUpdate represents an update to an existing false-positive request.\n\n**Update Rules:**\n- Can add or remove CVEs from the request\n- Cannot remove all CVEs (at least one CVE must remain)\n- False-positive requests remain permanent (no expiry)"
              }
            },
            "description": "VulnerabilityRequest encapsulates a request such as deferral request and false-positive request.\n\n**Request Lifecycle:**\n- Creation: New request in PENDING state\n- Approval: Request approved and enforced\n- Denial: Request denied and closed\n- Update: Approved request with pending update\n- Expiry: Request expires automatically or manually\n- Undo: Approved request undone and vulnerabilities re-enabled\n\n**Validation Rules:**\n- New requests must not have ID (auto-generated)\n- Must have at least one comment\n- Must have valid CVE format (e.g., \"CVE-2021-1234\")\n- Must have valid scope (image scope or global scope)\n- Cannot create duplicate requests for same CVE-scope combination\n- Deferral requests must specify expiry\n- False-positive requests are permanent (no expiry)\n- New requests cannot start in APPROVED or DENIED state\n\n**Performance Considerations:**\n- Maximum 1000 requests returned per list operation\n- Requests are processed sequentially to prevent race conditions\n- Duplicate prevention checks are performed during creation"
          }
        },
        "description": "ApproveVulnRequestResponse contains the approved request information."
      },
      "VulnerabilityRequestServiceDenyVulnerabilityRequestBody": {
        "nullable": true,
        "type": "object",
        "properties": {
          "comment": {
            "nullable": true,
            "type": "string",
            "description": "Comment explaining the denial decision.\nRequired for denial action."
          }
        },
        "description": "DenyVulnRequest contains parameters for denying a vulnerability request.\n\n**Denial Rules:**\n- Comment is required for denial\n- Only pending requests can be denied\n- Denied requests are permanently closed"
      },
      "v1DenyVulnRequestResponse": {
        "nullable": true,
        "type": "object",
        "properties": {
          "requestInfo": {
            "nullable": true,
            "type": "object",
            "properties": {
              "id": {
                "nullable": true,
                "type": "string",
                "description": "Unique identifier for the vulnerability request (auto-generated).\nNew requests must not specify this field."
              },
              "name": {
                "nullable": true,
                "type": "string",
                "description": "Human-readable name for the request (auto-generated).\nMust be unique across all requests."
              },
              "targetState": {
                "nullable": true,
                "type": "string",
                "description": "VulnerabilityState indicates if vulnerability is being observed or deferred(/suppressed). By default, it vulnerabilities are observed.\n\n - OBSERVED: [Default state]",
                "default": "OBSERVED",
                "enum": [
                  "OBSERVED",
                  "DEFERRED",
                  "FALSE_POSITIVE"
                ]
              },
              "status": {
                "nullable": true,
                "type": "string",
                "description": "RequestStatus indicates the status of a vulnerability request.\n\n**Status Lifecycle:**\n- PENDING: Default state for new requests awaiting approval/denial\n- APPROVED: Request approved and enforced\n- DENIED: Request denied and permanently closed\n- APPROVED_PENDING_UPDATE: Approved request with pending update\n\n**Status Rules:**\n- New requests must start in PENDING state\n- Only PENDING requests can be approved or denied\n- APPROVED requests can be updated (creates APPROVED_PENDING_UPDATE)\n- DENIED requests are permanently closed\n- Cancelled requests are not persisted (except in audit logs)\n\n - PENDING: Default request state. It indicates that the request has not been fulfilled and that an action (approve/deny) is required.\nOnly requests in this state can be approved, denied, or updated.\n - APPROVED: Indicates that the request has been approved by the approver.\nApproved requests are immediately enforced and suppress vulnerability detection.\nOnly PENDING requests can transition to this state.\n - DENIED: Indicates that the request has been denied by the approver.\nDenied requests are permanently closed and have no impact on vulnerability detection.\nOnly PENDING requests can transition to this state.\n - APPROVED_PENDING_UPDATE: Indicates that the original request was approved, but an update is still pending an approval or denial.\nThis state occurs when an approved request is updated.\nThe original approval remains in effect until the update is processed.",
                "default": "PENDING",
                "enum": [
                  "PENDING",
                  "APPROVED",
                  "DENIED",
                  "APPROVED_PENDING_UPDATE"
                ]
              },
              "expired": {
                "type": "boolean",
                "description": "Indicates if this request is a historical request that is no longer in effect\ndue to deferral expiry, cancellation, or restarting cve observation.\nExpired requests are retained for audit purposes."
              },
              "requestor": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "id": {
                    "nullable": true,
                    "type": "string"
                  },
                  "name": {
                    "nullable": true,
                    "type": "string"
                  }
                }
              },
              "approvers": {
                "type": "array",
                "description": "DEPRECATED: Use approvers_v2 instead.\nUsers who can approve or deny the request.",
                "items": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "id": {
                      "nullable": true,
                      "type": "string"
                    },
                    "name": {
                      "nullable": true,
                      "type": "string"
                    }
                  }
                }
              },
              "createdAt": {
                "nullable": true,
                "type": "string",
                "description": "Timestamp when the request was created.",
                "format": "date-time"
              },
              "lastUpdated": {
                "nullable": true,
                "type": "string",
                "description": "Timestamp when the request was last updated.",
                "format": "date-time"
              },
              "comments": {
                "type": "array",
                "description": "Comments on the request providing audit trail.\nMust have at least one comment for new requests.",
                "items": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "id": {
                      "nullable": true,
                      "type": "string",
                      "description": "Unique identifier for the comment."
                    },
                    "message": {
                      "nullable": true,
                      "type": "string",
                      "description": "The comment message content.\nRequired for all request actions."
                    },
                    "user": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "id": {
                          "nullable": true,
                          "type": "string"
                        },
                        "name": {
                          "nullable": true,
                          "type": "string"
                        }
                      }
                    },
                    "createdAt": {
                      "nullable": true,
                      "type": "string",
                      "description": "Timestamp when the comment was created.",
                      "format": "date-time"
                    }
                  },
                  "description": "RequestComment represents a comment on a vulnerability request.\n\n**Comment Rules:**\n- Comments are required for all request actions (create, approve, deny, update)\n- Each comment is associated with a user and timestamp\n- Comments provide audit trail for request lifecycle"
                }
              },
              "scope": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "imageScope": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "registry": {
                        "nullable": true,
                        "type": "string",
                        "description": "Container registry (e.g., \"docker.io\", \"gcr.io\").\nRequired for image scope."
                      },
                      "remote": {
                        "nullable": true,
                        "type": "string",
                        "description": "Image repository name (e.g., \"stackrox/main\").\nRequired for image scope."
                      },
                      "tag": {
                        "nullable": true,
                        "type": "string",
                        "description": "Image tag (e.g., \"latest\", \"v1.0.0\").\nRequired for image scope."
                      }
                    },
                    "description": "Image scope applies the request to specific container images."
                  },
                  "globalScope": {
                    "nullable": true,
                    "type": "object",
                    "description": "Global scope applies the request system-wide (deprecated)."
                  }
                },
                "description": "Scope defines the scope where the vulnerability request applies."
              },
              "requesterV2": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "id": {
                    "nullable": true,
                    "type": "string",
                    "description": "Unique identifier for the requester."
                  },
                  "name": {
                    "nullable": true,
                    "type": "string",
                    "description": "Display name of the requester."
                  }
                },
                "description": "Requester represents the user who created the vulnerability request.\n\n**Requester Rules:**\n- Must be specified for all new requests\n- Cannot be changed after request creation\n- Used for audit trail and permission checks"
              },
              "approversV2": {
                "type": "array",
                "description": "Users who can approve or deny the request (v2).\nMultiple approvers can be assigned.",
                "items": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "id": {
                      "nullable": true,
                      "type": "string",
                      "description": "Unique identifier for the approver."
                    },
                    "name": {
                      "nullable": true,
                      "type": "string",
                      "description": "Display name of the approver."
                    }
                  },
                  "description": "Approver represents a user who can approve or deny vulnerability requests.\n\n**Approver Rules:**\n- Multiple approvers can be assigned to a request\n- Any approver can approve or deny the request\n- Used for audit trail and permission checks"
                }
              },
              "deferralReq": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "expiry": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "expiresWhenFixed": {
                        "type": "boolean",
                        "description": "Indicates that this request expires when the associated vulnerability is fixed.\nCannot be used with expires_on.\nOnly applicable to deferral requests."
                      },
                      "expiresOn": {
                        "nullable": true,
                        "type": "string",
                        "description": "Indicates the timestamp when this request expires.\nCannot be used with expires_when_fixed.\nMust be a future timestamp.",
                        "format": "date-time"
                      },
                      "expiryType": {
                        "nullable": true,
                        "type": "string",
                        "description": "ExpiryType indicates the type of expiry for the request.\nThis field is under development, DO NOT USE FOR NON-DEVELOPMENT PURPOSES.\n\n - TIME: Request has a fixed expiry time. If used, expires_on must be set.\n - ALL_CVE_FIXABLE: Request expires if all CVEs in the request are fixable.\n - ANY_CVE_FIXABLE: Request expires if any CVE in the request is fixable.",
                        "default": "TIME",
                        "enum": [
                          "TIME",
                          "ALL_CVE_FIXABLE",
                          "ANY_CVE_FIXABLE"
                        ]
                      }
                    },
                    "description": "RequestExpiry defines the expiration configuration for deferral requests.\n\n**Expiry Rules:**\n- Deferral requests must specify expiry (either expires_when_fixed or expires_on)\n- False-positive requests do not have expiry (permanent)\n- Cannot specify both expiry options\n- Expiry type is under development (do not use for non-development purposes)"
                  }
                },
                "description": "DeferralRequest represents a request to temporarily defer vulnerability detection.\n\n**Deferral Rules:**\n- Must specify expiry configuration\n- Expiry can be time-based or fix-based\n- Deferrals are temporary and expire automatically"
              },
              "fpRequest": {
                "nullable": true,
                "type": "object",
                "description": "FalsePositiveRequest represents a request to permanently mark vulnerabilities as false-positive.\n\n**False-Positive Rules:**\n- No expiry configuration (permanent)\n- False-positives are permanently suppressed\n- Cannot be undone except through request management"
              },
              "cves": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "cves": {
                    "type": "array",
                    "description": "These are (NVD) vulnerability identifiers, `cve` field of `storage.CVE`, and *not* the `id` field.\nFor example, CVE-2021-44832.\nMust be in valid CVE format and not already covered by approved requests.",
                    "items": {
                      "nullable": true,
                      "type": "string"
                    }
                  }
                },
                "description": "CVEs represents the list of CVE identifiers in the request."
              },
              "updatedDeferralReq": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "expiry": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "expiresWhenFixed": {
                        "type": "boolean",
                        "description": "Indicates that this request expires when the associated vulnerability is fixed.\nCannot be used with expires_on.\nOnly applicable to deferral requests."
                      },
                      "expiresOn": {
                        "nullable": true,
                        "type": "string",
                        "description": "Indicates the timestamp when this request expires.\nCannot be used with expires_when_fixed.\nMust be a future timestamp.",
                        "format": "date-time"
                      },
                      "expiryType": {
                        "nullable": true,
                        "type": "string",
                        "description": "ExpiryType indicates the type of expiry for the request.\nThis field is under development, DO NOT USE FOR NON-DEVELOPMENT PURPOSES.\n\n - TIME: Request has a fixed expiry time. If used, expires_on must be set.\n - ALL_CVE_FIXABLE: Request expires if all CVEs in the request are fixable.\n - ANY_CVE_FIXABLE: Request expires if any CVE in the request is fixable.",
                        "default": "TIME",
                        "enum": [
                          "TIME",
                          "ALL_CVE_FIXABLE",
                          "ANY_CVE_FIXABLE"
                        ]
                      }
                    },
                    "description": "RequestExpiry defines the expiration configuration for deferral requests.\n\n**Expiry Rules:**\n- Deferral requests must specify expiry (either expires_when_fixed or expires_on)\n- False-positive requests do not have expiry (permanent)\n- Cannot specify both expiry options\n- Expiry type is under development (do not use for non-development purposes)"
                  }
                },
                "description": "DeferralRequest represents a request to temporarily defer vulnerability detection.\n\n**Deferral Rules:**\n- Must specify expiry configuration\n- Expiry can be time-based or fix-based\n- Deferrals are temporary and expire automatically"
              },
              "deferralUpdate": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "CVEs": {
                    "type": "array",
                    "description": "CVEs to be updated in the deferral request.\nCannot be empty (at least one CVE must remain).",
                    "items": {
                      "nullable": true,
                      "type": "string"
                    }
                  },
                  "expiry": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "expiresWhenFixed": {
                        "type": "boolean",
                        "description": "Indicates that this request expires when the associated vulnerability is fixed.\nCannot be used with expires_on.\nOnly applicable to deferral requests."
                      },
                      "expiresOn": {
                        "nullable": true,
                        "type": "string",
                        "description": "Indicates the timestamp when this request expires.\nCannot be used with expires_when_fixed.\nMust be a future timestamp.",
                        "format": "date-time"
                      },
                      "expiryType": {
                        "nullable": true,
                        "type": "string",
                        "description": "ExpiryType indicates the type of expiry for the request.\nThis field is under development, DO NOT USE FOR NON-DEVELOPMENT PURPOSES.\n\n - TIME: Request has a fixed expiry time. If used, expires_on must be set.\n - ALL_CVE_FIXABLE: Request expires if all CVEs in the request are fixable.\n - ANY_CVE_FIXABLE: Request expires if any CVE in the request is fixable.",
                        "default": "TIME",
                        "enum": [
                          "TIME",
                          "ALL_CVE_FIXABLE",
                          "ANY_CVE_FIXABLE"
                        ]
                      }
                    },
                    "description": "RequestExpiry defines the expiration configuration for deferral requests.\n\n**Expiry Rules:**\n- Deferral requests must specify expiry (either expires_when_fixed or expires_on)\n- False-positive requests do not have expiry (permanent)\n- Cannot specify both expiry options\n- Expiry type is under development (do not use for non-development purposes)"
                  }
                },
                "description": "DeferralUpdate represents an update to an existing deferral request.\n\n**Update Rules:**\n- Can add or remove CVEs from the request\n- Cannot remove all CVEs (at least one CVE must remain)\n- Can update expiry configuration\n- Creates a new pending update request"
              },
              "falsePositiveUpdate": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "CVEs": {
                    "type": "array",
                    "description": "CVEs to be updated in the false-positive request.\nCannot be empty (at least one CVE must remain).",
                    "items": {
                      "nullable": true,
                      "type": "string"
                    }
                  }
                },
                "description": "FalsePositiveUpdate represents an update to an existing false-positive request.\n\n**Update Rules:**\n- Can add or remove CVEs from the request\n- Cannot remove all CVEs (at least one CVE must remain)\n- False-positive requests remain permanent (no expiry)"
              }
            },
            "description": "VulnerabilityRequest encapsulates a request such as deferral request and false-positive request.\n\n**Request Lifecycle:**\n- Creation: New request in PENDING state\n- Approval: Request approved and enforced\n- Denial: Request denied and closed\n- Update: Approved request with pending update\n- Expiry: Request expires automatically or manually\n- Undo: Approved request undone and vulnerabilities re-enabled\n\n**Validation Rules:**\n- New requests must not have ID (auto-generated)\n- Must have at least one comment\n- Must have valid CVE format (e.g., \"CVE-2021-1234\")\n- Must have valid scope (image scope or global scope)\n- Cannot create duplicate requests for same CVE-scope combination\n- Deferral requests must specify expiry\n- False-positive requests are permanent (no expiry)\n- New requests cannot start in APPROVED or DENIED state\n\n**Performance Considerations:**\n- Maximum 1000 requests returned per list operation\n- Requests are processed sequentially to prevent race conditions\n- Duplicate prevention checks are performed during creation"
          }
        },
        "description": "DenyVulnRequestResponse contains the denied request information."
      },
      "v1UndoVulnRequestResponse": {
        "nullable": true,
        "type": "object",
        "properties": {
          "requestInfo": {
            "nullable": true,
            "type": "object",
            "properties": {
              "id": {
                "nullable": true,
                "type": "string",
                "description": "Unique identifier for the vulnerability request (auto-generated).\nNew requests must not specify this field."
              },
              "name": {
                "nullable": true,
                "type": "string",
                "description": "Human-readable name for the request (auto-generated).\nMust be unique across all requests."
              },
              "targetState": {
                "nullable": true,
                "type": "string",
                "description": "VulnerabilityState indicates if vulnerability is being observed or deferred(/suppressed). By default, it vulnerabilities are observed.\n\n - OBSERVED: [Default state]",
                "default": "OBSERVED",
                "enum": [
                  "OBSERVED",
                  "DEFERRED",
                  "FALSE_POSITIVE"
                ]
              },
              "status": {
                "nullable": true,
                "type": "string",
                "description": "RequestStatus indicates the status of a vulnerability request.\n\n**Status Lifecycle:**\n- PENDING: Default state for new requests awaiting approval/denial\n- APPROVED: Request approved and enforced\n- DENIED: Request denied and permanently closed\n- APPROVED_PENDING_UPDATE: Approved request with pending update\n\n**Status Rules:**\n- New requests must start in PENDING state\n- Only PENDING requests can be approved or denied\n- APPROVED requests can be updated (creates APPROVED_PENDING_UPDATE)\n- DENIED requests are permanently closed\n- Cancelled requests are not persisted (except in audit logs)\n\n - PENDING: Default request state. It indicates that the request has not been fulfilled and that an action (approve/deny) is required.\nOnly requests in this state can be approved, denied, or updated.\n - APPROVED: Indicates that the request has been approved by the approver.\nApproved requests are immediately enforced and suppress vulnerability detection.\nOnly PENDING requests can transition to this state.\n - DENIED: Indicates that the request has been denied by the approver.\nDenied requests are permanently closed and have no impact on vulnerability detection.\nOnly PENDING requests can transition to this state.\n - APPROVED_PENDING_UPDATE: Indicates that the original request was approved, but an update is still pending an approval or denial.\nThis state occurs when an approved request is updated.\nThe original approval remains in effect until the update is processed.",
                "default": "PENDING",
                "enum": [
                  "PENDING",
                  "APPROVED",
                  "DENIED",
                  "APPROVED_PENDING_UPDATE"
                ]
              },
              "expired": {
                "type": "boolean",
                "description": "Indicates if this request is a historical request that is no longer in effect\ndue to deferral expiry, cancellation, or restarting cve observation.\nExpired requests are retained for audit purposes."
              },
              "requestor": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "id": {
                    "nullable": true,
                    "type": "string"
                  },
                  "name": {
                    "nullable": true,
                    "type": "string"
                  }
                }
              },
              "approvers": {
                "type": "array",
                "description": "DEPRECATED: Use approvers_v2 instead.\nUsers who can approve or deny the request.",
                "items": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "id": {
                      "nullable": true,
                      "type": "string"
                    },
                    "name": {
                      "nullable": true,
                      "type": "string"
                    }
                  }
                }
              },
              "createdAt": {
                "nullable": true,
                "type": "string",
                "description": "Timestamp when the request was created.",
                "format": "date-time"
              },
              "lastUpdated": {
                "nullable": true,
                "type": "string",
                "description": "Timestamp when the request was last updated.",
                "format": "date-time"
              },
              "comments": {
                "type": "array",
                "description": "Comments on the request providing audit trail.\nMust have at least one comment for new requests.",
                "items": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "id": {
                      "nullable": true,
                      "type": "string",
                      "description": "Unique identifier for the comment."
                    },
                    "message": {
                      "nullable": true,
                      "type": "string",
                      "description": "The comment message content.\nRequired for all request actions."
                    },
                    "user": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "id": {
                          "nullable": true,
                          "type": "string"
                        },
                        "name": {
                          "nullable": true,
                          "type": "string"
                        }
                      }
                    },
                    "createdAt": {
                      "nullable": true,
                      "type": "string",
                      "description": "Timestamp when the comment was created.",
                      "format": "date-time"
                    }
                  },
                  "description": "RequestComment represents a comment on a vulnerability request.\n\n**Comment Rules:**\n- Comments are required for all request actions (create, approve, deny, update)\n- Each comment is associated with a user and timestamp\n- Comments provide audit trail for request lifecycle"
                }
              },
              "scope": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "imageScope": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "registry": {
                        "nullable": true,
                        "type": "string",
                        "description": "Container registry (e.g., \"docker.io\", \"gcr.io\").\nRequired for image scope."
                      },
                      "remote": {
                        "nullable": true,
                        "type": "string",
                        "description": "Image repository name (e.g., \"stackrox/main\").\nRequired for image scope."
                      },
                      "tag": {
                        "nullable": true,
                        "type": "string",
                        "description": "Image tag (e.g., \"latest\", \"v1.0.0\").\nRequired for image scope."
                      }
                    },
                    "description": "Image scope applies the request to specific container images."
                  },
                  "globalScope": {
                    "nullable": true,
                    "type": "object",
                    "description": "Global scope applies the request system-wide (deprecated)."
                  }
                },
                "description": "Scope defines the scope where the vulnerability request applies."
              },
              "requesterV2": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "id": {
                    "nullable": true,
                    "type": "string",
                    "description": "Unique identifier for the requester."
                  },
                  "name": {
                    "nullable": true,
                    "type": "string",
                    "description": "Display name of the requester."
                  }
                },
                "description": "Requester represents the user who created the vulnerability request.\n\n**Requester Rules:**\n- Must be specified for all new requests\n- Cannot be changed after request creation\n- Used for audit trail and permission checks"
              },
              "approversV2": {
                "type": "array",
                "description": "Users who can approve or deny the request (v2).\nMultiple approvers can be assigned.",
                "items": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "id": {
                      "nullable": true,
                      "type": "string",
                      "description": "Unique identifier for the approver."
                    },
                    "name": {
                      "nullable": true,
                      "type": "string",
                      "description": "Display name of the approver."
                    }
                  },
                  "description": "Approver represents a user who can approve or deny vulnerability requests.\n\n**Approver Rules:**\n- Multiple approvers can be assigned to a request\n- Any approver can approve or deny the request\n- Used for audit trail and permission checks"
                }
              },
              "deferralReq": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "expiry": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "expiresWhenFixed": {
                        "type": "boolean",
                        "description": "Indicates that this request expires when the associated vulnerability is fixed.\nCannot be used with expires_on.\nOnly applicable to deferral requests."
                      },
                      "expiresOn": {
                        "nullable": true,
                        "type": "string",
                        "description": "Indicates the timestamp when this request expires.\nCannot be used with expires_when_fixed.\nMust be a future timestamp.",
                        "format": "date-time"
                      },
                      "expiryType": {
                        "nullable": true,
                        "type": "string",
                        "description": "ExpiryType indicates the type of expiry for the request.\nThis field is under development, DO NOT USE FOR NON-DEVELOPMENT PURPOSES.\n\n - TIME: Request has a fixed expiry time. If used, expires_on must be set.\n - ALL_CVE_FIXABLE: Request expires if all CVEs in the request are fixable.\n - ANY_CVE_FIXABLE: Request expires if any CVE in the request is fixable.",
                        "default": "TIME",
                        "enum": [
                          "TIME",
                          "ALL_CVE_FIXABLE",
                          "ANY_CVE_FIXABLE"
                        ]
                      }
                    },
                    "description": "RequestExpiry defines the expiration configuration for deferral requests.\n\n**Expiry Rules:**\n- Deferral requests must specify expiry (either expires_when_fixed or expires_on)\n- False-positive requests do not have expiry (permanent)\n- Cannot specify both expiry options\n- Expiry type is under development (do not use for non-development purposes)"
                  }
                },
                "description": "DeferralRequest represents a request to temporarily defer vulnerability detection.\n\n**Deferral Rules:**\n- Must specify expiry configuration\n- Expiry can be time-based or fix-based\n- Deferrals are temporary and expire automatically"
              },
              "fpRequest": {
                "nullable": true,
                "type": "object",
                "description": "FalsePositiveRequest represents a request to permanently mark vulnerabilities as false-positive.\n\n**False-Positive Rules:**\n- No expiry configuration (permanent)\n- False-positives are permanently suppressed\n- Cannot be undone except through request management"
              },
              "cves": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "cves": {
                    "type": "array",
                    "description": "These are (NVD) vulnerability identifiers, `cve` field of `storage.CVE`, and *not* the `id` field.\nFor example, CVE-2021-44832.\nMust be in valid CVE format and not already covered by approved requests.",
                    "items": {
                      "nullable": true,
                      "type": "string"
                    }
                  }
                },
                "description": "CVEs represents the list of CVE identifiers in the request."
              },
              "updatedDeferralReq": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "expiry": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "expiresWhenFixed": {
                        "type": "boolean",
                        "description": "Indicates that this request expires when the associated vulnerability is fixed.\nCannot be used with expires_on.\nOnly applicable to deferral requests."
                      },
                      "expiresOn": {
                        "nullable": true,
                        "type": "string",
                        "description": "Indicates the timestamp when this request expires.\nCannot be used with expires_when_fixed.\nMust be a future timestamp.",
                        "format": "date-time"
                      },
                      "expiryType": {
                        "nullable": true,
                        "type": "string",
                        "description": "ExpiryType indicates the type of expiry for the request.\nThis field is under development, DO NOT USE FOR NON-DEVELOPMENT PURPOSES.\n\n - TIME: Request has a fixed expiry time. If used, expires_on must be set.\n - ALL_CVE_FIXABLE: Request expires if all CVEs in the request are fixable.\n - ANY_CVE_FIXABLE: Request expires if any CVE in the request is fixable.",
                        "default": "TIME",
                        "enum": [
                          "TIME",
                          "ALL_CVE_FIXABLE",
                          "ANY_CVE_FIXABLE"
                        ]
                      }
                    },
                    "description": "RequestExpiry defines the expiration configuration for deferral requests.\n\n**Expiry Rules:**\n- Deferral requests must specify expiry (either expires_when_fixed or expires_on)\n- False-positive requests do not have expiry (permanent)\n- Cannot specify both expiry options\n- Expiry type is under development (do not use for non-development purposes)"
                  }
                },
                "description": "DeferralRequest represents a request to temporarily defer vulnerability detection.\n\n**Deferral Rules:**\n- Must specify expiry configuration\n- Expiry can be time-based or fix-based\n- Deferrals are temporary and expire automatically"
              },
              "deferralUpdate": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "CVEs": {
                    "type": "array",
                    "description": "CVEs to be updated in the deferral request.\nCannot be empty (at least one CVE must remain).",
                    "items": {
                      "nullable": true,
                      "type": "string"
                    }
                  },
                  "expiry": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "expiresWhenFixed": {
                        "type": "boolean",
                        "description": "Indicates that this request expires when the associated vulnerability is fixed.\nCannot be used with expires_on.\nOnly applicable to deferral requests."
                      },
                      "expiresOn": {
                        "nullable": true,
                        "type": "string",
                        "description": "Indicates the timestamp when this request expires.\nCannot be used with expires_when_fixed.\nMust be a future timestamp.",
                        "format": "date-time"
                      },
                      "expiryType": {
                        "nullable": true,
                        "type": "string",
                        "description": "ExpiryType indicates the type of expiry for the request.\nThis field is under development, DO NOT USE FOR NON-DEVELOPMENT PURPOSES.\n\n - TIME: Request has a fixed expiry time. If used, expires_on must be set.\n - ALL_CVE_FIXABLE: Request expires if all CVEs in the request are fixable.\n - ANY_CVE_FIXABLE: Request expires if any CVE in the request is fixable.",
                        "default": "TIME",
                        "enum": [
                          "TIME",
                          "ALL_CVE_FIXABLE",
                          "ANY_CVE_FIXABLE"
                        ]
                      }
                    },
                    "description": "RequestExpiry defines the expiration configuration for deferral requests.\n\n**Expiry Rules:**\n- Deferral requests must specify expiry (either expires_when_fixed or expires_on)\n- False-positive requests do not have expiry (permanent)\n- Cannot specify both expiry options\n- Expiry type is under development (do not use for non-development purposes)"
                  }
                },
                "description": "DeferralUpdate represents an update to an existing deferral request.\n\n**Update Rules:**\n- Can add or remove CVEs from the request\n- Cannot remove all CVEs (at least one CVE must remain)\n- Can update expiry configuration\n- Creates a new pending update request"
              },
              "falsePositiveUpdate": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "CVEs": {
                    "type": "array",
                    "description": "CVEs to be updated in the false-positive request.\nCannot be empty (at least one CVE must remain).",
                    "items": {
                      "nullable": true,
                      "type": "string"
                    }
                  }
                },
                "description": "FalsePositiveUpdate represents an update to an existing false-positive request.\n\n**Update Rules:**\n- Can add or remove CVEs from the request\n- Cannot remove all CVEs (at least one CVE must remain)\n- False-positive requests remain permanent (no expiry)"
              }
            },
            "description": "VulnerabilityRequest encapsulates a request such as deferral request and false-positive request.\n\n**Request Lifecycle:**\n- Creation: New request in PENDING state\n- Approval: Request approved and enforced\n- Denial: Request denied and closed\n- Update: Approved request with pending update\n- Expiry: Request expires automatically or manually\n- Undo: Approved request undone and vulnerabilities re-enabled\n\n**Validation Rules:**\n- New requests must not have ID (auto-generated)\n- Must have at least one comment\n- Must have valid CVE format (e.g., \"CVE-2021-1234\")\n- Must have valid scope (image scope or global scope)\n- Cannot create duplicate requests for same CVE-scope combination\n- Deferral requests must specify expiry\n- False-positive requests are permanent (no expiry)\n- New requests cannot start in APPROVED or DENIED state\n\n**Performance Considerations:**\n- Maximum 1000 requests returned per list operation\n- Requests are processed sequentially to prevent race conditions\n- Duplicate prevention checks are performed during creation"
          }
        },
        "description": "UndoVulnRequestResponse contains the undone request information."
      },
      "VulnerabilityRequestServiceUpdateVulnerabilityRequestBody": {
        "nullable": true,
        "type": "object",
        "properties": {
          "comment": {
            "nullable": true,
            "type": "string",
            "description": "Comment explaining the update.\nRequired for update action."
          },
          "expiry": {
            "nullable": true,
            "type": "object",
            "properties": {
              "expiresWhenFixed": {
                "type": "boolean",
                "description": "Indicates that this request expires when the associated vulnerability is fixed.\nCannot be used with expires_on.\nOnly applicable to deferral requests."
              },
              "expiresOn": {
                "nullable": true,
                "type": "string",
                "description": "Indicates the timestamp when this request expires.\nCannot be used with expires_when_fixed.\nMust be a future timestamp.",
                "format": "date-time"
              },
              "expiryType": {
                "nullable": true,
                "type": "string",
                "description": "ExpiryType indicates the type of expiry for the request.\nThis field is under development, DO NOT USE FOR NON-DEVELOPMENT PURPOSES.\n\n - TIME: Request has a fixed expiry time. If used, expires_on must be set.\n - ALL_CVE_FIXABLE: Request expires if all CVEs in the request are fixable.\n - ANY_CVE_FIXABLE: Request expires if any CVE in the request is fixable.",
                "default": "TIME",
                "enum": [
                  "TIME",
                  "ALL_CVE_FIXABLE",
                  "ANY_CVE_FIXABLE"
                ]
              }
            },
            "description": "RequestExpiry defines the expiration configuration for deferral requests.\n\n**Expiry Rules:**\n- Deferral requests must specify expiry (either expires_when_fixed or expires_on)\n- False-positive requests do not have expiry (permanent)\n- Cannot specify both expiry options\n- Expiry type is under development (do not use for non-development purposes)"
          }
        },
        "description": "UpdateVulnRequest contains parameters for updating a vulnerability request.\n\n**Update Limitations:**\n- Currently, only expiry can be updated\n- Comment is required for update\n- Only pending requests can be updated\n- Update creates a new pending update request"
      },
      "v1UpdateVulnRequestResponse": {
        "nullable": true,
        "type": "object",
        "properties": {
          "requestInfo": {
            "nullable": true,
            "type": "object",
            "properties": {
              "id": {
                "nullable": true,
                "type": "string",
                "description": "Unique identifier for the vulnerability request (auto-generated).\nNew requests must not specify this field."
              },
              "name": {
                "nullable": true,
                "type": "string",
                "description": "Human-readable name for the request (auto-generated).\nMust be unique across all requests."
              },
              "targetState": {
                "nullable": true,
                "type": "string",
                "description": "VulnerabilityState indicates if vulnerability is being observed or deferred(/suppressed). By default, it vulnerabilities are observed.\n\n - OBSERVED: [Default state]",
                "default": "OBSERVED",
                "enum": [
                  "OBSERVED",
                  "DEFERRED",
                  "FALSE_POSITIVE"
                ]
              },
              "status": {
                "nullable": true,
                "type": "string",
                "description": "RequestStatus indicates the status of a vulnerability request.\n\n**Status Lifecycle:**\n- PENDING: Default state for new requests awaiting approval/denial\n- APPROVED: Request approved and enforced\n- DENIED: Request denied and permanently closed\n- APPROVED_PENDING_UPDATE: Approved request with pending update\n\n**Status Rules:**\n- New requests must start in PENDING state\n- Only PENDING requests can be approved or denied\n- APPROVED requests can be updated (creates APPROVED_PENDING_UPDATE)\n- DENIED requests are permanently closed\n- Cancelled requests are not persisted (except in audit logs)\n\n - PENDING: Default request state. It indicates that the request has not been fulfilled and that an action (approve/deny) is required.\nOnly requests in this state can be approved, denied, or updated.\n - APPROVED: Indicates that the request has been approved by the approver.\nApproved requests are immediately enforced and suppress vulnerability detection.\nOnly PENDING requests can transition to this state.\n - DENIED: Indicates that the request has been denied by the approver.\nDenied requests are permanently closed and have no impact on vulnerability detection.\nOnly PENDING requests can transition to this state.\n - APPROVED_PENDING_UPDATE: Indicates that the original request was approved, but an update is still pending an approval or denial.\nThis state occurs when an approved request is updated.\nThe original approval remains in effect until the update is processed.",
                "default": "PENDING",
                "enum": [
                  "PENDING",
                  "APPROVED",
                  "DENIED",
                  "APPROVED_PENDING_UPDATE"
                ]
              },
              "expired": {
                "type": "boolean",
                "description": "Indicates if this request is a historical request that is no longer in effect\ndue to deferral expiry, cancellation, or restarting cve observation.\nExpired requests are retained for audit purposes."
              },
              "requestor": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "id": {
                    "nullable": true,
                    "type": "string"
                  },
                  "name": {
                    "nullable": true,
                    "type": "string"
                  }
                }
              },
              "approvers": {
                "type": "array",
                "description": "DEPRECATED: Use approvers_v2 instead.\nUsers who can approve or deny the request.",
                "items": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "id": {
                      "nullable": true,
                      "type": "string"
                    },
                    "name": {
                      "nullable": true,
                      "type": "string"
                    }
                  }
                }
              },
              "createdAt": {
                "nullable": true,
                "type": "string",
                "description": "Timestamp when the request was created.",
                "format": "date-time"
              },
              "lastUpdated": {
                "nullable": true,
                "type": "string",
                "description": "Timestamp when the request was last updated.",
                "format": "date-time"
              },
              "comments": {
                "type": "array",
                "description": "Comments on the request providing audit trail.\nMust have at least one comment for new requests.",
                "items": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "id": {
                      "nullable": true,
                      "type": "string",
                      "description": "Unique identifier for the comment."
                    },
                    "message": {
                      "nullable": true,
                      "type": "string",
                      "description": "The comment message content.\nRequired for all request actions."
                    },
                    "user": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "id": {
                          "nullable": true,
                          "type": "string"
                        },
                        "name": {
                          "nullable": true,
                          "type": "string"
                        }
                      }
                    },
                    "createdAt": {
                      "nullable": true,
                      "type": "string",
                      "description": "Timestamp when the comment was created.",
                      "format": "date-time"
                    }
                  },
                  "description": "RequestComment represents a comment on a vulnerability request.\n\n**Comment Rules:**\n- Comments are required for all request actions (create, approve, deny, update)\n- Each comment is associated with a user and timestamp\n- Comments provide audit trail for request lifecycle"
                }
              },
              "scope": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "imageScope": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "registry": {
                        "nullable": true,
                        "type": "string",
                        "description": "Container registry (e.g., \"docker.io\", \"gcr.io\").\nRequired for image scope."
                      },
                      "remote": {
                        "nullable": true,
                        "type": "string",
                        "description": "Image repository name (e.g., \"stackrox/main\").\nRequired for image scope."
                      },
                      "tag": {
                        "nullable": true,
                        "type": "string",
                        "description": "Image tag (e.g., \"latest\", \"v1.0.0\").\nRequired for image scope."
                      }
                    },
                    "description": "Image scope applies the request to specific container images."
                  },
                  "globalScope": {
                    "nullable": true,
                    "type": "object",
                    "description": "Global scope applies the request system-wide (deprecated)."
                  }
                },
                "description": "Scope defines the scope where the vulnerability request applies."
              },
              "requesterV2": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "id": {
                    "nullable": true,
                    "type": "string",
                    "description": "Unique identifier for the requester."
                  },
                  "name": {
                    "nullable": true,
                    "type": "string",
                    "description": "Display name of the requester."
                  }
                },
                "description": "Requester represents the user who created the vulnerability request.\n\n**Requester Rules:**\n- Must be specified for all new requests\n- Cannot be changed after request creation\n- Used for audit trail and permission checks"
              },
              "approversV2": {
                "type": "array",
                "description": "Users who can approve or deny the request (v2).\nMultiple approvers can be assigned.",
                "items": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "id": {
                      "nullable": true,
                      "type": "string",
                      "description": "Unique identifier for the approver."
                    },
                    "name": {
                      "nullable": true,
                      "type": "string",
                      "description": "Display name of the approver."
                    }
                  },
                  "description": "Approver represents a user who can approve or deny vulnerability requests.\n\n**Approver Rules:**\n- Multiple approvers can be assigned to a request\n- Any approver can approve or deny the request\n- Used for audit trail and permission checks"
                }
              },
              "deferralReq": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "expiry": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "expiresWhenFixed": {
                        "type": "boolean",
                        "description": "Indicates that this request expires when the associated vulnerability is fixed.\nCannot be used with expires_on.\nOnly applicable to deferral requests."
                      },
                      "expiresOn": {
                        "nullable": true,
                        "type": "string",
                        "description": "Indicates the timestamp when this request expires.\nCannot be used with expires_when_fixed.\nMust be a future timestamp.",
                        "format": "date-time"
                      },
                      "expiryType": {
                        "nullable": true,
                        "type": "string",
                        "description": "ExpiryType indicates the type of expiry for the request.\nThis field is under development, DO NOT USE FOR NON-DEVELOPMENT PURPOSES.\n\n - TIME: Request has a fixed expiry time. If used, expires_on must be set.\n - ALL_CVE_FIXABLE: Request expires if all CVEs in the request are fixable.\n - ANY_CVE_FIXABLE: Request expires if any CVE in the request is fixable.",
                        "default": "TIME",
                        "enum": [
                          "TIME",
                          "ALL_CVE_FIXABLE",
                          "ANY_CVE_FIXABLE"
                        ]
                      }
                    },
                    "description": "RequestExpiry defines the expiration configuration for deferral requests.\n\n**Expiry Rules:**\n- Deferral requests must specify expiry (either expires_when_fixed or expires_on)\n- False-positive requests do not have expiry (permanent)\n- Cannot specify both expiry options\n- Expiry type is under development (do not use for non-development purposes)"
                  }
                },
                "description": "DeferralRequest represents a request to temporarily defer vulnerability detection.\n\n**Deferral Rules:**\n- Must specify expiry configuration\n- Expiry can be time-based or fix-based\n- Deferrals are temporary and expire automatically"
              },
              "fpRequest": {
                "nullable": true,
                "type": "object",
                "description": "FalsePositiveRequest represents a request to permanently mark vulnerabilities as false-positive.\n\n**False-Positive Rules:**\n- No expiry configuration (permanent)\n- False-positives are permanently suppressed\n- Cannot be undone except through request management"
              },
              "cves": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "cves": {
                    "type": "array",
                    "description": "These are (NVD) vulnerability identifiers, `cve` field of `storage.CVE`, and *not* the `id` field.\nFor example, CVE-2021-44832.\nMust be in valid CVE format and not already covered by approved requests.",
                    "items": {
                      "nullable": true,
                      "type": "string"
                    }
                  }
                },
                "description": "CVEs represents the list of CVE identifiers in the request."
              },
              "updatedDeferralReq": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "expiry": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "expiresWhenFixed": {
                        "type": "boolean",
                        "description": "Indicates that this request expires when the associated vulnerability is fixed.\nCannot be used with expires_on.\nOnly applicable to deferral requests."
                      },
                      "expiresOn": {
                        "nullable": true,
                        "type": "string",
                        "description": "Indicates the timestamp when this request expires.\nCannot be used with expires_when_fixed.\nMust be a future timestamp.",
                        "format": "date-time"
                      },
                      "expiryType": {
                        "nullable": true,
                        "type": "string",
                        "description": "ExpiryType indicates the type of expiry for the request.\nThis field is under development, DO NOT USE FOR NON-DEVELOPMENT PURPOSES.\n\n - TIME: Request has a fixed expiry time. If used, expires_on must be set.\n - ALL_CVE_FIXABLE: Request expires if all CVEs in the request are fixable.\n - ANY_CVE_FIXABLE: Request expires if any CVE in the request is fixable.",
                        "default": "TIME",
                        "enum": [
                          "TIME",
                          "ALL_CVE_FIXABLE",
                          "ANY_CVE_FIXABLE"
                        ]
                      }
                    },
                    "description": "RequestExpiry defines the expiration configuration for deferral requests.\n\n**Expiry Rules:**\n- Deferral requests must specify expiry (either expires_when_fixed or expires_on)\n- False-positive requests do not have expiry (permanent)\n- Cannot specify both expiry options\n- Expiry type is under development (do not use for non-development purposes)"
                  }
                },
                "description": "DeferralRequest represents a request to temporarily defer vulnerability detection.\n\n**Deferral Rules:**\n- Must specify expiry configuration\n- Expiry can be time-based or fix-based\n- Deferrals are temporary and expire automatically"
              },
              "deferralUpdate": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "CVEs": {
                    "type": "array",
                    "description": "CVEs to be updated in the deferral request.\nCannot be empty (at least one CVE must remain).",
                    "items": {
                      "nullable": true,
                      "type": "string"
                    }
                  },
                  "expiry": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "expiresWhenFixed": {
                        "type": "boolean",
                        "description": "Indicates that this request expires when the associated vulnerability is fixed.\nCannot be used with expires_on.\nOnly applicable to deferral requests."
                      },
                      "expiresOn": {
                        "nullable": true,
                        "type": "string",
                        "description": "Indicates the timestamp when this request expires.\nCannot be used with expires_when_fixed.\nMust be a future timestamp.",
                        "format": "date-time"
                      },
                      "expiryType": {
                        "nullable": true,
                        "type": "string",
                        "description": "ExpiryType indicates the type of expiry for the request.\nThis field is under development, DO NOT USE FOR NON-DEVELOPMENT PURPOSES.\n\n - TIME: Request has a fixed expiry time. If used, expires_on must be set.\n - ALL_CVE_FIXABLE: Request expires if all CVEs in the request are fixable.\n - ANY_CVE_FIXABLE: Request expires if any CVE in the request is fixable.",
                        "default": "TIME",
                        "enum": [
                          "TIME",
                          "ALL_CVE_FIXABLE",
                          "ANY_CVE_FIXABLE"
                        ]
                      }
                    },
                    "description": "RequestExpiry defines the expiration configuration for deferral requests.\n\n**Expiry Rules:**\n- Deferral requests must specify expiry (either expires_when_fixed or expires_on)\n- False-positive requests do not have expiry (permanent)\n- Cannot specify both expiry options\n- Expiry type is under development (do not use for non-development purposes)"
                  }
                },
                "description": "DeferralUpdate represents an update to an existing deferral request.\n\n**Update Rules:**\n- Can add or remove CVEs from the request\n- Cannot remove all CVEs (at least one CVE must remain)\n- Can update expiry configuration\n- Creates a new pending update request"
              },
              "falsePositiveUpdate": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "CVEs": {
                    "type": "array",
                    "description": "CVEs to be updated in the false-positive request.\nCannot be empty (at least one CVE must remain).",
                    "items": {
                      "nullable": true,
                      "type": "string"
                    }
                  }
                },
                "description": "FalsePositiveUpdate represents an update to an existing false-positive request.\n\n**Update Rules:**\n- Can add or remove CVEs from the request\n- Cannot remove all CVEs (at least one CVE must remain)\n- False-positive requests remain permanent (no expiry)"
              }
            },
            "description": "VulnerabilityRequest encapsulates a request such as deferral request and false-positive request.\n\n**Request Lifecycle:**\n- Creation: New request in PENDING state\n- Approval: Request approved and enforced\n- Denial: Request denied and closed\n- Update: Approved request with pending update\n- Expiry: Request expires automatically or manually\n- Undo: Approved request undone and vulnerabilities re-enabled\n\n**Validation Rules:**\n- New requests must not have ID (auto-generated)\n- Must have at least one comment\n- Must have valid CVE format (e.g., \"CVE-2021-1234\")\n- Must have valid scope (image scope or global scope)\n- Cannot create duplicate requests for same CVE-scope combination\n- Deferral requests must specify expiry\n- False-positive requests are permanent (no expiry)\n- New requests cannot start in APPROVED or DENIED state\n\n**Performance Considerations:**\n- Maximum 1000 requests returned per list operation\n- Requests are processed sequentially to prevent race conditions\n- Duplicate prevention checks are performed during creation"
          }
        },
        "description": "UpdateVulnRequestResponse contains the updated request information."
      },
      "storageListDeployment": {
        "title": "Next available tag: 9",
        "nullable": true,
        "type": "object",
        "properties": {
          "id": {
            "nullable": true,
            "type": "string"
          },
          "hash": {
            "nullable": true,
            "type": "string",
            "format": "uint64"
          },
          "name": {
            "nullable": true,
            "type": "string"
          },
          "cluster": {
            "nullable": true,
            "type": "string"
          },
          "clusterId": {
            "nullable": true,
            "type": "string"
          },
          "namespace": {
            "nullable": true,
            "type": "string"
          },
          "created": {
            "nullable": true,
            "type": "string",
            "format": "date-time"
          },
          "priority": {
            "nullable": true,
            "type": "string",
            "format": "int64"
          }
        }
      },
      "v1ListDeploymentsResponse": {
        "nullable": true,
        "type": "object",
        "properties": {
          "deployments": {
            "type": "array",
            "items": {
              "title": "Next available tag: 9",
              "nullable": true,
              "type": "object",
              "properties": {
                "id": {
                  "nullable": true,
                  "type": "string"
                },
                "hash": {
                  "nullable": true,
                  "type": "string",
                  "format": "uint64"
                },
                "name": {
                  "nullable": true,
                  "type": "string"
                },
                "cluster": {
                  "nullable": true,
                  "type": "string"
                },
                "clusterId": {
                  "nullable": true,
                  "type": "string"
                },
                "namespace": {
                  "nullable": true,
                  "type": "string"
                },
                "created": {
                  "nullable": true,
                  "type": "string",
                  "format": "date-time"
                },
                "priority": {
                  "nullable": true,
                  "type": "string",
                  "format": "int64"
                }
              }
            }
          }
        }
      },
      "storageNamespaceMetadata": {
        "nullable": true,
        "type": "object",
        "properties": {
          "id": {
            "nullable": true,
            "type": "string"
          },
          "name": {
            "nullable": true,
            "type": "string"
          },
          "clusterId": {
            "nullable": true,
            "type": "string"
          },
          "clusterName": {
            "nullable": true,
            "type": "string"
          },
          "labels": {
            "nullable": true,
            "type": "object",
            "additionalProperties": {
              "nullable": true,
              "type": "string"
            }
          },
          "creationTime": {
            "nullable": true,
            "type": "string",
            "format": "date-time"
          },
          "priority": {
            "nullable": true,
            "type": "string",
            "format": "int64"
          },
          "annotations": {
            "nullable": true,
            "type": "object",
            "additionalProperties": {
              "nullable": true,
              "type": "string"
            }
          }
        }
      },
      "v1Namespace": {
        "nullable": true,
        "type": "object",
        "properties": {
          "metadata": {
            "nullable": true,
            "type": "object",
            "properties": {
              "id": {
                "nullable": true,
                "type": "string"
              },
              "name": {
                "nullable": true,
                "type": "string"
              },
              "clusterId": {
                "nullable": true,
                "type": "string"
              },
              "clusterName": {
                "nullable": true,
                "type": "string"
              },
              "labels": {
                "nullable": true,
                "type": "object",
                "additionalProperties": {
                  "nullable": true,
                  "type": "string"
                }
              },
              "creationTime": {
                "nullable": true,
                "type": "string",
                "format": "date-time"
              },
              "priority": {
                "nullable": true,
                "type": "string",
                "format": "int64"
              },
              "annotations": {
                "nullable": true,
                "type": "object",
                "additionalProperties": {
                  "nullable": true,
                  "type": "string"
                }
              }
            }
          },
          "numDeployments": {
            "type": "integer",
            "format": "int32"
          },
          "numSecrets": {
            "type": "integer",
            "format": "int32"
          },
          "numNetworkPolicies": {
            "type": "integer",
            "format": "int32"
          }
        }
      },
      "v1GetNamespacesResponse": {
        "nullable": true,
        "type": "object",
        "properties": {
          "namespaces": {
            "type": "array",
            "items": {
              "nullable": true,
              "type": "object",
              "properties": {
                "metadata": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "id": {
                      "nullable": true,
                      "type": "string"
                    },
                    "name": {
                      "nullable": true,
                      "type": "string"
                    },
                    "clusterId": {
                      "nullable": true,
                      "type": "string"
                    },
                    "clusterName": {
                      "nullable": true,
                      "type": "string"
                    },
                    "labels": {
                      "nullable": true,
                      "type": "object",
                      "additionalProperties": {
                        "nullable": true,
                        "type": "string"
                      }
                    },
                    "creationTime": {
                      "nullable": true,
                      "type": "string",
                      "format": "date-time"
                    },
                    "priority": {
                      "nullable": true,
                      "type": "string",
                      "format": "int64"
                    },
                    "annotations": {
                      "nullable": true,
                      "type": "object",
                      "additionalProperties": {
                        "nullable": true,
                        "type": "string"
                      }
                    }
                  }
                },
                "numDeployments": {
                  "type": "integer",
                  "format": "int32"
                },
                "numSecrets": {
                  "type": "integer",
                  "format": "int32"
                },
                "numNetworkPolicies": {
                  "type": "integer",
                  "format": "int32"
                }
              }
            }
          }
        }
      },
      "storageLabelSelectorOperator": {
        "nullable": true,
        "type": "string",
        "default": "UNKNOWN",
        "enum": [
          "UNKNOWN",
          "IN",
          "NOT_IN",
          "EXISTS",
          "NOT_EXISTS"
        ]
      },
      "storageLabelSelectorRequirement": {
        "title": "Next available tag: 4",
        "nullable": true,
        "type": "object",
        "properties": {
          "key": {
            "nullable": true,
            "type": "string"
          },
          "op": {
            "nullable": true,
            "type": "string",
            "default": "UNKNOWN",
            "enum": [
              "UNKNOWN",
              "IN",
              "NOT_IN",
              "EXISTS",
              "NOT_EXISTS"
            ]
          },
          "values": {
            "type": "array",
            "items": {
              "nullable": true,
              "type": "string"
            }
          }
        }
      },
      "storageLabelSelector": {
        "title": "Label selector components are joined with logical AND, see\n    https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/",
        "nullable": true,
        "type": "object",
        "properties": {
          "matchLabels": {
            "nullable": true,
            "type": "object",
            "additionalProperties": {
              "nullable": true,
              "type": "string"
            },
            "description": "This is actually a oneof, but we can't make it one due to backwards\ncompatibility constraints."
          },
          "requirements": {
            "type": "array",
            "items": {
              "title": "Next available tag: 4",
              "nullable": true,
              "type": "object",
              "properties": {
                "key": {
                  "nullable": true,
                  "type": "string"
                },
                "op": {
                  "nullable": true,
                  "type": "string",
                  "default": "UNKNOWN",
                  "enum": [
                    "UNKNOWN",
                    "IN",
                    "NOT_IN",
                    "EXISTS",
                    "NOT_EXISTS"
                  ]
                },
                "values": {
                  "type": "array",
                  "items": {
                    "nullable": true,
                    "type": "string"
                  }
                }
              }
            }
          }
        },
        "description": "Next available tag: 3"
      },
      "EnvironmentConfigEnvVarSource": {
        "title": "For any update to EnvVarSource, please also update 'ui/src/messages/common.js'",
        "nullable": true,
        "type": "string",
        "default": "UNSET",
        "enum": [
          "UNSET",
          "RAW",
          "SECRET_KEY",
          "CONFIG_MAP_KEY",
          "FIELD",
          "RESOURCE_FIELD",
          "UNKNOWN"
        ]
      },
      "ContainerConfigEnvironmentConfig": {
        "nullable": true,
        "type": "object",
        "properties": {
          "key": {
            "nullable": true,
            "type": "string"
          },
          "value": {
            "nullable": true,
            "type": "string"
          },
          "envVarSource": {
            "title": "For any update to EnvVarSource, please also update 'ui/src/messages/common.js'",
            "nullable": true,
            "type": "string",
            "default": "UNSET",
            "enum": [
              "UNSET",
              "RAW",
              "SECRET_KEY",
              "CONFIG_MAP_KEY",
              "FIELD",
              "RESOURCE_FIELD",
              "UNKNOWN"
            ]
          }
        }
      },
      "storageContainerConfig": {
        "nullable": true,
        "type": "object",
        "properties": {
          "env": {
            "type": "array",
            "items": {
              "nullable": true,
              "type": "object",
              "properties": {
                "key": {
                  "nullable": true,
                  "type": "string"
                },
                "value": {
                  "nullable": true,
                  "type": "string"
                },
                "envVarSource": {
                  "title": "For any update to EnvVarSource, please also update 'ui/src/messages/common.js'",
                  "nullable": true,
                  "type": "string",
                  "default": "UNSET",
                  "enum": [
                    "UNSET",
                    "RAW",
                    "SECRET_KEY",
                    "CONFIG_MAP_KEY",
                    "FIELD",
                    "RESOURCE_FIELD",
                    "UNKNOWN"
                  ]
                }
              }
            }
          },
          "command": {
            "type": "array",
            "items": {
              "nullable": true,
              "type": "string"
            }
          },
          "args": {
            "type": "array",
            "items": {
              "nullable": true,
              "type": "string"
            }
          },
          "directory": {
            "nullable": true,
            "type": "string"
          },
          "user": {
            "nullable": true,
            "type": "string"
          },
          "uid": {
            "nullable": true,
            "type": "string",
            "format": "int64"
          },
          "appArmorProfile": {
            "nullable": true,
            "type": "string"
          }
        }
      },
      "SecurityContextSELinux": {
        "nullable": true,
        "type": "object",
        "properties": {
          "user": {
            "nullable": true,
            "type": "string"
          },
          "role": {
            "nullable": true,
            "type": "string"
          },
          "type": {
            "nullable": true,
            "type": "string"
          },
          "level": {
            "nullable": true,
            "type": "string"
          }
        }
      },
      "SeccompProfileProfileType": {
        "nullable": true,
        "type": "string",
        "default": "UNCONFINED",
        "enum": [
          "UNCONFINED",
          "RUNTIME_DEFAULT",
          "LOCALHOST"
        ]
      },
      "SecurityContextSeccompProfile": {
        "nullable": true,
        "type": "object",
        "properties": {
          "type": {
            "nullable": true,
            "type": "string",
            "default": "UNCONFINED",
            "enum": [
              "UNCONFINED",
              "RUNTIME_DEFAULT",
              "LOCALHOST"
            ]
          },
          "localhostProfile": {
            "nullable": true,
            "type": "string"
          }
        }
      },
      "storageSecurityContext": {
        "nullable": true,
        "type": "object",
        "properties": {
          "privileged": {
            "type": "boolean"
          },
          "selinux": {
            "nullable": true,
            "type": "object",
            "properties": {
              "user": {
                "nullable": true,
                "type": "string"
              },
              "role": {
                "nullable": true,
                "type": "string"
              },
              "type": {
                "nullable": true,
                "type": "string"
              },
              "level": {
                "nullable": true,
                "type": "string"
              }
            }
          },
          "dropCapabilities": {
            "type": "array",
            "items": {
              "nullable": true,
              "type": "string"
            }
          },
          "addCapabilities": {
            "type": "array",
            "items": {
              "nullable": true,
              "type": "string"
            }
          },
          "readOnlyRootFilesystem": {
            "type": "boolean"
          },
          "seccompProfile": {
            "nullable": true,
            "type": "object",
            "properties": {
              "type": {
                "nullable": true,
                "type": "string",
                "default": "UNCONFINED",
                "enum": [
                  "UNCONFINED",
                  "RUNTIME_DEFAULT",
                  "LOCALHOST"
                ]
              },
              "localhostProfile": {
                "nullable": true,
                "type": "string"
              }
            }
          },
          "allowPrivilegeEscalation": {
            "type": "boolean"
          }
        }
      },
      "VolumeMountPropagation": {
        "nullable": true,
        "type": "string",
        "default": "NONE",
        "enum": [
          "NONE",
          "HOST_TO_CONTAINER",
          "BIDIRECTIONAL"
        ]
      },
      "storageVolume": {
        "nullable": true,
        "type": "object",
        "properties": {
          "name": {
            "nullable": true,
            "type": "string"
          },
          "source": {
            "nullable": true,
            "type": "string"
          },
          "destination": {
            "nullable": true,
            "type": "string"
          },
          "readOnly": {
            "type": "boolean"
          },
          "type": {
            "nullable": true,
            "type": "string"
          },
          "mountPropagation": {
            "nullable": true,
            "type": "string",
            "default": "NONE",
            "enum": [
              "NONE",
              "HOST_TO_CONTAINER",
              "BIDIRECTIONAL"
            ]
          }
        }
      },
      "PortConfigExposureLevel": {
        "nullable": true,
        "type": "string",
        "default": "UNSET",
        "enum": [
          "UNSET",
          "EXTERNAL",
          "NODE",
          "INTERNAL",
          "HOST",
          "ROUTE"
        ]
      },
      "PortConfigExposureInfo": {
        "nullable": true,
        "type": "object",
        "properties": {
          "level": {
            "nullable": true,
            "type": "string",
            "default": "UNSET",
            "enum": [
              "UNSET",
              "EXTERNAL",
              "NODE",
              "INTERNAL",
              "HOST",
              "ROUTE"
            ]
          },
          "serviceName": {
            "title": "only set if level is not HOST",
            "nullable": true,
            "type": "string"
          },
          "serviceId": {
            "nullable": true,
            "type": "string"
          },
          "serviceClusterIp": {
            "nullable": true,
            "type": "string"
          },
          "servicePort": {
            "type": "integer",
            "format": "int32"
          },
          "nodePort": {
            "title": "only set if level is HOST, NODE, EXTERNAL or ROUTE",
            "type": "integer",
            "format": "int32"
          },
          "externalIps": {
            "title": "only set if level is EXTERNAL",
            "type": "array",
            "items": {
              "nullable": true,
              "type": "string"
            }
          },
          "externalHostnames": {
            "title": "only set if level is EXTERNAL or ROUTE",
            "type": "array",
            "items": {
              "nullable": true,
              "type": "string"
            }
          }
        }
      },
      "storagePortConfig": {
        "title": "Next Available Tag: 6",
        "nullable": true,
        "type": "object",
        "properties": {
          "name": {
            "nullable": true,
            "type": "string"
          },
          "containerPort": {
            "type": "integer",
            "format": "int32"
          },
          "protocol": {
            "nullable": true,
            "type": "string"
          },
          "exposure": {
            "nullable": true,
            "type": "string",
            "default": "UNSET",
            "enum": [
              "UNSET",
              "EXTERNAL",
              "NODE",
              "INTERNAL",
              "HOST",
              "ROUTE"
            ]
          },
          "exposedPort": {
            "type": "integer",
            "format": "int32"
          },
          "exposureInfos": {
            "type": "array",
            "items": {
              "nullable": true,
              "type": "object",
              "properties": {
                "level": {
                  "nullable": true,
                  "type": "string",
                  "default": "UNSET",
                  "enum": [
                    "UNSET",
                    "EXTERNAL",
                    "NODE",
                    "INTERNAL",
                    "HOST",
                    "ROUTE"
                  ]
                },
                "serviceName": {
                  "title": "only set if level is not HOST",
                  "nullable": true,
                  "type": "string"
                },
                "serviceId": {
                  "nullable": true,
                  "type": "string"
                },
                "serviceClusterIp": {
                  "nullable": true,
                  "type": "string"
                },
                "servicePort": {
                  "type": "integer",
                  "format": "int32"
                },
                "nodePort": {
                  "title": "only set if level is HOST, NODE, EXTERNAL or ROUTE",
                  "type": "integer",
                  "format": "int32"
                },
                "externalIps": {
                  "title": "only set if level is EXTERNAL",
                  "type": "array",
                  "items": {
                    "nullable": true,
                    "type": "string"
                  }
                },
                "externalHostnames": {
                  "title": "only set if level is EXTERNAL or ROUTE",
                  "type": "array",
                  "items": {
                    "nullable": true,
                    "type": "string"
                  }
                }
              }
            }
          }
        }
      },
      "storageEmbeddedSecret": {
        "nullable": true,
        "type": "object",
        "properties": {
          "name": {
            "nullable": true,
            "type": "string"
          },
          "path": {
            "nullable": true,
            "type": "string"
          }
        }
      },
      "storageResources": {
        "nullable": true,
        "type": "object",
        "properties": {
          "cpuCoresRequest": {
            "type": "number",
            "format": "float"
          },
          "cpuCoresLimit": {
            "type": "number",
            "format": "float"
          },
          "memoryMbRequest": {
            "type": "number",
            "format": "float"
          },
          "memoryMbLimit": {
            "type": "number",
            "format": "float"
          }
        }
      },
      "storageLivenessProbe": {
        "nullable": true,
        "type": "object",
        "properties": {
          "defined": {
            "type": "boolean"
          }
        }
      },
      "storageReadinessProbe": {
        "nullable": true,
        "type": "object",
        "properties": {
          "defined": {
            "type": "boolean"
          }
        }
      },
      "storageContainer": {
        "nullable": true,
        "type": "object",
        "properties": {
          "id": {
            "nullable": true,
            "type": "string"
          },
          "config": {
            "nullable": true,
            "type": "object",
            "properties": {
              "env": {
                "type": "array",
                "items": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "key": {
                      "nullable": true,
                      "type": "string"
                    },
                    "value": {
                      "nullable": true,
                      "type": "string"
                    },
                    "envVarSource": {
                      "title": "For any update to EnvVarSource, please also update 'ui/src/messages/common.js'",
                      "nullable": true,
                      "type": "string",
                      "default": "UNSET",
                      "enum": [
                        "UNSET",
                        "RAW",
                        "SECRET_KEY",
                        "CONFIG_MAP_KEY",
                        "FIELD",
                        "RESOURCE_FIELD",
                        "UNKNOWN"
                      ]
                    }
                  }
                }
              },
              "command": {
                "type": "array",
                "items": {
                  "nullable": true,
                  "type": "string"
                }
              },
              "args": {
                "type": "array",
                "items": {
                  "nullable": true,
                  "type": "string"
                }
              },
              "directory": {
                "nullable": true,
                "type": "string"
              },
              "user": {
                "nullable": true,
                "type": "string"
              },
              "uid": {
                "nullable": true,
                "type": "string",
                "format": "int64"
              },
              "appArmorProfile": {
                "nullable": true,
                "type": "string"
              }
            }
          },
          "image": {
            "title": "Next tag: 13",
            "nullable": true,
            "type": "object",
            "properties": {
              "id": {
                "nullable": true,
                "type": "string"
              },
              "name": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "registry": {
                    "nullable": true,
                    "type": "string"
                  },
                  "remote": {
                    "nullable": true,
                    "type": "string"
                  },
                  "tag": {
                    "nullable": true,
                    "type": "string"
                  },
                  "fullName": {
                    "nullable": true,
                    "type": "string"
                  }
                }
              },
              "notPullable": {
                "type": "boolean"
              },
              "isClusterLocal": {
                "type": "boolean"
              },
              "idV2": {
                "nullable": true,
                "type": "string"
              }
            }
          },
          "securityContext": {
            "nullable": true,
            "type": "object",
            "properties": {
              "privileged": {
                "type": "boolean"
              },
              "selinux": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "user": {
                    "nullable": true,
                    "type": "string"
                  },
                  "role": {
                    "nullable": true,
                    "type": "string"
                  },
                  "type": {
                    "nullable": true,
                    "type": "string"
                  },
                  "level": {
                    "nullable": true,
                    "type": "string"
                  }
                }
              },
              "dropCapabilities": {
                "type": "array",
                "items": {
                  "nullable": true,
                  "type": "string"
                }
              },
              "addCapabilities": {
                "type": "array",
                "items": {
                  "nullable": true,
                  "type": "string"
                }
              },
              "readOnlyRootFilesystem": {
                "type": "boolean"
              },
              "seccompProfile": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "type": {
                    "nullable": true,
                    "type": "string",
                    "default": "UNCONFINED",
                    "enum": [
                      "UNCONFINED",
                      "RUNTIME_DEFAULT",
                      "LOCALHOST"
                    ]
                  },
                  "localhostProfile": {
                    "nullable": true,
                    "type": "string"
                  }
                }
              },
              "allowPrivilegeEscalation": {
                "type": "boolean"
              }
            }
          },
          "volumes": {
            "type": "array",
            "items": {
              "nullable": true,
              "type": "object",
              "properties": {
                "name": {
                  "nullable": true,
                  "type": "string"
                },
                "source": {
                  "nullable": true,
                  "type": "string"
                },
                "destination": {
                  "nullable": true,
                  "type": "string"
                },
                "readOnly": {
                  "type": "boolean"
                },
                "type": {
                  "nullable": true,
                  "type": "string"
                },
                "mountPropagation": {
                  "nullable": true,
                  "type": "string",
                  "default": "NONE",
                  "enum": [
                    "NONE",
                    "HOST_TO_CONTAINER",
                    "BIDIRECTIONAL"
                  ]
                }
              }
            }
          },
          "ports": {
            "title": "Policies use the port config on the top-level deployment.",
            "type": "array",
            "items": {
              "title": "Next Available Tag: 6",
              "nullable": true,
              "type": "object",
              "properties": {
                "name": {
                  "nullable": true,
                  "type": "string"
                },
                "containerPort": {
                  "type": "integer",
                  "format": "int32"
                },
                "protocol": {
                  "nullable": true,
                  "type": "string"
                },
                "exposure": {
                  "nullable": true,
                  "type": "string",
                  "default": "UNSET",
                  "enum": [
                    "UNSET",
                    "EXTERNAL",
                    "NODE",
                    "INTERNAL",
                    "HOST",
                    "ROUTE"
                  ]
                },
                "exposedPort": {
                  "type": "integer",
                  "format": "int32"
                },
                "exposureInfos": {
                  "type": "array",
                  "items": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "level": {
                        "nullable": true,
                        "type": "string",
                        "default": "UNSET",
                        "enum": [
                          "UNSET",
                          "EXTERNAL",
                          "NODE",
                          "INTERNAL",
                          "HOST",
                          "ROUTE"
                        ]
                      },
                      "serviceName": {
                        "title": "only set if level is not HOST",
                        "nullable": true,
                        "type": "string"
                      },
                      "serviceId": {
                        "nullable": true,
                        "type": "string"
                      },
                      "serviceClusterIp": {
                        "nullable": true,
                        "type": "string"
                      },
                      "servicePort": {
                        "type": "integer",
                        "format": "int32"
                      },
                      "nodePort": {
                        "title": "only set if level is HOST, NODE, EXTERNAL or ROUTE",
                        "type": "integer",
                        "format": "int32"
                      },
                      "externalIps": {
                        "title": "only set if level is EXTERNAL",
                        "type": "array",
                        "items": {
                          "nullable": true,
                          "type": "string"
                        }
                      },
                      "externalHostnames": {
                        "title": "only set if level is EXTERNAL or ROUTE",
                        "type": "array",
                        "items": {
                          "nullable": true,
                          "type": "string"
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "secrets": {
            "type": "array",
            "items": {
              "nullable": true,
              "type": "object",
              "properties": {
                "name": {
                  "nullable": true,
                  "type": "string"
                },
                "path": {
                  "nullable": true,
                  "type": "string"
                }
              }
            }
          },
          "resources": {
            "nullable": true,
            "type": "object",
            "properties": {
              "cpuCoresRequest": {
                "type": "number",
                "format": "float"
              },
              "cpuCoresLimit": {
                "type": "number",
                "format": "float"
              },
              "memoryMbRequest": {
                "type": "number",
                "format": "float"
              },
              "memoryMbLimit": {
                "type": "number",
                "format": "float"
              }
            }
          },
          "name": {
            "nullable": true,
            "type": "string"
          },
          "livenessProbe": {
            "nullable": true,
            "type": "object",
            "properties": {
              "defined": {
                "type": "boolean"
              }
            }
          },
          "readinessProbe": {
            "nullable": true,
            "type": "object",
            "properties": {
              "defined": {
                "type": "boolean"
              }
            }
          }
        }
      },
      "storagePermissionLevel": {
        "title": "For any update to PermissionLevel, also update:\n- pkg/searchbasedpolicies/builders/k8s_rbac.go\n- ui/src/messages/common.js",
        "nullable": true,
        "type": "string",
        "default": "UNSET",
        "enum": [
          "UNSET",
          "NONE",
          "DEFAULT",
          "ELEVATED_IN_NAMESPACE",
          "ELEVATED_CLUSTER_WIDE",
          "CLUSTER_ADMIN"
        ]
      },
      "storageTolerationOperator": {
        "nullable": true,
        "type": "string",
        "default": "TOLERATION_OPERATION_UNKNOWN",
        "enum": [
          "TOLERATION_OPERATION_UNKNOWN",
          "TOLERATION_OPERATOR_EXISTS",
          "TOLERATION_OPERATOR_EQUAL"
        ]
      },
      "storageTaintEffect": {
        "nullable": true,
        "type": "string",
        "default": "UNKNOWN_TAINT_EFFECT",
        "enum": [
          "UNKNOWN_TAINT_EFFECT",
          "NO_SCHEDULE_TAINT_EFFECT",
          "PREFER_NO_SCHEDULE_TAINT_EFFECT",
          "NO_EXECUTE_TAINT_EFFECT"
        ]
      },
      "storageToleration": {
        "nullable": true,
        "type": "object",
        "properties": {
          "key": {
            "nullable": true,
            "type": "string"
          },
          "operator": {
            "nullable": true,
            "type": "string",
            "default": "TOLERATION_OPERATION_UNKNOWN",
            "enum": [
              "TOLERATION_OPERATION_UNKNOWN",
              "TOLERATION_OPERATOR_EXISTS",
              "TOLERATION_OPERATOR_EQUAL"
            ]
          },
          "value": {
            "nullable": true,
            "type": "string"
          },
          "taintEffect": {
            "nullable": true,
            "type": "string",
            "default": "UNKNOWN_TAINT_EFFECT",
            "enum": [
              "UNKNOWN_TAINT_EFFECT",
              "NO_SCHEDULE_TAINT_EFFECT",
              "PREFER_NO_SCHEDULE_TAINT_EFFECT",
              "NO_EXECUTE_TAINT_EFFECT"
            ]
          }
        }
      },
      "storageDeployment": {
        "title": "Next available tag: 36",
        "nullable": true,
        "type": "object",
        "properties": {
          "id": {
            "nullable": true,
            "type": "string"
          },
          "name": {
            "nullable": true,
            "type": "string"
          },
          "hash": {
            "nullable": true,
            "type": "string",
            "format": "uint64"
          },
          "type": {
            "nullable": true,
            "type": "string"
          },
          "namespace": {
            "nullable": true,
            "type": "string"
          },
          "namespaceId": {
            "nullable": true,
            "type": "string"
          },
          "orchestratorComponent": {
            "type": "boolean"
          },
          "replicas": {
            "nullable": true,
            "type": "string",
            "format": "int64"
          },
          "labels": {
            "nullable": true,
            "type": "object",
            "additionalProperties": {
              "nullable": true,
              "type": "string"
            }
          },
          "podLabels": {
            "nullable": true,
            "type": "object",
            "additionalProperties": {
              "nullable": true,
              "type": "string"
            }
          },
          "labelSelector": {
            "title": "Label selector components are joined with logical AND, see\n    https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/",
            "nullable": true,
            "type": "object",
            "properties": {
              "matchLabels": {
                "nullable": true,
                "type": "object",
                "additionalProperties": {
                  "nullable": true,
                  "type": "string"
                },
                "description": "This is actually a oneof, but we can't make it one due to backwards\ncompatibility constraints."
              },
              "requirements": {
                "type": "array",
                "items": {
                  "title": "Next available tag: 4",
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "key": {
                      "nullable": true,
                      "type": "string"
                    },
                    "op": {
                      "nullable": true,
                      "type": "string",
                      "default": "UNKNOWN",
                      "enum": [
                        "UNKNOWN",
                        "IN",
                        "NOT_IN",
                        "EXISTS",
                        "NOT_EXISTS"
                      ]
                    },
                    "values": {
                      "type": "array",
                      "items": {
                        "nullable": true,
                        "type": "string"
                      }
                    }
                  }
                }
              }
            },
            "description": "Next available tag: 3"
          },
          "created": {
            "nullable": true,
            "type": "string",
            "format": "date-time"
          },
          "clusterId": {
            "nullable": true,
            "type": "string"
          },
          "clusterName": {
            "nullable": true,
            "type": "string"
          },
          "containers": {
            "type": "array",
            "items": {
              "nullable": true,
              "type": "object",
              "properties": {
                "id": {
                  "nullable": true,
                  "type": "string"
                },
                "config": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "env": {
                      "type": "array",
                      "items": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "key": {
                            "nullable": true,
                            "type": "string"
                          },
                          "value": {
                            "nullable": true,
                            "type": "string"
                          },
                          "envVarSource": {
                            "title": "For any update to EnvVarSource, please also update 'ui/src/messages/common.js'",
                            "nullable": true,
                            "type": "string",
                            "default": "UNSET",
                            "enum": [
                              "UNSET",
                              "RAW",
                              "SECRET_KEY",
                              "CONFIG_MAP_KEY",
                              "FIELD",
                              "RESOURCE_FIELD",
                              "UNKNOWN"
                            ]
                          }
                        }
                      }
                    },
                    "command": {
                      "type": "array",
                      "items": {
                        "nullable": true,
                        "type": "string"
                      }
                    },
                    "args": {
                      "type": "array",
                      "items": {
                        "nullable": true,
                        "type": "string"
                      }
                    },
                    "directory": {
                      "nullable": true,
                      "type": "string"
                    },
                    "user": {
                      "nullable": true,
                      "type": "string"
                    },
                    "uid": {
                      "nullable": true,
                      "type": "string",
                      "format": "int64"
                    },
                    "appArmorProfile": {
                      "nullable": true,
                      "type": "string"
                    }
                  }
                },
                "image": {
                  "title": "Next tag: 13",
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "id": {
                      "nullable": true,
                      "type": "string"
                    },
                    "name": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "registry": {
                          "nullable": true,
                          "type": "string"
                        },
                        "remote": {
                          "nullable": true,
                          "type": "string"
                        },
                        "tag": {
                          "nullable": true,
                          "type": "string"
                        },
                        "fullName": {
                          "nullable": true,
                          "type": "string"
                        }
                      }
                    },
                    "notPullable": {
                      "type": "boolean"
                    },
                    "isClusterLocal": {
                      "type": "boolean"
                    },
                    "idV2": {
                      "nullable": true,
                      "type": "string"
                    }
                  }
                },
                "securityContext": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "privileged": {
                      "type": "boolean"
                    },
                    "selinux": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "user": {
                          "nullable": true,
                          "type": "string"
                        },
                        "role": {
                          "nullable": true,
                          "type": "string"
                        },
                        "type": {
                          "nullable": true,
                          "type": "string"
                        },
                        "level": {
                          "nullable": true,
                          "type": "string"
                        }
                      }
                    },
                    "dropCapabilities": {
                      "type": "array",
                      "items": {
                        "nullable": true,
                        "type": "string"
                      }
                    },
                    "addCapabilities": {
                      "type": "array",
                      "items": {
                        "nullable": true,
                        "type": "string"
                      }
                    },
                    "readOnlyRootFilesystem": {
                      "type": "boolean"
                    },
                    "seccompProfile": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "type": {
                          "nullable": true,
                          "type": "string",
                          "default": "UNCONFINED",
                          "enum": [
                            "UNCONFINED",
                            "RUNTIME_DEFAULT",
                            "LOCALHOST"
                          ]
                        },
                        "localhostProfile": {
                          "nullable": true,
                          "type": "string"
                        }
                      }
                    },
                    "allowPrivilegeEscalation": {
                      "type": "boolean"
                    }
                  }
                },
                "volumes": {
                  "type": "array",
                  "items": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "name": {
                        "nullable": true,
                        "type": "string"
                      },
                      "source": {
                        "nullable": true,
                        "type": "string"
                      },
                      "destination": {
                        "nullable": true,
                        "type": "string"
                      },
                      "readOnly": {
                        "type": "boolean"
                      },
                      "type": {
                        "nullable": true,
                        "type": "string"
                      },
                      "mountPropagation": {
                        "nullable": true,
                        "type": "string",
                        "default": "NONE",
                        "enum": [
                          "NONE",
                          "HOST_TO_CONTAINER",
                          "BIDIRECTIONAL"
                        ]
                      }
                    }
                  }
                },
                "ports": {
                  "title": "Policies use the port config on the top-level deployment.",
                  "type": "array",
                  "items": {
                    "title": "Next Available Tag: 6",
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "name": {
                        "nullable": true,
                        "type": "string"
                      },
                      "containerPort": {
                        "type": "integer",
                        "format": "int32"
                      },
                      "protocol": {
                        "nullable": true,
                        "type": "string"
                      },
                      "exposure": {
                        "nullable": true,
                        "type": "string",
                        "default": "UNSET",
                        "enum": [
                          "UNSET",
                          "EXTERNAL",
                          "NODE",
                          "INTERNAL",
                          "HOST",
                          "ROUTE"
                        ]
                      },
                      "exposedPort": {
                        "type": "integer",
                        "format": "int32"
                      },
                      "exposureInfos": {
                        "type": "array",
                        "items": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "level": {
                              "nullable": true,
                              "type": "string",
                              "default": "UNSET",
                              "enum": [
                                "UNSET",
                                "EXTERNAL",
                                "NODE",
                                "INTERNAL",
                                "HOST",
                                "ROUTE"
                              ]
                            },
                            "serviceName": {
                              "title": "only set if level is not HOST",
                              "nullable": true,
                              "type": "string"
                            },
                            "serviceId": {
                              "nullable": true,
                              "type": "string"
                            },
                            "serviceClusterIp": {
                              "nullable": true,
                              "type": "string"
                            },
                            "servicePort": {
                              "type": "integer",
                              "format": "int32"
                            },
                            "nodePort": {
                              "title": "only set if level is HOST, NODE, EXTERNAL or ROUTE",
                              "type": "integer",
                              "format": "int32"
                            },
                            "externalIps": {
                              "title": "only set if level is EXTERNAL",
                              "type": "array",
                              "items": {
                                "nullable": true,
                                "type": "string"
                              }
                            },
                            "externalHostnames": {
                              "title": "only set if level is EXTERNAL or ROUTE",
                              "type": "array",
                              "items": {
                                "nullable": true,
                                "type": "string"
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                },
                "secrets": {
                  "type": "array",
                  "items": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "name": {
                        "nullable": true,
                        "type": "string"
                      },
                      "path": {
                        "nullable": true,
                        "type": "string"
                      }
                    }
                  }
                },
                "resources": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "cpuCoresRequest": {
                      "type": "number",
                      "format": "float"
                    },
                    "cpuCoresLimit": {
                      "type": "number",
                      "format": "float"
                    },
                    "memoryMbRequest": {
                      "type": "number",
                      "format": "float"
                    },
                    "memoryMbLimit": {
                      "type": "number",
                      "format": "float"
                    }
                  }
                },
                "name": {
                  "nullable": true,
                  "type": "string"
                },
                "livenessProbe": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "defined": {
                      "type": "boolean"
                    }
                  }
                },
                "readinessProbe": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "defined": {
                      "type": "boolean"
                    }
                  }
                }
              }
            }
          },
          "annotations": {
            "nullable": true,
            "type": "object",
            "additionalProperties": {
              "nullable": true,
              "type": "string"
            }
          },
          "priority": {
            "nullable": true,
            "type": "string",
            "format": "int64"
          },
          "inactive": {
            "type": "boolean"
          },
          "imagePullSecrets": {
            "type": "array",
            "items": {
              "nullable": true,
              "type": "string"
            }
          },
          "serviceAccount": {
            "nullable": true,
            "type": "string"
          },
          "serviceAccountPermissionLevel": {
            "title": "For any update to PermissionLevel, also update:\n- pkg/searchbasedpolicies/builders/k8s_rbac.go\n- ui/src/messages/common.js",
            "nullable": true,
            "type": "string",
            "default": "UNSET",
            "enum": [
              "UNSET",
              "NONE",
              "DEFAULT",
              "ELEVATED_IN_NAMESPACE",
              "ELEVATED_CLUSTER_WIDE",
              "CLUSTER_ADMIN"
            ]
          },
          "automountServiceAccountToken": {
            "type": "boolean"
          },
          "hostNetwork": {
            "type": "boolean"
          },
          "hostPid": {
            "type": "boolean"
          },
          "hostIpc": {
            "type": "boolean"
          },
          "runtimeClass": {
            "nullable": true,
            "type": "string"
          },
          "tolerations": {
            "type": "array",
            "items": {
              "nullable": true,
              "type": "object",
              "properties": {
                "key": {
                  "nullable": true,
                  "type": "string"
                },
                "operator": {
                  "nullable": true,
                  "type": "string",
                  "default": "TOLERATION_OPERATION_UNKNOWN",
                  "enum": [
                    "TOLERATION_OPERATION_UNKNOWN",
                    "TOLERATION_OPERATOR_EXISTS",
                    "TOLERATION_OPERATOR_EQUAL"
                  ]
                },
                "value": {
                  "nullable": true,
                  "type": "string"
                },
                "taintEffect": {
                  "nullable": true,
                  "type": "string",
                  "default": "UNKNOWN_TAINT_EFFECT",
                  "enum": [
                    "UNKNOWN_TAINT_EFFECT",
                    "NO_SCHEDULE_TAINT_EFFECT",
                    "PREFER_NO_SCHEDULE_TAINT_EFFECT",
                    "NO_EXECUTE_TAINT_EFFECT"
                  ]
                }
              }
            }
          },
          "ports": {
            "type": "array",
            "items": {
              "title": "Next Available Tag: 6",
              "nullable": true,
              "type": "object",
              "properties": {
                "name": {
                  "nullable": true,
                  "type": "string"
                },
                "containerPort": {
                  "type": "integer",
                  "format": "int32"
                },
                "protocol": {
                  "nullable": true,
                  "type": "string"
                },
                "exposure": {
                  "nullable": true,
                  "type": "string",
                  "default": "UNSET",
                  "enum": [
                    "UNSET",
                    "EXTERNAL",
                    "NODE",
                    "INTERNAL",
                    "HOST",
                    "ROUTE"
                  ]
                },
                "exposedPort": {
                  "type": "integer",
                  "format": "int32"
                },
                "exposureInfos": {
                  "type": "array",
                  "items": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "level": {
                        "nullable": true,
                        "type": "string",
                        "default": "UNSET",
                        "enum": [
                          "UNSET",
                          "EXTERNAL",
                          "NODE",
                          "INTERNAL",
                          "HOST",
                          "ROUTE"
                        ]
                      },
                      "serviceName": {
                        "title": "only set if level is not HOST",
                        "nullable": true,
                        "type": "string"
                      },
                      "serviceId": {
                        "nullable": true,
                        "type": "string"
                      },
                      "serviceClusterIp": {
                        "nullable": true,
                        "type": "string"
                      },
                      "servicePort": {
                        "type": "integer",
                        "format": "int32"
                      },
                      "nodePort": {
                        "title": "only set if level is HOST, NODE, EXTERNAL or ROUTE",
                        "type": "integer",
                        "format": "int32"
                      },
                      "externalIps": {
                        "title": "only set if level is EXTERNAL",
                        "type": "array",
                        "items": {
                          "nullable": true,
                          "type": "string"
                        }
                      },
                      "externalHostnames": {
                        "title": "only set if level is EXTERNAL or ROUTE",
                        "type": "array",
                        "items": {
                          "nullable": true,
                          "type": "string"
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "stateTimestamp": {
            "title": "Internal use only",
            "nullable": true,
            "type": "string",
            "format": "int64"
          },
          "riskScore": {
            "type": "number",
            "format": "float"
          },
          "platformComponent": {
            "type": "boolean"
          }
        }
      },
      "storageRiskSubjectType": {
        "title": "Next tag: 9",
        "nullable": true,
        "type": "string",
        "default": "UNKNOWN",
        "enum": [
          "UNKNOWN",
          "DEPLOYMENT",
          "NAMESPACE",
          "CLUSTER",
          "NODE",
          "NODE_COMPONENT",
          "IMAGE",
          "IMAGE_COMPONENT",
          "SERVICEACCOUNT"
        ]
      },
      "storageRiskSubject": {
        "nullable": true,
        "type": "object",
        "properties": {
          "id": {
            "nullable": true,
            "type": "string"
          },
          "namespace": {
            "nullable": true,
            "type": "string"
          },
          "clusterId": {
            "nullable": true,
            "type": "string"
          },
          "type": {
            "title": "Next tag: 9",
            "nullable": true,
            "type": "string",
            "default": "UNKNOWN",
            "enum": [
              "UNKNOWN",
              "DEPLOYMENT",
              "NAMESPACE",
              "CLUSTER",
              "NODE",
              "NODE_COMPONENT",
              "IMAGE",
              "IMAGE_COMPONENT",
              "SERVICEACCOUNT"
            ]
          }
        }
      },
      "ResultFactor": {
        "nullable": true,
        "type": "object",
        "properties": {
          "message": {
            "nullable": true,
            "type": "string"
          },
          "url": {
            "nullable": true,
            "type": "string"
          }
        }
      },
      "storageRiskResult": {
        "nullable": true,
        "type": "object",
        "properties": {
          "name": {
            "nullable": true,
            "type": "string"
          },
          "factors": {
            "type": "array",
            "items": {
              "nullable": true,
              "type": "object",
              "properties": {
                "message": {
                  "nullable": true,
                  "type": "string"
                },
                "url": {
                  "nullable": true,
                  "type": "string"
                }
              }
            }
          },
          "score": {
            "type": "number",
            "format": "float"
          }
        }
      },
      "storageRisk": {
        "nullable": true,
        "type": "object",
        "properties": {
          "id": {
            "nullable": true,
            "type": "string"
          },
          "subject": {
            "nullable": true,
            "type": "object",
            "properties": {
              "id": {
                "nullable": true,
                "type": "string"
              },
              "namespace": {
                "nullable": true,
                "type": "string"
              },
              "clusterId": {
                "nullable": true,
                "type": "string"
              },
              "type": {
                "title": "Next tag: 9",
                "nullable": true,
                "type": "string",
                "default": "UNKNOWN",
                "enum": [
                  "UNKNOWN",
                  "DEPLOYMENT",
                  "NAMESPACE",
                  "CLUSTER",
                  "NODE",
                  "NODE_COMPONENT",
                  "IMAGE",
                  "IMAGE_COMPONENT",
                  "SERVICEACCOUNT"
                ]
              }
            }
          },
          "score": {
            "type": "number",
            "format": "float"
          },
          "results": {
            "type": "array",
            "items": {
              "nullable": true,
              "type": "object",
              "properties": {
                "name": {
                  "nullable": true,
                  "type": "string"
                },
                "factors": {
                  "type": "array",
                  "items": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "message": {
                        "nullable": true,
                        "type": "string"
                      },
                      "url": {
                        "nullable": true,
                        "type": "string"
                      }
                    }
                  }
                },
                "score": {
                  "type": "number",
                  "format": "float"
                }
              }
            }
          }
        }
      },
      "v1GetDeploymentWithRiskResponse": {
        "nullable": true,
        "type": "object",
        "properties": {
          "deployment": {
            "title": "Next available tag: 36",
            "nullable": true,
            "type": "object",
            "properties": {
              "id": {
                "nullable": true,
                "type": "string"
              },
              "name": {
                "nullable": true,
                "type": "string"
              },
              "hash": {
                "nullable": true,
                "type": "string",
                "format": "uint64"
              },
              "type": {
                "nullable": true,
                "type": "string"
              },
              "namespace": {
                "nullable": true,
                "type": "string"
              },
              "namespaceId": {
                "nullable": true,
                "type": "string"
              },
              "orchestratorComponent": {
                "type": "boolean"
              },
              "replicas": {
                "nullable": true,
                "type": "string",
                "format": "int64"
              },
              "labels": {
                "nullable": true,
                "type": "object",
                "additionalProperties": {
                  "nullable": true,
                  "type": "string"
                }
              },
              "podLabels": {
                "nullable": true,
                "type": "object",
                "additionalProperties": {
                  "nullable": true,
                  "type": "string"
                }
              },
              "labelSelector": {
                "title": "Label selector components are joined with logical AND, see\n    https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/",
                "nullable": true,
                "type": "object",
                "properties": {
                  "matchLabels": {
                    "nullable": true,
                    "type": "object",
                    "additionalProperties": {
                      "nullable": true,
                      "type": "string"
                    },
                    "description": "This is actually a oneof, but we can't make it one due to backwards\ncompatibility constraints."
                  },
                  "requirements": {
                    "type": "array",
                    "items": {
                      "title": "Next available tag: 4",
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "key": {
                          "nullable": true,
                          "type": "string"
                        },
                        "op": {
                          "nullable": true,
                          "type": "string",
                          "default": "UNKNOWN",
                          "enum": [
                            "UNKNOWN",
                            "IN",
                            "NOT_IN",
                            "EXISTS",
                            "NOT_EXISTS"
                          ]
                        },
                        "values": {
                          "type": "array",
                          "items": {
                            "nullable": true,
                            "type": "string"
                          }
                        }
                      }
                    }
                  }
                },
                "description": "Next available tag: 3"
              },
              "created": {
                "nullable": true,
                "type": "string",
                "format": "date-time"
              },
              "clusterId": {
                "nullable": true,
                "type": "string"
              },
              "clusterName": {
                "nullable": true,
                "type": "string"
              },
              "containers": {
                "type": "array",
                "items": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "id": {
                      "nullable": true,
                      "type": "string"
                    },
                    "config": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "env": {
                          "type": "array",
                          "items": {
                            "nullable": true,
                            "type": "object",
                            "properties": {
                              "key": {
                                "nullable": true,
                                "type": "string"
                              },
                              "value": {
                                "nullable": true,
                                "type": "string"
                              },
                              "envVarSource": {
                                "title": "For any update to EnvVarSource, please also update 'ui/src/messages/common.js'",
                                "nullable": true,
                                "type": "string",
                                "default": "UNSET",
                                "enum": [
                                  "UNSET",
                                  "RAW",
                                  "SECRET_KEY",
                                  "CONFIG_MAP_KEY",
                                  "FIELD",
                                  "RESOURCE_FIELD",
                                  "UNKNOWN"
                                ]
                              }
                            }
                          }
                        },
                        "command": {
                          "type": "array",
                          "items": {
                            "nullable": true,
                            "type": "string"
                          }
                        },
                        "args": {
                          "type": "array",
                          "items": {
                            "nullable": true,
                            "type": "string"
                          }
                        },
                        "directory": {
                          "nullable": true,
                          "type": "string"
                        },
                        "user": {
                          "nullable": true,
                          "type": "string"
                        },
                        "uid": {
                          "nullable": true,
                          "type": "string",
                          "format": "int64"
                        },
                        "appArmorProfile": {
                          "nullable": true,
                          "type": "string"
                        }
                      }
                    },
                    "image": {
                      "title": "Next tag: 13",
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "id": {
                          "nullable": true,
                          "type": "string"
                        },
                        "name": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "registry": {
                              "nullable": true,
                              "type": "string"
                            },
                            "remote": {
                              "nullable": true,
                              "type": "string"
                            },
                            "tag": {
                              "nullable": true,
                              "type": "string"
                            },
                            "fullName": {
                              "nullable": true,
                              "type": "string"
                            }
                          }
                        },
                        "notPullable": {
                          "type": "boolean"
                        },
                        "isClusterLocal": {
                          "type": "boolean"
                        },
                        "idV2": {
                          "nullable": true,
                          "type": "string"
                        }
                      }
                    },
                    "securityContext": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "privileged": {
                          "type": "boolean"
                        },
                        "selinux": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "user": {
                              "nullable": true,
                              "type": "string"
                            },
                            "role": {
                              "nullable": true,
                              "type": "string"
                            },
                            "type": {
                              "nullable": true,
                              "type": "string"
                            },
                            "level": {
                              "nullable": true,
                              "type": "string"
                            }
                          }
                        },
                        "dropCapabilities": {
                          "type": "array",
                          "items": {
                            "nullable": true,
                            "type": "string"
                          }
                        },
                        "addCapabilities": {
                          "type": "array",
                          "items": {
                            "nullable": true,
                            "type": "string"
                          }
                        },
                        "readOnlyRootFilesystem": {
                          "type": "boolean"
                        },
                        "seccompProfile": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "type": {
                              "nullable": true,
                              "type": "string",
                              "default": "UNCONFINED",
                              "enum": [
                                "UNCONFINED",
                                "RUNTIME_DEFAULT",
                                "LOCALHOST"
                              ]
                            },
                            "localhostProfile": {
                              "nullable": true,
                              "type": "string"
                            }
                          }
                        },
                        "allowPrivilegeEscalation": {
                          "type": "boolean"
                        }
                      }
                    },
                    "volumes": {
                      "type": "array",
                      "items": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "name": {
                            "nullable": true,
                            "type": "string"
                          },
                          "source": {
                            "nullable": true,
                            "type": "string"
                          },
                          "destination": {
                            "nullable": true,
                            "type": "string"
                          },
                          "readOnly": {
                            "type": "boolean"
                          },
                          "type": {
                            "nullable": true,
                            "type": "string"
                          },
                          "mountPropagation": {
                            "nullable": true,
                            "type": "string",
                            "default": "NONE",
                            "enum": [
                              "NONE",
                              "HOST_TO_CONTAINER",
                              "BIDIRECTIONAL"
                            ]
                          }
                        }
                      }
                    },
                    "ports": {
                      "title": "Policies use the port config on the top-level deployment.",
                      "type": "array",
                      "items": {
                        "title": "Next Available Tag: 6",
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "name": {
                            "nullable": true,
                            "type": "string"
                          },
                          "containerPort": {
                            "type": "integer",
                            "format": "int32"
                          },
                          "protocol": {
                            "nullable": true,
                            "type": "string"
                          },
                          "exposure": {
                            "nullable": true,
                            "type": "string",
                            "default": "UNSET",
                            "enum": [
                              "UNSET",
                              "EXTERNAL",
                              "NODE",
                              "INTERNAL",
                              "HOST",
                              "ROUTE"
                            ]
                          },
                          "exposedPort": {
                            "type": "integer",
                            "format": "int32"
                          },
                          "exposureInfos": {
                            "type": "array",
                            "items": {
                              "nullable": true,
                              "type": "object",
                              "properties": {
                                "level": {
                                  "nullable": true,
                                  "type": "string",
                                  "default": "UNSET",
                                  "enum": [
                                    "UNSET",
                                    "EXTERNAL",
                                    "NODE",
                                    "INTERNAL",
                                    "HOST",
                                    "ROUTE"
                                  ]
                                },
                                "serviceName": {
                                  "title": "only set if level is not HOST",
                                  "nullable": true,
                                  "type": "string"
                                },
                                "serviceId": {
                                  "nullable": true,
                                  "type": "string"
                                },
                                "serviceClusterIp": {
                                  "nullable": true,
                                  "type": "string"
                                },
                                "servicePort": {
                                  "type": "integer",
                                  "format": "int32"
                                },
                                "nodePort": {
                                  "title": "only set if level is HOST, NODE, EXTERNAL or ROUTE",
                                  "type": "integer",
                                  "format": "int32"
                                },
                                "externalIps": {
                                  "title": "only set if level is EXTERNAL",
                                  "type": "array",
                                  "items": {
                                    "nullable": true,
                                    "type": "string"
                                  }
                                },
                                "externalHostnames": {
                                  "title": "only set if level is EXTERNAL or ROUTE",
                                  "type": "array",
                                  "items": {
                                    "nullable": true,
                                    "type": "string"
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    },
                    "secrets": {
                      "type": "array",
                      "items": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "name": {
                            "nullable": true,
                            "type": "string"
                          },
                          "path": {
                            "nullable": true,
                            "type": "string"
                          }
                        }
                      }
                    },
                    "resources": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "cpuCoresRequest": {
                          "type": "number",
                          "format": "float"
                        },
                        "cpuCoresLimit": {
                          "type": "number",
                          "format": "float"
                        },
                        "memoryMbRequest": {
                          "type": "number",
                          "format": "float"
                        },
                        "memoryMbLimit": {
                          "type": "number",
                          "format": "float"
                        }
                      }
                    },
                    "name": {
                      "nullable": true,
                      "type": "string"
                    },
                    "livenessProbe": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "defined": {
                          "type": "boolean"
                        }
                      }
                    },
                    "readinessProbe": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "defined": {
                          "type": "boolean"
                        }
                      }
                    }
                  }
                }
              },
              "annotations": {
                "nullable": true,
                "type": "object",
                "additionalProperties": {
                  "nullable": true,
                  "type": "string"
                }
              },
              "priority": {
                "nullable": true,
                "type": "string",
                "format": "int64"
              },
              "inactive": {
                "type": "boolean"
              },
              "imagePullSecrets": {
                "type": "array",
                "items": {
                  "nullable": true,
                  "type": "string"
                }
              },
              "serviceAccount": {
                "nullable": true,
                "type": "string"
              },
              "serviceAccountPermissionLevel": {
                "title": "For any update to PermissionLevel, also update:\n- pkg/searchbasedpolicies/builders/k8s_rbac.go\n- ui/src/messages/common.js",
                "nullable": true,
                "type": "string",
                "default": "UNSET",
                "enum": [
                  "UNSET",
                  "NONE",
                  "DEFAULT",
                  "ELEVATED_IN_NAMESPACE",
                  "ELEVATED_CLUSTER_WIDE",
                  "CLUSTER_ADMIN"
                ]
              },
              "automountServiceAccountToken": {
                "type": "boolean"
              },
              "hostNetwork": {
                "type": "boolean"
              },
              "hostPid": {
                "type": "boolean"
              },
              "hostIpc": {
                "type": "boolean"
              },
              "runtimeClass": {
                "nullable": true,
                "type": "string"
              },
              "tolerations": {
                "type": "array",
                "items": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "key": {
                      "nullable": true,
                      "type": "string"
                    },
                    "operator": {
                      "nullable": true,
                      "type": "string",
                      "default": "TOLERATION_OPERATION_UNKNOWN",
                      "enum": [
                        "TOLERATION_OPERATION_UNKNOWN",
                        "TOLERATION_OPERATOR_EXISTS",
                        "TOLERATION_OPERATOR_EQUAL"
                      ]
                    },
                    "value": {
                      "nullable": true,
                      "type": "string"
                    },
                    "taintEffect": {
                      "nullable": true,
                      "type": "string",
                      "default": "UNKNOWN_TAINT_EFFECT",
                      "enum": [
                        "UNKNOWN_TAINT_EFFECT",
                        "NO_SCHEDULE_TAINT_EFFECT",
                        "PREFER_NO_SCHEDULE_TAINT_EFFECT",
                        "NO_EXECUTE_TAINT_EFFECT"
                      ]
                    }
                  }
                }
              },
              "ports": {
                "type": "array",
                "items": {
                  "title": "Next Available Tag: 6",
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "name": {
                      "nullable": true,
                      "type": "string"
                    },
                    "containerPort": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "protocol": {
                      "nullable": true,
                      "type": "string"
                    },
                    "exposure": {
                      "nullable": true,
                      "type": "string",
                      "default": "UNSET",
                      "enum": [
                        "UNSET",
                        "EXTERNAL",
                        "NODE",
                        "INTERNAL",
                        "HOST",
                        "ROUTE"
                      ]
                    },
                    "exposedPort": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "exposureInfos": {
                      "type": "array",
                      "items": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "level": {
                            "nullable": true,
                            "type": "string",
                            "default": "UNSET",
                            "enum": [
                              "UNSET",
                              "EXTERNAL",
                              "NODE",
                              "INTERNAL",
                              "HOST",
                              "ROUTE"
                            ]
                          },
                          "serviceName": {
                            "title": "only set if level is not HOST",
                            "nullable": true,
                            "type": "string"
                          },
                          "serviceId": {
                            "nullable": true,
                            "type": "string"
                          },
                          "serviceClusterIp": {
                            "nullable": true,
                            "type": "string"
                          },
                          "servicePort": {
                            "type": "integer",
                            "format": "int32"
                          },
                          "nodePort": {
                            "title": "only set if level is HOST, NODE, EXTERNAL or ROUTE",
                            "type": "integer",
                            "format": "int32"
                          },
                          "externalIps": {
                            "title": "only set if level is EXTERNAL",
                            "type": "array",
                            "items": {
                              "nullable": true,
                              "type": "string"
                            }
                          },
                          "externalHostnames": {
                            "title": "only set if level is EXTERNAL or ROUTE",
                            "type": "array",
                            "items": {
                              "nullable": true,
                              "type": "string"
                            }
                          }
                        }
                      }
                    }
                  }
                }
              },
              "stateTimestamp": {
                "title": "Internal use only",
                "nullable": true,
                "type": "string",
                "format": "int64"
              },
              "riskScore": {
                "type": "number",
                "format": "float"
              },
              "platformComponent": {
                "type": "boolean"
              }
            }
          },
          "risk": {
            "nullable": true,
            "type": "object",
            "properties": {
              "id": {
                "nullable": true,
                "type": "string"
              },
              "subject": {
                "nullable": true,
                "type": "object",
                "properties": {
                  "id": {
                    "nullable": true,
                    "type": "string"
                  },
                  "namespace": {
                    "nullable": true,
                    "type": "string"
                  },
                  "clusterId": {
                    "nullable": true,
                    "type": "string"
                  },
                  "type": {
                    "title": "Next tag: 9",
                    "nullable": true,
                    "type": "string",
                    "default": "UNKNOWN",
                    "enum": [
                      "UNKNOWN",
                      "DEPLOYMENT",
                      "NAMESPACE",
                      "CLUSTER",
                      "NODE",
                      "NODE_COMPONENT",
                      "IMAGE",
                      "IMAGE_COMPONENT",
                      "SERVICEACCOUNT"
                    ]
                  }
                }
              },
              "score": {
                "type": "number",
                "format": "float"
              },
              "results": {
                "type": "array",
                "items": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "name": {
                      "nullable": true,
                      "type": "string"
                    },
                    "factors": {
                      "type": "array",
                      "items": {
                        "nullable": true,
                        "type": "object",
                        "properties": {
                          "message": {
                            "nullable": true,
                            "type": "string"
                          },
                          "url": {
                            "nullable": true,
                            "type": "string"
                          }
                        }
                      }
                    },
                    "score": {
                      "type": "number",
                      "format": "float"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "storageListPolicy": {
        "nullable": true,
        "type": "object",
        "properties": {
          "id": {
            "nullable": true,
            "type": "string"
          },
          "name": {
            "nullable": true,
            "type": "string"
          },
          "description": {
            "nullable": true,
            "type": "string"
          },
          "severity": {
            "nullable": true,
            "type": "string",
            "default": "UNSET_SEVERITY",
            "enum": [
              "UNSET_SEVERITY",
              "LOW_SEVERITY",
              "MEDIUM_SEVERITY",
              "HIGH_SEVERITY",
              "CRITICAL_SEVERITY"
            ]
          },
          "disabled": {
            "type": "boolean"
          },
          "lifecycleStages": {
            "type": "array",
            "items": {
              "nullable": true,
              "type": "string",
              "default": "DEPLOY",
              "enum": [
                "DEPLOY",
                "BUILD",
                "RUNTIME"
              ]
            }
          },
          "notifiers": {
            "type": "array",
            "items": {
              "nullable": true,
              "type": "string"
            }
          },
          "lastUpdated": {
            "nullable": true,
            "type": "string",
            "format": "date-time"
          },
          "eventSource": {
            "nullable": true,
            "type": "string",
            "default": "NOT_APPLICABLE",
            "enum": [
              "NOT_APPLICABLE",
              "DEPLOYMENT_EVENT",
              "AUDIT_LOG_EVENT"
            ]
          },
          "isDefault": {
            "type": "boolean"
          },
          "source": {
            "nullable": true,
            "type": "string",
            "default": "IMPERATIVE",
            "enum": [
              "IMPERATIVE",
              "DECLARATIVE"
            ]
          }
        }
      },
      "v1ListPoliciesResponse": {
        "nullable": true,
        "type": "object",
        "properties": {
          "policies": {
            "type": "array",
            "items": {
              "nullable": true,
              "type": "object",
              "properties": {
                "id": {
                  "nullable": true,
                  "type": "string"
                },
                "name": {
                  "nullable": true,
                  "type": "string"
                },
                "description": {
                  "nullable": true,
                  "type": "string"
                },
                "severity": {
                  "nullable": true,
                  "type": "string",
                  "default": "UNSET_SEVERITY",
                  "enum": [
                    "UNSET_SEVERITY",
                    "LOW_SEVERITY",
                    "MEDIUM_SEVERITY",
                    "HIGH_SEVERITY",
                    "CRITICAL_SEVERITY"
                  ]
                },
                "disabled": {
                  "type": "boolean"
                },
                "lifecycleStages": {
                  "type": "array",
                  "items": {
                    "nullable": true,
                    "type": "string",
                    "default": "DEPLOY",
                    "enum": [
                      "DEPLOY",
                      "BUILD",
                      "RUNTIME"
                    ]
                  }
                },
                "notifiers": {
                  "type": "array",
                  "items": {
                    "nullable": true,
                    "type": "string"
                  }
                },
                "lastUpdated": {
                  "nullable": true,
                  "type": "string",
                  "format": "date-time"
                },
                "eventSource": {
                  "nullable": true,
                  "type": "string",
                  "default": "NOT_APPLICABLE",
                  "enum": [
                    "NOT_APPLICABLE",
                    "DEPLOYMENT_EVENT",
                    "AUDIT_LOG_EVENT"
                  ]
                },
                "isDefault": {
                  "type": "boolean"
                },
                "source": {
                  "nullable": true,
                  "type": "string",
                  "default": "IMPERATIVE",
                  "enum": [
                    "IMPERATIVE",
                    "DECLARATIVE"
                  ]
                }
              }
            }
          }
        }
      },
      "PolicyServicePutPolicyBody": {
        "title": "Next tag: 28",
        "nullable": true,
        "type": "object",
        "properties": {
          "name": {
            "title": "Name of the policy. Must be unique across all policies.\nValidation: 5-128 characters, no newlines or dollar signs\nPattern: ^[^\\n\\r\\$]{5,128}$",
            "nullable": true,
            "type": "string"
          },
          "description": {
            "title": "Free-form text description of this policy.\nValidation: Max 800 characters, no dollar signs\nPattern: ^[^\\$]{0,800}$",
            "nullable": true,
            "type": "string"
          },
          "rationale": {
            "nullable": true,
            "type": "string",
            "description": "Business justification for why this policy exists.\nUsed for compliance and audit purposes."
          },
          "remediation": {
            "nullable": true,
            "type": "string",
            "description": "Describes how to remediate a violation of this policy.\nShould be actionable and specific to the policy type."
          },
          "disabled": {
            "title": "Toggles whether or not this policy will be executing and actively firing alerts.\nDefault: false",
            "type": "boolean"
          },
          "categories": {
            "title": "List of categories that this policy falls under. Category names must already exist in Central.\nValidation: At least one category required, no duplicates",
            "type": "array",
            "items": {
              "nullable": true,
              "type": "string"
            }
          },
          "lifecycleStages": {
            "title": "Describes which policy lifecycle stages this policy applies to. Choices are DEPLOY, BUILD, and RUNTIME.\nValidation: At least one stage required\n- BUILD: Must contain image-related criteria only\n- DEPLOY: Cannot contain runtime criteria\n- RUNTIME: Must contain at least one runtime criterion",
            "type": "array",
            "items": {
              "nullable": true,
              "type": "string",
              "default": "DEPLOY",
              "enum": [
                "DEPLOY",
                "BUILD",
                "RUNTIME"
              ]
            }
          },
          "eventSource": {
            "nullable": true,
            "type": "string",
            "default": "NOT_APPLICABLE",
            "enum": [
              "NOT_APPLICABLE",
              "DEPLOYMENT_EVENT",
              "AUDIT_LOG_EVENT"
            ]
          },
          "exclusions": {
            "title": "Define deployments or images that should be excluded from this policy.\nValidation:\n- Deployment exclusions: Only valid for DEPLOY and RUNTIME lifecycles\n- Image exclusions: Only valid for BUILD lifecycle\n- Must have at least one criteria (name, scope, or image)",
            "type": "array",
            "items": {
              "nullable": true,
              "type": "object",
              "properties": {
                "name": {
                  "nullable": true,
                  "type": "string",
                  "description": "Name of the exclusion. Used for identification and documentation."
                },
                "deployment": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "name": {
                      "title": "Name of the deployment to exclude. Optional if scope is provided.\nValidation: Must be provided if scope is not specified",
                      "nullable": true,
                      "type": "string"
                    },
                    "scope": {
                      "nullable": true,
                      "type": "object",
                      "properties": {
                        "cluster": {
                          "nullable": true,
                          "type": "string"
                        },
                        "namespace": {
                          "nullable": true,
                          "type": "string"
                        },
                        "label": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "key": {
                              "nullable": true,
                              "type": "string"
                            },
                            "value": {
                              "nullable": true,
                              "type": "string"
                            }
                          }
                        }
                      }
                    }
                  }
                },
                "image": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "name": {
                      "title": "Name of the image to exclude.\nValidation: Must be non-empty",
                      "nullable": true,
                      "type": "string"
                    }
                  }
                },
                "expiration": {
                  "nullable": true,
                  "type": "string",
                  "description": "Expiration timestamp for this exclusion.\nWhen expired, the exclusion is automatically removed.",
                  "format": "date-time"
                }
              }
            }
          },
          "scope": {
            "title": "Defines clusters, namespaces, and deployments that should be included in this policy.\nNo scopes defined includes everything.\nValidation: Must have at least one field populated (cluster, namespace, or label)",
            "type": "array",
            "items": {
              "nullable": true,
              "type": "object",
              "properties": {
                "cluster": {
                  "nullable": true,
                  "type": "string"
                },
                "namespace": {
                  "nullable": true,
                  "type": "string"
                },
                "label": {
                  "nullable": true,
                  "type": "object",
                  "properties": {
                    "key": {
                      "nullable": true,
                      "type": "string"
                    },
                    "value": {
                      "nullable": true,
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "severity": {
            "nullable": true,
            "type": "string",
            "default": "UNSET_SEVERITY",
            "enum": [
              "UNSET_SEVERITY",
              "LOW_SEVERITY",
              "MEDIUM_SEVERITY",
              "HIGH_SEVERITY",
              "CRITICAL_SEVERITY"
            ]
          },
          "enforcementActions": {
            "title": "Lists the enforcement actions to take when a violation from this policy is identified.\nValidation: Must be compatible with lifecycle stages\n- FAIL_BUILD_ENFORCEMENT: BUILD lifecycle only\n- SCALE_TO_ZERO_ENFORCEMENT: DEPLOY lifecycle only\n- UNSATISFIABLE_NODE_CONSTRAINT_ENFORCEMENT: DEPLOY lifecycle only\n- KILL_POD_ENFORCEMENT: RUNTIME lifecycle only\n- FAIL_KUBE_REQUEST_ENFORCEMENT: RUNTIME lifecycle only\n- FAIL_DEPLOYMENT_CREATE_ENFORCEMENT: DEPLOY lifecycle only\n- FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT: DEPLOY lifecycle only\n- Audit log policies: No enforcement actions allowed",
            "type": "array",
            "items": {
              "nullable": true,
              "type": "string",
              "description": " - FAIL_KUBE_REQUEST_ENFORCEMENT: FAIL_KUBE_REQUEST_ENFORCEMENT takes effect only if admission control webhook is enabled to listen on exec and port-forward events.\n - FAIL_DEPLOYMENT_CREATE_ENFORCEMENT: FAIL_DEPLOYMENT_CREATE_ENFORCEMENT takes effect only if admission control webhook is configured to enforce on object creates.\n - FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT: FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT takes effect only if admission control webhook is configured to enforce on object updates.",
              "default": "UNSET_ENFORCEMENT",
              "enum": [
                "UNSET_ENFORCEMENT",
                "SCALE_TO_ZERO_ENFORCEMENT",
                "UNSATISFIABLE_NODE_CONSTRAINT_ENFORCEMENT",
                "KILL_POD_ENFORCEMENT",
                "FAIL_BUILD_ENFORCEMENT",
                "FAIL_KUBE_REQUEST_ENFORCEMENT",
                "FAIL_DEPLOYMENT_CREATE_ENFORCEMENT",
                "FAIL_DEPLOYMENT_UPDATE_ENFORCEMENT"
              ]
            }
          },
          "notifiers": {
            "title": "List of IDs of the notifiers that should be triggered when a violation from this policy is identified.\nIDs should be in the form of a UUID and are found through the Central API.\nValidation: All notifier IDs must reference existing notifiers",
            "type": "array",
            "items": {
              "nullable": true,
              "type": "string"
            }
          },
          "lastUpdated": {
            "nullable": true,
            "type": "string",
            "description": "Timestamp when the policy was last updated. Auto-generated during creation/update.",
            "format": "date-time"
          },
          "SORTName": {
            "nullable": true,
            "type": "string",
            "description": "For internal use only."
          },
          "SORTLifecycleStage": {
            "nullable": true,
            "type": "string",
            "description": "For internal use only."
          },
          "SORTEnforcement": {
            "type": "boolean",
            "description": "For internal use only."
          },
          "policyVersion": {
            "title": "Policy version. Must be \"1.1\" (current supported version).\nValidation: Only version 1.1 is supported",
            "nullable": true,
            "type": "string"
          },
          "policySections": {
            "title": "PolicySections define the violation criteria for this policy.\nValidation Requirements:\n- Each section must have a unique sectionName\n- Each policy group must have a valid fieldName and at least one value\n- Field names must be valid for the specified lifecycle stages\n- Values must match the expected format for each field type\n- Boolean operators must be compatible with field requirements\n- Negation must be allowed for the field type\n- Runtime policies must contain at least one runtime criterion\n- Runtime criteria must be in separate sections\n- Audit log policies require both KubeResource and KubeAPIVerb criteria",
            "type": "array",
            "items": {
              "nullable": true,
              "type": "object",
              "properties": {
                "sectionName": {
                  "nullable": true,
                  "type": "string",
                  "description": "Name of the policy section. Must be unique within the policy.\nUsed for organizing policy criteria into logical groups."
                },
                "policyGroups": {
                  "title": "The set of policy groups that make up this section. Each group can be considered an individual criterion.\nValidation Requirements:\n- Each group must have a valid fieldName and at least one value\n- Field names must be valid for the specified lifecycle stages\n- Values must match the expected format for each field type\n- Boolean operators must be compatible with field requirements\n- Negation must be allowed for the field type\n- Runtime criteria must be in separate sections\n- Audit log policies require both KubeResource and KubeAPIVerb criteria",
                  "type": "array",
                  "items": {
                    "nullable": true,
                    "type": "object",
                    "properties": {
                      "fieldName": {
                        "title": "Defines which field on a deployment or image this PolicyGroup evaluates.\nSee https://docs.openshift.com/acs/operating/manage-security-policies.html#policy-criteria_manage-security-policies for a complete list of possible values.\nValidation Requirements:\n- Must be a valid field name for the specified lifecycle stages\n- Field must support the specified boolean operator\n- Field must allow negation if negate=true\n- Field must support multiple values if more than one value is provided\n- Some fields have special restrictions (e.g., ImageSignatureVerifiedBy cannot use AND operator)",
                        "nullable": true,
                        "type": "string"
                      },
                      "booleanOperator": {
                        "nullable": true,
                        "type": "string",
                        "default": "OR",
                        "enum": [
                          "OR",
                          "AND"
                        ]
                      },
                      "negate": {
                        "title": "Determines if the evaluation of this PolicyGroup is negated. Default to false.\nValidation: Must be allowed for the field type\n- Some fields cannot be negated (negationForbidden=true)",
                        "type": "boolean"
                      },
                      "values": {
                        "title": "List of values for the specified field.\nValidation Requirements:\n- Must have at least one value\n- Values must match the expected regex pattern for the field type\n- Some fields only support single values\n- Values must be valid for the field's data type and constraints\n- Environment variable values have special format requirements\n- Dockerfile line values have special restrictions (e.g., no FROM with strict validation)",
                        "type": "array",
                        "items": {
                          "nullable": true,
                          "type": "object",
                          "properties": {
                            "value": {
                              "title": "The actual value for the policy criterion.\nValidation: Must match the expected format for the field type\nExamples:\n- CVE: \"CVE-2021-1234\"\n- Image Tag: \"latest\"\n- Environment Variable: \"UNSET=key=value\" or \"SECRET_KEY=key=\"\n- Dockerfile Line: \"ADD=.\" or \"RUN=apt-get update\"\n- Process Name: \"nginx\"\n- Network Flow: \"tcp:80\"",
                              "nullable": true,
                              "type": "string"
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          },
          "mitreAttackVectors": {
            "type": "array",
            "description": "MITRE ATT&CK framework mappings for this policy.\nUsed for threat intelligence and compliance reporting.",
            "items": {
              "nullable": true,
              "type": "object",
              "properties": {
                "tactic": {
                  "nullable": true,
                  "type": "string"
                },
                "techniques": {
                  "type": "array",
                  "items": {
                    "nullable": true,
                    "type": "string"
                  }
                }
              }
            }
          },
          "criteriaLocked": {
            "type": "boolean",
            "description": "Read-only field. If true, the policy's criteria fields are rendered read-only."
          },
          "mitreVectorsLocked": {
            "type": "boolean",
            "description": "Read-only field. If true, the policy's MITRE ATT&CK fields are rendered read-only."
          },
          "isDefault": {
            "type": "boolean",
            "description": "Read-only field. Indicates the policy is a default policy if true and a custom policy if false."
          },
          "source": {
            "nullable": true,
            "type": "string",
            "default": "IMPERATIVE",
            "enum": [
              "IMPERATIVE",
              "DECLARATIVE"
            ]
          }
        }
      },
      "PolicyServicePatchPolicyBody": {
        "nullable": true,
        "type": "object",
        "properties": {
          "disabled": {
            "type": "boolean"
          }
        }
      }
    }
  },
  "x-original-swagger-version": "2.0"
}
